(function() {
    var lastTime = 0;
    var vendors = [ "ms", "moz", "webkit", "o" ];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
    }
    if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
})();

var Stats = function() {
    var l = Date.now(), m = l, g = 0, n = Infinity, o = 0, h = 0, p = Infinity, q = 0, r = 0, s = 0, f = document.createElement("div");
    f.id = "stats";
    f.addEventListener("mousedown", function(b) {
        b.preventDefault();
        t(++s % 2);
    }, !1);
    f.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
    var a = document.createElement("div");
    a.id = "fps";
    a.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002";
    f.appendChild(a);
    var i = document.createElement("div");
    i.id = "fpsText";
    i.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
    i.innerHTML = "FPS";
    a.appendChild(i);
    var c = document.createElement("div");
    c.id = "fpsGraph";
    c.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff";
    for (a.appendChild(c); 74 > c.children.length; ) {
        var j = document.createElement("span");
        j.style.cssText = "width:1px;height:30px;float:left;background-color:#113";
        c.appendChild(j);
    }
    var d = document.createElement("div");
    d.id = "ms";
    d.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";
    f.appendChild(d);
    var k = document.createElement("div");
    k.id = "msText";
    k.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
    k.innerHTML = "MS";
    d.appendChild(k);
    var e = document.createElement("div");
    e.id = "msGraph";
    e.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0";
    for (d.appendChild(e); 74 > e.children.length; ) j = document.createElement("span"), 
    j.style.cssText = "width:1px;height:30px;float:left;background-color:#131", e.appendChild(j);
    var t = function(b) {
        s = b;
        switch (s) {
          case 0:
            a.style.display = "block";
            d.style.display = "none";
            break;

          case 1:
            a.style.display = "none", d.style.display = "block";
        }
    };
    return {
        REVISION: 11,
        domElement: f,
        setMode: t,
        begin: function() {
            l = Date.now();
        },
        end: function() {
            var b = Date.now();
            g = b - l;
            n = Math.min(n, g);
            o = Math.max(o, g);
            k.textContent = g + " MS (" + n + "-" + o + ")";
            var a = Math.min(30, 30 - 30 * (g / 200));
            e.appendChild(e.firstChild).style.height = a + "px";
            r++;
            b > m + 1e3 && (h = Math.round(1e3 * r / (b - m)), p = Math.min(p, h), q = Math.max(q, h), 
            i.textContent = h + " FPS (" + p + "-" + q + ")", a = Math.min(30, 30 - 30 * (h / 100)), 
            c.appendChild(c.firstChild).style.height = a + "px", m = b, r = 0);
            return b;
        },
        update: function() {
            l = this.end();
        }
    };
};

var THREE = {
    REVISION: "71"
};

if (typeof module === "object") {
    module.exports = THREE;
}

if (Math.sign === undefined) {
    Math.sign = function(x) {
        return x < 0 ? -1 : x > 0 ? 1 : +x;
    };
}

THREE.log = function() {
    console.log.apply(console, arguments);
};

THREE.warn = function() {
    console.warn.apply(console, arguments);
};

THREE.error = function() {
    console.error.apply(console, arguments);
};

THREE.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};

THREE.CullFaceNone = 0;

THREE.CullFaceBack = 1;

THREE.CullFaceFront = 2;

THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;

THREE.FrontFaceDirectionCCW = 1;

THREE.BasicShadowMap = 0;

THREE.PCFShadowMap = 1;

THREE.PCFSoftShadowMap = 2;

THREE.FrontSide = 0;

THREE.BackSide = 1;

THREE.DoubleSide = 2;

THREE.NoShading = 0;

THREE.FlatShading = 1;

THREE.SmoothShading = 2;

THREE.NoColors = 0;

THREE.FaceColors = 1;

THREE.VertexColors = 2;

THREE.NoBlending = 0;

THREE.NormalBlending = 1;

THREE.AdditiveBlending = 2;

THREE.SubtractiveBlending = 3;

THREE.MultiplyBlending = 4;

THREE.CustomBlending = 5;

THREE.AddEquation = 100;

THREE.SubtractEquation = 101;

THREE.ReverseSubtractEquation = 102;

THREE.MinEquation = 103;

THREE.MaxEquation = 104;

THREE.ZeroFactor = 200;

THREE.OneFactor = 201;

THREE.SrcColorFactor = 202;

THREE.OneMinusSrcColorFactor = 203;

THREE.SrcAlphaFactor = 204;

THREE.OneMinusSrcAlphaFactor = 205;

THREE.DstAlphaFactor = 206;

THREE.OneMinusDstAlphaFactor = 207;

THREE.DstColorFactor = 208;

THREE.OneMinusDstColorFactor = 209;

THREE.SrcAlphaSaturateFactor = 210;

THREE.MultiplyOperation = 0;

THREE.MixOperation = 1;

THREE.AddOperation = 2;

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;

THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;

THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

THREE.RepeatWrapping = 1e3;

THREE.ClampToEdgeWrapping = 1001;

THREE.MirroredRepeatWrapping = 1002;

THREE.NearestFilter = 1003;

THREE.NearestMipMapNearestFilter = 1004;

THREE.NearestMipMapLinearFilter = 1005;

THREE.LinearFilter = 1006;

THREE.LinearMipMapNearestFilter = 1007;

THREE.LinearMipMapLinearFilter = 1008;

THREE.UnsignedByteType = 1009;

THREE.ByteType = 1010;

THREE.ShortType = 1011;

THREE.UnsignedShortType = 1012;

THREE.IntType = 1013;

THREE.UnsignedIntType = 1014;

THREE.FloatType = 1015;

THREE.HalfFloatType = 1025;

THREE.UnsignedShort4444Type = 1016;

THREE.UnsignedShort5551Type = 1017;

THREE.UnsignedShort565Type = 1018;

THREE.AlphaFormat = 1019;

THREE.RGBFormat = 1020;

THREE.RGBAFormat = 1021;

THREE.LuminanceFormat = 1022;

THREE.LuminanceAlphaFormat = 1023;

THREE.RGBEFormat = THREE.RGBAFormat;

THREE.RGB_S3TC_DXT1_Format = 2001;

THREE.RGBA_S3TC_DXT1_Format = 2002;

THREE.RGBA_S3TC_DXT3_Format = 2003;

THREE.RGBA_S3TC_DXT5_Format = 2004;

THREE.RGB_PVRTC_4BPPV1_Format = 2100;

THREE.RGB_PVRTC_2BPPV1_Format = 2101;

THREE.RGBA_PVRTC_4BPPV1_Format = 2102;

THREE.RGBA_PVRTC_2BPPV1_Format = 2103;

THREE.Projector = function() {
    THREE.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
    this.projectVector = function(vector, camera) {
        THREE.warn("THREE.Projector: .projectVector() is now vector.project().");
        vector.project(camera);
    };
    this.unprojectVector = function(vector, camera) {
        THREE.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
        vector.unproject(camera);
    };
    this.pickingRay = function(vector, camera) {
        THREE.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
    };
};

THREE.CanvasRenderer = function() {
    THREE.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
    this.domElement = document.createElement("canvas");
    this.clear = function() {};
    this.render = function() {};
    this.setClearColor = function() {};
    this.setSize = function() {};
};

THREE.Color = function(color) {
    if (arguments.length === 3) {
        return this.setRGB(arguments[0], arguments[1], arguments[2]);
    }
    return this.set(color);
};

THREE.Color.prototype = {
    constructor: THREE.Color,
    r: 1,
    g: 1,
    b: 1,
    set: function(value) {
        if (value instanceof THREE.Color) {
            this.copy(value);
        } else if (typeof value === "number") {
            this.setHex(value);
        } else if (typeof value === "string") {
            this.setStyle(value);
        }
        return this;
    },
    setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    },
    setRGB: function(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    },
    setHSL: function(h, s, l) {
        if (s === 0) {
            this.r = this.g = this.b = l;
        } else {
            var hue2rgb = function(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
                return p;
            };
            var p = l <= .5 ? l * (1 + s) : l + s - l * s;
            var q = 2 * l - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
    },
    setStyle: function(style) {
        if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(style)) {
            var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(style);
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            return this;
        }
        if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(style)) {
            var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(style);
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            return this;
        }
        if (/^\#([0-9a-f]{6})$/i.test(style)) {
            var color = /^\#([0-9a-f]{6})$/i.exec(style);
            this.setHex(parseInt(color[1], 16));
            return this;
        }
        if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(style)) {
            var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(style);
            this.setHex(parseInt(color[1] + color[1] + color[2] + color[2] + color[3] + color[3], 16));
            return this;
        }
        if (/^(\w+)$/i.test(style)) {
            this.setHex(THREE.ColorKeywords[style]);
            return this;
        }
    },
    copy: function(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    },
    copyGammaToLinear: function(color, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
    },
    copyLinearToGamma: function(color, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2;
        var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
    },
    convertGammaToLinear: function() {
        var r = this.r, g = this.g, b = this.b;
        this.r = r * r;
        this.g = g * g;
        this.b = b * b;
        return this;
    },
    convertLinearToGamma: function() {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this;
    },
    getHex: function() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    },
    getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(optionalTarget) {
        var hsl = optionalTarget || {
            h: 0,
            s: 0,
            l: 0
        };
        var r = this.r, g = this.g, b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue, saturation;
        var lightness = (min + max) / 2;
        if (min === max) {
            hue = 0;
            saturation = 0;
        } else {
            var delta = max - min;
            saturation = lightness <= .5 ? delta / (max + min) : delta / (2 - max - min);
            switch (max) {
              case r:
                hue = (g - b) / delta + (g < b ? 6 : 0);
                break;

              case g:
                hue = (b - r) / delta + 2;
                break;

              case b:
                hue = (r - g) / delta + 4;
                break;
            }
            hue /= 6;
        }
        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;
        return hsl;
    },
    getStyle: function() {
        return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
    },
    offsetHSL: function(h, s, l) {
        var hsl = this.getHSL();
        hsl.h += h;
        hsl.s += s;
        hsl.l += l;
        this.setHSL(hsl.h, hsl.s, hsl.l);
        return this;
    },
    add: function(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
    },
    addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    },
    addScalar: function(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    },
    multiply: function(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
    },
    multiplyScalar: function(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    },
    lerp: function(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
    },
    equals: function(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
    },
    fromArray: function(array) {
        this.r = array[0];
        this.g = array[1];
        this.b = array[2];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    },
    clone: function() {
        return new THREE.Color().setRGB(this.r, this.g, this.b);
    }
};

THREE.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
};

THREE.Quaternion = function(x, y, z, w) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = w !== undefined ? w : 1;
};

THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion,
    _x: 0,
    _y: 0,
    _z: 0,
    _w: 0,
    get x() {
        return this._x;
    },
    set x(value) {
        this._x = value;
        this.onChangeCallback();
    },
    get y() {
        return this._y;
    },
    set y(value) {
        this._y = value;
        this.onChangeCallback();
    },
    get z() {
        return this._z;
    },
    set z(value) {
        this._z = value;
        this.onChangeCallback();
    },
    get w() {
        return this._w;
    },
    set w(value) {
        this._w = value;
        this.onChangeCallback();
    },
    set: function(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this.onChangeCallback();
        return this;
    },
    copy: function(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this.onChangeCallback();
        return this;
    },
    setFromEuler: function(euler, update) {
        if (euler instanceof THREE.Euler === false) {
            throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        }
        var c1 = Math.cos(euler._x / 2);
        var c2 = Math.cos(euler._y / 2);
        var c3 = Math.cos(euler._z / 2);
        var s1 = Math.sin(euler._x / 2);
        var s2 = Math.sin(euler._y / 2);
        var s3 = Math.sin(euler._z / 2);
        if (euler.order === "XYZ") {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (euler.order === "YXZ") {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (euler.order === "ZXY") {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (euler.order === "ZYX") {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (euler.order === "YZX") {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (euler.order === "XZY") {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        if (update !== false) this.onChangeCallback();
        return this;
    },
    setFromAxisAngle: function(axis, angle) {
        var halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this.onChangeCallback();
        return this;
    },
    setFromRotationMatrix: function(m) {
        var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
        if (trace > 0) {
            s = .5 / Math.sqrt(trace + 1);
            this._w = .25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = .25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
            s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = .25 * s;
            this._z = (m23 + m32) / s;
        } else {
            s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = .25 * s;
        }
        this.onChangeCallback();
        return this;
    },
    setFromUnitVectors: function() {
        var v1, r;
        var EPS = 1e-6;
        return function(vFrom, vTo) {
            if (v1 === undefined) v1 = new THREE.Vector3();
            r = vFrom.dot(vTo) + 1;
            if (r < EPS) {
                r = 0;
                if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                    v1.set(-vFrom.y, vFrom.x, 0);
                } else {
                    v1.set(0, -vFrom.z, vFrom.y);
                }
            } else {
                v1.crossVectors(vFrom, vTo);
            }
            this._x = v1.x;
            this._y = v1.y;
            this._z = v1.z;
            this._w = r;
            this.normalize();
            return this;
        };
    }(),
    inverse: function() {
        this.conjugate().normalize();
        return this;
    },
    conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this.onChangeCallback();
        return this;
    },
    dot: function(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    },
    lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    },
    normalize: function() {
        var l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this.onChangeCallback();
        return this;
    },
    multiply: function(q, p) {
        if (p !== undefined) {
            THREE.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    },
    multiplyQuaternions: function(a, b) {
        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this.onChangeCallback();
        return this;
    },
    multiplyVector3: function(vector) {
        THREE.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return vector.applyQuaternion(this);
    },
    slerp: function(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        var x = this._x, y = this._y, z = this._z, w = this._w;
        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        } else {
            this.copy(qb);
        }
        if (cosHalfTheta >= 1) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
        }
        var halfTheta = Math.acos(cosHalfTheta);
        var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
        if (Math.abs(sinHalfTheta) < .001) {
            this._w = .5 * (w + this._w);
            this._x = .5 * (x + this._x);
            this._y = .5 * (y + this._y);
            this._z = .5 * (z + this._z);
            return this;
        }
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this.onChangeCallback();
        return this;
    },
    equals: function(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this.onChangeCallback();
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    },
    onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
    },
    onChangeCallback: function() {},
    clone: function() {
        return new THREE.Quaternion(this._x, this._y, this._z, this._w);
    }
};

THREE.Quaternion.slerp = function(qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
};

THREE.Vector2 = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
};

THREE.Vector2.prototype = {
    constructor: THREE.Vector2,
    set: function(x, y) {
        this.x = x;
        this.y = y;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;

          case 1:
            this.y = value;
            break;

          default:
            throw new Error("index is out of range: " + index);
        }
    },
    getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          default:
            throw new Error("index is out of range: " + index);
        }
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    },
    add: function(v, w) {
        if (w !== undefined) {
            THREE.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    },
    sub: function(v, w) {
        if (w !== undefined) {
            THREE.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    },
    subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    },
    multiply: function(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    },
    multiplyScalar: function(s) {
        this.x *= s;
        this.y *= s;
        return this;
    },
    divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    },
    divideScalar: function(scalar) {
        if (scalar !== 0) {
            var invScalar = 1 / scalar;
            this.x *= invScalar;
            this.y *= invScalar;
        } else {
            this.x = 0;
            this.y = 0;
        }
        return this;
    },
    min: function(v) {
        if (this.x > v.x) {
            this.x = v.x;
        }
        if (this.y > v.y) {
            this.y = v.y;
        }
        return this;
    },
    max: function(v) {
        if (this.x < v.x) {
            this.x = v.x;
        }
        if (this.y < v.y) {
            this.y = v.y;
        }
        return this;
    },
    clamp: function(min, max) {
        if (this.x < min.x) {
            this.x = min.x;
        } else if (this.x > max.x) {
            this.x = max.x;
        }
        if (this.y < min.y) {
            this.y = min.y;
        } else if (this.y > max.y) {
            this.y = max.y;
        }
        return this;
    },
    clampScalar: function() {
        var min, max;
        return function(minVal, maxVal) {
            if (min === undefined) {
                min = new THREE.Vector2();
                max = new THREE.Vector2();
            }
            min.set(minVal, minVal);
            max.set(maxVal, maxVal);
            return this.clamp(min, max);
        };
    }(),
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    },
    roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    },
    setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
            this.multiplyScalar(l / oldLength);
        }
        return this;
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    },
    lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    },
    fromAttribute: function(attribute, index, offset) {
        if (offset === undefined) offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        return this;
    },
    clone: function() {
        return new THREE.Vector2(this.x, this.y);
    }
};

THREE.Vector3 = function(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
};

THREE.Vector3.prototype = {
    constructor: THREE.Vector3,
    set: function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setZ: function(z) {
        this.z = z;
        return this;
    },
    setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;

          case 1:
            this.y = value;
            break;

          case 2:
            this.z = value;
            break;

          default:
            throw new Error("index is out of range: " + index);
        }
    },
    getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          case 2:
            return this.z;

          default:
            throw new Error("index is out of range: " + index);
        }
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    },
    add: function(v, w) {
        if (w !== undefined) {
            THREE.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    },
    sub: function(v, w) {
        if (w !== undefined) {
            THREE.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    },
    subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    },
    multiply: function(v, w) {
        if (w !== undefined) {
            THREE.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    },
    multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    },
    multiplyVectors: function(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    },
    applyEuler: function() {
        var quaternion;
        return function(euler) {
            if (euler instanceof THREE.Euler === false) {
                THREE.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.");
            }
            if (quaternion === undefined) quaternion = new THREE.Quaternion();
            this.applyQuaternion(quaternion.setFromEuler(euler));
            return this;
        };
    }(),
    applyAxisAngle: function() {
        var quaternion;
        return function(axis, angle) {
            if (quaternion === undefined) quaternion = new THREE.Quaternion();
            this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
            return this;
        };
    }(),
    applyMatrix3: function(m) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
    },
    applyMatrix4: function(m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return this;
    },
    applyProjection: function(m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
        return this;
    },
    applyQuaternion: function(q) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    },
    project: function() {
        var matrix;
        return function(camera) {
            if (matrix === undefined) matrix = new THREE.Matrix4();
            matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
            return this.applyProjection(matrix);
        };
    }(),
    unproject: function() {
        var matrix;
        return function(camera) {
            if (matrix === undefined) matrix = new THREE.Matrix4();
            matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
            return this.applyProjection(matrix);
        };
    }(),
    transformDirection: function(m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        this.normalize();
        return this;
    },
    divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    },
    divideScalar: function(scalar) {
        if (scalar !== 0) {
            var invScalar = 1 / scalar;
            this.x *= invScalar;
            this.y *= invScalar;
            this.z *= invScalar;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }
        return this;
    },
    min: function(v) {
        if (this.x > v.x) {
            this.x = v.x;
        }
        if (this.y > v.y) {
            this.y = v.y;
        }
        if (this.z > v.z) {
            this.z = v.z;
        }
        return this;
    },
    max: function(v) {
        if (this.x < v.x) {
            this.x = v.x;
        }
        if (this.y < v.y) {
            this.y = v.y;
        }
        if (this.z < v.z) {
            this.z = v.z;
        }
        return this;
    },
    clamp: function(min, max) {
        if (this.x < min.x) {
            this.x = min.x;
        } else if (this.x > max.x) {
            this.x = max.x;
        }
        if (this.y < min.y) {
            this.y = min.y;
        } else if (this.y > max.y) {
            this.y = max.y;
        }
        if (this.z < min.z) {
            this.z = min.z;
        } else if (this.z > max.z) {
            this.z = max.z;
        }
        return this;
    },
    clampScalar: function() {
        var min, max;
        return function(minVal, maxVal) {
            if (min === undefined) {
                min = new THREE.Vector3();
                max = new THREE.Vector3();
            }
            min.set(minVal, minVal, minVal);
            max.set(maxVal, maxVal, maxVal);
            return this.clamp(min, max);
        };
    }(),
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    },
    roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
            this.multiplyScalar(l / oldLength);
        }
        return this;
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    },
    lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
    },
    cross: function(v, w) {
        if (w !== undefined) {
            THREE.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
            return this.crossVectors(v, w);
        }
        var x = this.x, y = this.y, z = this.z;
        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;
        return this;
    },
    crossVectors: function(a, b) {
        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    },
    projectOnVector: function() {
        var v1, dot;
        return function(vector) {
            if (v1 === undefined) v1 = new THREE.Vector3();
            v1.copy(vector).normalize();
            dot = this.dot(v1);
            return this.copy(v1).multiplyScalar(dot);
        };
    }(),
    projectOnPlane: function() {
        var v1;
        return function(planeNormal) {
            if (v1 === undefined) v1 = new THREE.Vector3();
            v1.copy(this).projectOnVector(planeNormal);
            return this.sub(v1);
        };
    }(),
    reflect: function() {
        var v1;
        return function(normal) {
            if (v1 === undefined) v1 = new THREE.Vector3();
            return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
        };
    }(),
    angleTo: function(v) {
        var theta = this.dot(v) / (this.length() * v.length());
        return Math.acos(THREE.Math.clamp(theta, -1, 1));
    },
    distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    },
    setEulerFromRotationMatrix: function(m, order) {
        THREE.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    },
    setEulerFromQuaternion: function(q, order) {
        THREE.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    },
    getPositionFromMatrix: function(m) {
        THREE.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m);
    },
    getScaleFromMatrix: function(m) {
        THREE.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m);
    },
    getColumnFromMatrix: function(index, matrix) {
        THREE.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(index, matrix);
    },
    setFromMatrixPosition: function(m) {
        this.x = m.elements[12];
        this.y = m.elements[13];
        this.z = m.elements[14];
        return this;
    },
    setFromMatrixScale: function(m) {
        var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
        var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
        var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    },
    setFromMatrixColumn: function(index, matrix) {
        var offset = index * 4;
        var me = matrix.elements;
        this.x = me[offset];
        this.y = me[offset + 1];
        this.z = me[offset + 2];
        return this;
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    },
    fromAttribute: function(attribute, index, offset) {
        if (offset === undefined) offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        return this;
    },
    clone: function() {
        return new THREE.Vector3(this.x, this.y, this.z);
    }
};

THREE.Vector4 = function(x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w !== undefined ? w : 1;
};

THREE.Vector4.prototype = {
    constructor: THREE.Vector4,
    set: function(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setZ: function(z) {
        this.z = z;
        return this;
    },
    setW: function(w) {
        this.w = w;
        return this;
    },
    setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;

          case 1:
            this.y = value;
            break;

          case 2:
            this.z = value;
            break;

          case 3:
            this.w = value;
            break;

          default:
            throw new Error("index is out of range: " + index);
        }
    },
    getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          case 2:
            return this.z;

          case 3:
            return this.w;

          default:
            throw new Error("index is out of range: " + index);
        }
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    },
    add: function(v, w) {
        if (w !== undefined) {
            THREE.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    },
    sub: function(v, w) {
        if (w !== undefined) {
            THREE.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    },
    subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    },
    multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    },
    applyMatrix4: function(m) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
    },
    divideScalar: function(scalar) {
        if (scalar !== 0) {
            var invScalar = 1 / scalar;
            this.x *= invScalar;
            this.y *= invScalar;
            this.z *= invScalar;
            this.w *= invScalar;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
        }
        return this;
    },
    setAxisAngleFromQuaternion: function(q) {
        this.w = 2 * Math.acos(q.w);
        var s = Math.sqrt(1 - q.w * q.w);
        if (s < 1e-4) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    },
    setAxisAngleFromRotationMatrix: function(m) {
        var angle, x, y, z, epsilon = .01, epsilon2 = .1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                this.set(1, 0, 0, 0);
                return this;
            }
            angle = Math.PI;
            var xx = (m11 + 1) / 2;
            var yy = (m22 + 1) / 2;
            var zz = (m33 + 1) / 2;
            var xy = (m12 + m21) / 4;
            var xz = (m13 + m31) / 4;
            var yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                if (xx < epsilon) {
                    x = 0;
                    y = .707106781;
                    z = .707106781;
                } else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                }
            } else if (yy > zz) {
                if (yy < epsilon) {
                    x = .707106781;
                    y = 0;
                    z = .707106781;
                } else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                }
            } else {
                if (zz < epsilon) {
                    x = .707106781;
                    y = .707106781;
                    z = 0;
                } else {
                    z = Math.sqrt(zz);
                    x = xz / z;
                    y = yz / z;
                }
            }
            this.set(x, y, z, angle);
            return this;
        }
        var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < .001) s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    },
    min: function(v) {
        if (this.x > v.x) {
            this.x = v.x;
        }
        if (this.y > v.y) {
            this.y = v.y;
        }
        if (this.z > v.z) {
            this.z = v.z;
        }
        if (this.w > v.w) {
            this.w = v.w;
        }
        return this;
    },
    max: function(v) {
        if (this.x < v.x) {
            this.x = v.x;
        }
        if (this.y < v.y) {
            this.y = v.y;
        }
        if (this.z < v.z) {
            this.z = v.z;
        }
        if (this.w < v.w) {
            this.w = v.w;
        }
        return this;
    },
    clamp: function(min, max) {
        if (this.x < min.x) {
            this.x = min.x;
        } else if (this.x > max.x) {
            this.x = max.x;
        }
        if (this.y < min.y) {
            this.y = min.y;
        } else if (this.y > max.y) {
            this.y = max.y;
        }
        if (this.z < min.z) {
            this.z = min.z;
        } else if (this.z > max.z) {
            this.z = max.z;
        }
        if (this.w < min.w) {
            this.w = min.w;
        } else if (this.w > max.w) {
            this.w = max.w;
        }
        return this;
    },
    clampScalar: function() {
        var min, max;
        return function(minVal, maxVal) {
            if (min === undefined) {
                min = new THREE.Vector4();
                max = new THREE.Vector4();
            }
            min.set(minVal, minVal, minVal, minVal);
            max.set(maxVal, maxVal, maxVal, maxVal);
            return this.clamp(min, max);
        };
    }(),
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    },
    roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
            this.multiplyScalar(l / oldLength);
        }
        return this;
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    },
    lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    },
    fromAttribute: function(attribute, index, offset) {
        if (offset === undefined) offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        this.w = attribute.array[index + 3];
        return this;
    },
    clone: function() {
        return new THREE.Vector4(this.x, this.y, this.z, this.w);
    }
};

THREE.Euler = function(x, y, z, order) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || THREE.Euler.DefaultOrder;
};

THREE.Euler.RotationOrders = [ "XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX" ];

THREE.Euler.DefaultOrder = "XYZ";

THREE.Euler.prototype = {
    constructor: THREE.Euler,
    _x: 0,
    _y: 0,
    _z: 0,
    _order: THREE.Euler.DefaultOrder,
    get x() {
        return this._x;
    },
    set x(value) {
        this._x = value;
        this.onChangeCallback();
    },
    get y() {
        return this._y;
    },
    set y(value) {
        this._y = value;
        this.onChangeCallback();
    },
    get z() {
        return this._z;
    },
    set z(value) {
        this._z = value;
        this.onChangeCallback();
    },
    get order() {
        return this._order;
    },
    set order(value) {
        this._order = value;
        this.onChangeCallback();
    },
    set: function(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this.onChangeCallback();
        return this;
    },
    copy: function(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this.onChangeCallback();
        return this;
    },
    setFromRotationMatrix: function(m, order, update) {
        var clamp = THREE.Math.clamp;
        var te = m.elements;
        var m11 = te[0], m12 = te[4], m13 = te[8];
        var m21 = te[1], m22 = te[5], m23 = te[9];
        var m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        if (order === "XYZ") {
            this._y = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < .99999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
            } else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
            }
        } else if (order === "YXZ") {
            this._x = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < .99999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
            } else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
            }
        } else if (order === "ZXY") {
            this._x = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < .99999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
            } else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
            }
        } else if (order === "ZYX") {
            this._y = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < .99999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
            } else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
            }
        } else if (order === "YZX") {
            this._z = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < .99999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
            } else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
            }
        } else if (order === "XZY") {
            this._z = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < .99999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
            } else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
            }
        } else {
            THREE.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order);
        }
        this._order = order;
        if (update !== false) this.onChangeCallback();
        return this;
    },
    setFromQuaternion: function() {
        var matrix;
        return function(q, order, update) {
            if (matrix === undefined) matrix = new THREE.Matrix4();
            matrix.makeRotationFromQuaternion(q);
            this.setFromRotationMatrix(matrix, order, update);
            return this;
        };
    }(),
    setFromVector3: function(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
    },
    reorder: function() {
        var q = new THREE.Quaternion();
        return function(newOrder) {
            q.setFromEuler(this);
            this.setFromQuaternion(q, newOrder);
        };
    }(),
    equals: function(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    },
    fromArray: function(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this.onChangeCallback();
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    },
    toVector3: function(optionalResult) {
        if (optionalResult) {
            return optionalResult.set(this._x, this._y, this._z);
        } else {
            return new THREE.Vector3(this._x, this._y, this._z);
        }
    },
    onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
    },
    onChangeCallback: function() {},
    clone: function() {
        return new THREE.Euler(this._x, this._y, this._z, this._order);
    }
};

THREE.Line3 = function(start, end) {
    this.start = start !== undefined ? start : new THREE.Vector3();
    this.end = end !== undefined ? end : new THREE.Vector3();
};

THREE.Line3.prototype = {
    constructor: THREE.Line3,
    set: function(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    },
    copy: function(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    },
    center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.start, this.end).multiplyScalar(.5);
    },
    delta: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors(this.end, this.start);
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end);
    },
    distance: function() {
        return this.start.distanceTo(this.end);
    },
    at: function(t, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function() {
        var startP = new THREE.Vector3();
        var startEnd = new THREE.Vector3();
        return function(point, clampToLine) {
            startP.subVectors(point, this.start);
            startEnd.subVectors(this.end, this.start);
            var startEnd2 = startEnd.dot(startEnd);
            var startEnd_startP = startEnd.dot(startP);
            var t = startEnd_startP / startEnd2;
            if (clampToLine) {
                t = THREE.Math.clamp(t, 0, 1);
            }
            return t;
        };
    }(),
    closestPointToPoint: function(point, clampToLine, optionalTarget) {
        var t = this.closestPointToPointParameter(point, clampToLine);
        var result = optionalTarget || new THREE.Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    },
    equals: function(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    },
    clone: function() {
        return new THREE.Line3().copy(this);
    }
};

THREE.Box2 = function(min, max) {
    this.min = min !== undefined ? min : new THREE.Vector2(Infinity, Infinity);
    this.max = max !== undefined ? max : new THREE.Vector2(-Infinity, -Infinity);
};

THREE.Box2.prototype = {
    constructor: THREE.Box2,
    set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromPoints: function(points) {
        this.makeEmpty();
        for (var i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
        }
        return this;
    },
    setFromCenterAndSize: function() {
        var v1 = new THREE.Vector2();
        return function(center, size) {
            var halfSize = v1.copy(size).multiplyScalar(.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        };
    }(),
    copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    },
    empty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.addVectors(this.min, this.max).multiplyScalar(.5);
    },
    size: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    containsPoint: function(point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
            return false;
        }
        return true;
    },
    containsBox: function(box) {
        if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y) {
            return true;
        }
        return false;
    },
    getParameter: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    },
    isIntersectionBox: function(box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
            return false;
        }
        return true;
    },
    clampPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
        var v1 = new THREE.Vector2();
        return function(point) {
            var clampedPoint = v1.copy(point).clamp(this.min, this.max);
            return clampedPoint.sub(point).length();
        };
    }(),
    intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    },
    union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    },
    clone: function() {
        return new THREE.Box2().copy(this);
    }
};

THREE.Box3 = function(min, max) {
    this.min = min !== undefined ? min : new THREE.Vector3(Infinity, Infinity, Infinity);
    this.max = max !== undefined ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
};

THREE.Box3.prototype = {
    constructor: THREE.Box3,
    set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromPoints: function(points) {
        this.makeEmpty();
        for (var i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
        }
        return this;
    },
    setFromCenterAndSize: function() {
        var v1 = new THREE.Vector3();
        return function(center, size) {
            var halfSize = v1.copy(size).multiplyScalar(.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        };
    }(),
    setFromObject: function() {
        var v1 = new THREE.Vector3();
        return function(object) {
            var scope = this;
            object.updateMatrixWorld(true);
            this.makeEmpty();
            object.traverse(function(node) {
                var geometry = node.geometry;
                if (geometry !== undefined) {
                    if (geometry instanceof THREE.Geometry) {
                        var vertices = geometry.vertices;
                        for (var i = 0, il = vertices.length; i < il; i++) {
                            v1.copy(vertices[i]);
                            v1.applyMatrix4(node.matrixWorld);
                            scope.expandByPoint(v1);
                        }
                    } else if (geometry instanceof THREE.BufferGeometry && geometry.attributes["position"] !== undefined) {
                        var positions = geometry.attributes["position"].array;
                        for (var i = 0, il = positions.length; i < il; i += 3) {
                            v1.set(positions[i], positions[i + 1], positions[i + 2]);
                            v1.applyMatrix4(node.matrixWorld);
                            scope.expandByPoint(v1);
                        }
                    }
                }
            });
            return this;
        };
    }(),
    copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    },
    empty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.min, this.max).multiplyScalar(.5);
    },
    size: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    containsPoint: function(point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
            return false;
        }
        return true;
    },
    containsBox: function(box) {
        if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z) {
            return true;
        }
        return false;
    },
    getParameter: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    },
    isIntersectionBox: function(box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
            return false;
        }
        return true;
    },
    clampPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
        var v1 = new THREE.Vector3();
        return function(point) {
            var clampedPoint = v1.copy(point).clamp(this.min, this.max);
            return clampedPoint.sub(point).length();
        };
    }(),
    getBoundingSphere: function() {
        var v1 = new THREE.Vector3();
        return function(optionalTarget) {
            var result = optionalTarget || new THREE.Sphere();
            result.center = this.center();
            result.radius = this.size(v1).length() * .5;
            return result;
        };
    }(),
    intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    },
    union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    applyMatrix4: function() {
        var points = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
        return function(matrix) {
            points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
            points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
            points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
            points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
            points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
            points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
            points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
            points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
            this.makeEmpty();
            this.setFromPoints(points);
            return this;
        };
    }(),
    translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    },
    clone: function() {
        return new THREE.Box3().copy(this);
    }
};

THREE.Matrix3 = function() {
    this.elements = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]);
    if (arguments.length > 0) {
        THREE.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
};

THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3,
    set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[3] = n12;
        te[6] = n13;
        te[1] = n21;
        te[4] = n22;
        te[7] = n23;
        te[2] = n31;
        te[5] = n32;
        te[8] = n33;
        return this;
    },
    identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    },
    copy: function(m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
        return this;
    },
    multiplyVector3: function(vector) {
        THREE.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return vector.applyMatrix3(this);
    },
    multiplyVector3Array: function(a) {
        THREE.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
        return this.applyToVector3Array(a);
    },
    applyToVector3Array: function() {
        var v1 = new THREE.Vector3();
        return function(array, offset, length) {
            if (offset === undefined) offset = 0;
            if (length === undefined) length = array.length;
            for (var i = 0, j = offset; i < length; i += 3, j += 3) {
                v1.x = array[j];
                v1.y = array[j + 1];
                v1.z = array[j + 2];
                v1.applyMatrix3(this);
                array[j] = v1.x;
                array[j + 1] = v1.y;
                array[j + 2] = v1.z;
            }
            return array;
        };
    }(),
    multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    },
    determinant: function() {
        var te = this.elements;
        var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    },
    getInverse: function(matrix, throwOnInvertible) {
        var me = matrix.elements;
        var te = this.elements;
        te[0] = me[10] * me[5] - me[6] * me[9];
        te[1] = -me[10] * me[1] + me[2] * me[9];
        te[2] = me[6] * me[1] - me[2] * me[5];
        te[3] = -me[10] * me[4] + me[6] * me[8];
        te[4] = me[10] * me[0] - me[2] * me[8];
        te[5] = -me[6] * me[0] + me[2] * me[4];
        te[6] = me[9] * me[4] - me[5] * me[8];
        te[7] = -me[9] * me[0] + me[1] * me[8];
        te[8] = me[5] * me[0] - me[1] * me[4];
        var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];
        if (det === 0) {
            var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
            if (throwOnInvertible || false) {
                throw new Error(msg);
            } else {
                THREE.warn(msg);
            }
            this.identity();
            return this;
        }
        this.multiplyScalar(1 / det);
        return this;
    },
    transpose: function() {
        var tmp, m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
    },
    flattenToArrayOffset: function(array, offset) {
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    },
    getNormalMatrix: function(m) {
        this.getInverse(m).transpose();
        return this;
    },
    transposeIntoArray: function(r) {
        var m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    },
    fromArray: function(array) {
        this.elements.set(array);
        return this;
    },
    toArray: function() {
        var te = this.elements;
        return [ te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8] ];
    },
    clone: function() {
        return new THREE.Matrix3().fromArray(this.elements);
    }
};

THREE.Matrix4 = function() {
    this.elements = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);
    if (arguments.length > 0) {
        THREE.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
};

THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4,
    set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    },
    identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    },
    copy: function(m) {
        this.elements.set(m.elements);
        return this;
    },
    extractPosition: function(m) {
        THREE.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m);
    },
    copyPosition: function(m) {
        var te = this.elements;
        var me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    },
    extractBasis: function(xAxis, yAxis, zAxis) {
        var te = this.elements;
        xAxis.set(te[0], te[1], te[2]);
        yAxis.set(te[4], te[5], te[6]);
        zAxis.set(te[8], te[9], te[10]);
        return this;
    },
    makeBasis: function(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    },
    extractRotation: function() {
        var v1 = new THREE.Vector3();
        return function(m) {
            var te = this.elements;
            var me = m.elements;
            var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();
            var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();
            var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();
            te[0] = me[0] * scaleX;
            te[1] = me[1] * scaleX;
            te[2] = me[2] * scaleX;
            te[4] = me[4] * scaleY;
            te[5] = me[5] * scaleY;
            te[6] = me[6] * scaleY;
            te[8] = me[8] * scaleZ;
            te[9] = me[9] * scaleZ;
            te[10] = me[10] * scaleZ;
            return this;
        };
    }(),
    makeRotationFromEuler: function(euler) {
        if (euler instanceof THREE.Euler === false) {
            THREE.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        }
        var te = this.elements;
        var x = euler.x, y = euler.y, z = euler.z;
        var a = Math.cos(x), b = Math.sin(x);
        var c = Math.cos(y), d = Math.sin(y);
        var e = Math.cos(z), f = Math.sin(z);
        if (euler.order === "XYZ") {
            var ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
        } else if (euler.order === "YXZ") {
            var ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
        } else if (euler.order === "ZXY") {
            var ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
        } else if (euler.order === "ZYX") {
            var ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
        } else if (euler.order === "YZX") {
            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === "XZY") {
            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    },
    setRotationFromQuaternion: function(q) {
        THREE.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q);
    },
    makeRotationFromQuaternion: function(q) {
        var te = this.elements;
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;
        te[0] = 1 - (yy + zz);
        te[4] = xy - wz;
        te[8] = xz + wy;
        te[1] = xy + wz;
        te[5] = 1 - (xx + zz);
        te[9] = yz - wx;
        te[2] = xz - wy;
        te[6] = yz + wx;
        te[10] = 1 - (xx + yy);
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    },
    lookAt: function() {
        var x = new THREE.Vector3();
        var y = new THREE.Vector3();
        var z = new THREE.Vector3();
        return function(eye, target, up) {
            var te = this.elements;
            z.subVectors(eye, target).normalize();
            if (z.length() === 0) {
                z.z = 1;
            }
            x.crossVectors(up, z).normalize();
            if (x.length() === 0) {
                z.x += 1e-4;
                x.crossVectors(up, z).normalize();
            }
            y.crossVectors(z, x);
            te[0] = x.x;
            te[4] = y.x;
            te[8] = z.x;
            te[1] = x.y;
            te[5] = y.y;
            te[9] = z.y;
            te[2] = x.z;
            te[6] = y.z;
            te[10] = z.z;
            return this;
        };
    }(),
    multiply: function(m, n) {
        if (n !== undefined) {
            THREE.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    },
    multiplyMatrices: function(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    },
    multiplyToArray: function(a, b, r) {
        var te = this.elements;
        this.multiplyMatrices(a, b);
        r[0] = te[0];
        r[1] = te[1];
        r[2] = te[2];
        r[3] = te[3];
        r[4] = te[4];
        r[5] = te[5];
        r[6] = te[6];
        r[7] = te[7];
        r[8] = te[8];
        r[9] = te[9];
        r[10] = te[10];
        r[11] = te[11];
        r[12] = te[12];
        r[13] = te[13];
        r[14] = te[14];
        r[15] = te[15];
        return this;
    },
    multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    },
    multiplyVector3: function(vector) {
        THREE.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
        return vector.applyProjection(this);
    },
    multiplyVector4: function(vector) {
        THREE.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
    },
    multiplyVector3Array: function(a) {
        THREE.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
        return this.applyToVector3Array(a);
    },
    applyToVector3Array: function() {
        var v1 = new THREE.Vector3();
        return function(array, offset, length) {
            if (offset === undefined) offset = 0;
            if (length === undefined) length = array.length;
            for (var i = 0, j = offset; i < length; i += 3, j += 3) {
                v1.x = array[j];
                v1.y = array[j + 1];
                v1.z = array[j + 2];
                v1.applyMatrix4(this);
                array[j] = v1.x;
                array[j + 1] = v1.y;
                array[j + 2] = v1.z;
            }
            return array;
        };
    }(),
    rotateAxis: function(v) {
        THREE.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        v.transformDirection(this);
    },
    crossVector: function(vector) {
        THREE.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
    },
    determinant: function() {
        var te = this.elements;
        var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    },
    transpose: function() {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
    },
    flattenToArrayOffset: function(array, offset) {
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    },
    getPosition: function() {
        var v1 = new THREE.Vector3();
        return function() {
            THREE.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
            var te = this.elements;
            return v1.set(te[12], te[13], te[14]);
        };
    }(),
    setPosition: function(v) {
        var te = this.elements;
        te[12] = v.x;
        te[13] = v.y;
        te[14] = v.z;
        return this;
    },
    getInverse: function(m, throwOnInvertible) {
        var te = this.elements;
        var me = m.elements;
        var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
        var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
        var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
        var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];
        te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
        te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
        te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
        te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
        te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
        te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
        te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
        te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
        te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
        te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
        te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
        te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
        var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];
        if (det == 0) {
            var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
            if (throwOnInvertible || false) {
                throw new Error(msg);
            } else {
                THREE.warn(msg);
            }
            this.identity();
            return this;
        }
        this.multiplyScalar(1 / det);
        return this;
    },
    translate: function(v) {
        THREE.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function(angle) {
        THREE.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function(angle) {
        THREE.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function(angle) {
        THREE.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function(axis, angle) {
        THREE.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    scale: function(v) {
        var te = this.elements;
        var x = v.x, y = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
    },
    getMaxScaleOnAxis: function() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));
    },
    makeTranslation: function(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    },
    makeRotationX: function(theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationY: function(theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationZ: function(theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationAxis: function(axis, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x, y = axis.y, z = axis.z;
        var tx = t * x, ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
    },
    makeScale: function(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    },
    compose: function(position, quaternion, scale) {
        this.makeRotationFromQuaternion(quaternion);
        this.scale(scale);
        this.setPosition(position);
        return this;
    },
    decompose: function() {
        var vector = new THREE.Vector3();
        var matrix = new THREE.Matrix4();
        return function(position, quaternion, scale) {
            var te = this.elements;
            var sx = vector.set(te[0], te[1], te[2]).length();
            var sy = vector.set(te[4], te[5], te[6]).length();
            var sz = vector.set(te[8], te[9], te[10]).length();
            var det = this.determinant();
            if (det < 0) {
                sx = -sx;
            }
            position.x = te[12];
            position.y = te[13];
            position.z = te[14];
            matrix.elements.set(this.elements);
            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;
            matrix.elements[0] *= invSX;
            matrix.elements[1] *= invSX;
            matrix.elements[2] *= invSX;
            matrix.elements[4] *= invSY;
            matrix.elements[5] *= invSY;
            matrix.elements[6] *= invSY;
            matrix.elements[8] *= invSZ;
            matrix.elements[9] *= invSZ;
            matrix.elements[10] *= invSZ;
            quaternion.setFromRotationMatrix(matrix);
            scale.x = sx;
            scale.y = sy;
            scale.z = sz;
            return this;
        };
    }(),
    makeFrustum: function(left, right, bottom, top, near, far) {
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    },
    makePerspective: function(fov, aspect, near, far) {
        var ymax = near * Math.tan(THREE.Math.degToRad(fov * .5));
        var ymin = -ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;
        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
    },
    makeOrthographic: function(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = right - left;
        var h = top - bottom;
        var p = far - near;
        var x = (right + left) / w;
        var y = (top + bottom) / h;
        var z = (far + near) / p;
        te[0] = 2 / w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 / h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 / p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    },
    fromArray: function(array) {
        this.elements.set(array);
        return this;
    },
    toArray: function() {
        var te = this.elements;
        return [ te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8], te[9], te[10], te[11], te[12], te[13], te[14], te[15] ];
    },
    clone: function() {
        return new THREE.Matrix4().fromArray(this.elements);
    }
};

THREE.Ray = function(origin, direction) {
    this.origin = origin !== undefined ? origin : new THREE.Vector3();
    this.direction = direction !== undefined ? direction : new THREE.Vector3();
};

THREE.Ray.prototype = {
    constructor: THREE.Ray,
    set: function(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    },
    copy: function(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    },
    at: function(t, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    recast: function() {
        var v1 = new THREE.Vector3();
        return function(t) {
            this.origin.copy(this.at(t, v1));
            return this;
        };
    }(),
    closestPointToPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        result.subVectors(point, this.origin);
        var directionDistance = result.dot(this.direction);
        if (directionDistance < 0) {
            return result.copy(this.origin);
        }
        return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    },
    distanceToPoint: function() {
        var v1 = new THREE.Vector3();
        return function(point) {
            var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
            if (directionDistance < 0) {
                return this.origin.distanceTo(point);
            }
            v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
            return v1.distanceTo(point);
        };
    }(),
    distanceSqToSegment: function() {
        var segCenter = new THREE.Vector3();
        var segDir = new THREE.Vector3();
        var diff = new THREE.Vector3();
        return function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
            segCenter.copy(v0).add(v1).multiplyScalar(.5);
            segDir.copy(v1).sub(v0).normalize();
            diff.copy(this.origin).sub(segCenter);
            var segExtent = v0.distanceTo(v1) * .5;
            var a01 = -this.direction.dot(segDir);
            var b0 = diff.dot(this.direction);
            var b1 = -diff.dot(segDir);
            var c = diff.lengthSq();
            var det = Math.abs(1 - a01 * a01);
            var s0, s1, sqrDist, extDet;
            if (det > 0) {
                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;
                if (s0 >= 0) {
                    if (s1 >= -extDet) {
                        if (s1 <= extDet) {
                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                        } else {
                            s1 = segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    } else {
                        s1 = -segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    if (s1 <= -extDet) {
                        s0 = Math.max(0, -(-a01 * segExtent + b0));
                        s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    } else if (s1 <= extDet) {
                        s0 = 0;
                        s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = s1 * (s1 + 2 * b1) + c;
                    } else {
                        s0 = Math.max(0, -(a01 * segExtent + b0));
                        s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
            } else {
                s1 = a01 > 0 ? -segExtent : segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
            if (optionalPointOnRay) {
                optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
            }
            if (optionalPointOnSegment) {
                optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
            }
            return sqrDist;
        };
    }(),
    isIntersectionSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) <= sphere.radius;
    },
    intersectSphere: function() {
        var v1 = new THREE.Vector3();
        return function(sphere, optionalTarget) {
            v1.subVectors(sphere.center, this.origin);
            var tca = v1.dot(this.direction);
            var d2 = v1.dot(v1) - tca * tca;
            var radius2 = sphere.radius * sphere.radius;
            if (d2 > radius2) return null;
            var thc = Math.sqrt(radius2 - d2);
            var t0 = tca - thc;
            var t1 = tca + thc;
            if (t0 < 0 && t1 < 0) return null;
            if (t0 < 0) return this.at(t1, optionalTarget);
            return this.at(t0, optionalTarget);
        };
    }(),
    isIntersectionPlane: function(plane) {
        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
            return true;
        }
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
            return true;
        }
        return false;
    },
    distanceToPlane: function(plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator == 0) {
            if (plane.distanceToPoint(this.origin) == 0) {
                return 0;
            }
            return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
    },
    intersectPlane: function(plane, optionalTarget) {
        var t = this.distanceToPlane(plane);
        if (t === null) {
            return null;
        }
        return this.at(t, optionalTarget);
    },
    isIntersectionBox: function() {
        var v = new THREE.Vector3();
        return function(box) {
            return this.intersectBox(box, v) !== null;
        };
    }(),
    intersectBox: function(box, optionalTarget) {
        var tmin, tmax, tymin, tymax, tzmin, tzmax;
        var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
        } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
        } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        if (tymin > tmin || tmin !== tmin) tmin = tymin;
        if (tymax < tmax || tmax !== tmax) tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
    },
    intersectTriangle: function() {
        var diff = new THREE.Vector3();
        var edge1 = new THREE.Vector3();
        var edge2 = new THREE.Vector3();
        var normal = new THREE.Vector3();
        return function(a, b, c, backfaceCulling, optionalTarget) {
            edge1.subVectors(b, a);
            edge2.subVectors(c, a);
            normal.crossVectors(edge1, edge2);
            var DdN = this.direction.dot(normal);
            var sign;
            if (DdN > 0) {
                if (backfaceCulling) return null;
                sign = 1;
            } else if (DdN < 0) {
                sign = -1;
                DdN = -DdN;
            } else {
                return null;
            }
            diff.subVectors(this.origin, a);
            var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
            if (DdQxE2 < 0) {
                return null;
            }
            var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
            if (DdE1xQ < 0) {
                return null;
            }
            if (DdQxE2 + DdE1xQ > DdN) {
                return null;
            }
            var QdN = -sign * diff.dot(normal);
            if (QdN < 0) {
                return null;
            }
            return this.at(QdN / DdN, optionalTarget);
        };
    }(),
    applyMatrix4: function(matrix4) {
        this.direction.add(this.origin).applyMatrix4(matrix4);
        this.origin.applyMatrix4(matrix4);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this;
    },
    equals: function(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    },
    clone: function() {
        return new THREE.Ray().copy(this);
    }
};

THREE.Sphere = function(center, radius) {
    this.center = center !== undefined ? center : new THREE.Vector3();
    this.radius = radius !== undefined ? radius : 0;
};

THREE.Sphere.prototype = {
    constructor: THREE.Sphere,
    set: function(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    },
    setFromPoints: function() {
        var box = new THREE.Box3();
        return function(points, optionalCenter) {
            var center = this.center;
            if (optionalCenter !== undefined) {
                center.copy(optionalCenter);
            } else {
                box.setFromPoints(points).center(center);
            }
            var maxRadiusSq = 0;
            for (var i = 0, il = points.length; i < il; i++) {
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSq);
            return this;
        };
    }(),
    copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    },
    empty: function() {
        return this.radius <= 0;
    },
    containsPoint: function(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(point) {
        return point.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    },
    clampPoint: function(point, optionalTarget) {
        var deltaLengthSq = this.center.distanceToSquared(point);
        var result = optionalTarget || new THREE.Vector3();
        result.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            result.sub(this.center).normalize();
            result.multiplyScalar(this.radius).add(this.center);
        }
        return result;
    },
    getBoundingBox: function(optionalTarget) {
        var box = optionalTarget || new THREE.Box3();
        box.set(this.center, this.center);
        box.expandByScalar(this.radius);
        return box;
    },
    applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    },
    translate: function(offset) {
        this.center.add(offset);
        return this;
    },
    equals: function(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    },
    clone: function() {
        return new THREE.Sphere().copy(this);
    }
};

THREE.Frustum = function(p0, p1, p2, p3, p4, p5) {
    this.planes = [ p0 !== undefined ? p0 : new THREE.Plane(), p1 !== undefined ? p1 : new THREE.Plane(), p2 !== undefined ? p2 : new THREE.Plane(), p3 !== undefined ? p3 : new THREE.Plane(), p4 !== undefined ? p4 : new THREE.Plane(), p5 !== undefined ? p5 : new THREE.Plane() ];
};

THREE.Frustum.prototype = {
    constructor: THREE.Frustum,
    set: function(p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    },
    copy: function(frustum) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
            planes[i].copy(frustum.planes[i]);
        }
        return this;
    },
    setFromMatrix: function(m) {
        var planes = this.planes;
        var me = m.elements;
        var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    },
    intersectsObject: function() {
        var sphere = new THREE.Sphere();
        return function(object) {
            var geometry = object.geometry;
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(object.matrixWorld);
            return this.intersectsSphere(sphere);
        };
    }(),
    intersectsSphere: function(sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for (var i = 0; i < 6; i++) {
            var distance = planes[i].distanceToPoint(center);
            if (distance < negRadius) {
                return false;
            }
        }
        return true;
    },
    intersectsBox: function() {
        var p1 = new THREE.Vector3(), p2 = new THREE.Vector3();
        return function(box) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                var plane = planes[i];
                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                var d1 = plane.distanceToPoint(p1);
                var d2 = plane.distanceToPoint(p2);
                if (d1 < 0 && d2 < 0) {
                    return false;
                }
            }
            return true;
        };
    }(),
    containsPoint: function(point) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
            if (planes[i].distanceToPoint(point) < 0) {
                return false;
            }
        }
        return true;
    },
    clone: function() {
        return new THREE.Frustum().copy(this);
    }
};

THREE.Plane = function(normal, constant) {
    this.normal = normal !== undefined ? normal : new THREE.Vector3(1, 0, 0);
    this.constant = constant !== undefined ? constant : 0;
};

THREE.Plane.prototype = {
    constructor: THREE.Plane,
    set: function(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
    },
    setComponents: function(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
    },
    setFromNormalAndCoplanarPoint: function(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
    },
    setFromCoplanarPoints: function() {
        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        return function(a, b, c) {
            var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
            this.setFromNormalAndCoplanarPoint(normal, a);
            return this;
        };
    }(),
    copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    },
    normalize: function() {
        var inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    },
    negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
    },
    distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
    },
    distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    },
    projectPoint: function(point, optionalTarget) {
        return this.orthoPoint(point, optionalTarget).sub(point).negate();
    },
    orthoPoint: function(point, optionalTarget) {
        var perpendicularMagnitude = this.distanceToPoint(point);
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
    },
    isIntersectionLine: function(line) {
        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    },
    intersectLine: function() {
        var v1 = new THREE.Vector3();
        return function(line, optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            var direction = line.delta(v1);
            var denominator = this.normal.dot(direction);
            if (denominator == 0) {
                if (this.distanceToPoint(line.start) == 0) {
                    return result.copy(line.start);
                }
                return undefined;
            }
            var t = -(line.start.dot(this.normal) + this.constant) / denominator;
            if (t < 0 || t > 1) {
                return undefined;
            }
            return result.copy(direction).multiplyScalar(t).add(line.start);
        };
    }(),
    coplanarPoint: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        var m1 = new THREE.Matrix3();
        return function(matrix, optionalNormalMatrix) {
            var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
            var newNormal = v1.copy(this.normal).applyMatrix3(normalMatrix);
            var newCoplanarPoint = this.coplanarPoint(v2);
            newCoplanarPoint.applyMatrix4(matrix);
            this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);
            return this;
        };
    }(),
    translate: function(offset) {
        this.constant = this.constant - offset.dot(this.normal);
        return this;
    },
    equals: function(plane) {
        return plane.normal.equals(this.normal) && plane.constant == this.constant;
    },
    clone: function() {
        return new THREE.Plane().copy(this);
    }
};

THREE.Math = {
    generateUUID: function() {
        var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
        var uuid = new Array(36);
        var rnd = 0, r;
        return function() {
            for (var i = 0; i < 36; i++) {
                if (i == 8 || i == 13 || i == 18 || i == 23) {
                    uuid[i] = "-";
                } else if (i == 14) {
                    uuid[i] = "4";
                } else {
                    if (rnd <= 2) rnd = 33554432 + Math.random() * 16777216 | 0;
                    r = rnd & 15;
                    rnd = rnd >> 4;
                    uuid[i] = chars[i == 19 ? r & 3 | 8 : r];
                }
            }
            return uuid.join("");
        };
    }(),
    clamp: function(x, a, b) {
        return x < a ? a : x > b ? b : x;
    },
    clampBottom: function(x, a) {
        return x < a ? a : x;
    },
    mapLinear: function(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    smoothstep: function(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
    },
    smootherstep: function(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
    },
    random16: function() {
        return (65280 * Math.random() + 255 * Math.random()) / 65535;
    },
    randInt: function(low, high) {
        return Math.floor(this.randFloat(low, high));
    },
    randFloat: function(low, high) {
        return low + Math.random() * (high - low);
    },
    randFloatSpread: function(range) {
        return range * (.5 - Math.random());
    },
    degToRad: function() {
        var degreeToRadiansFactor = Math.PI / 180;
        return function(degrees) {
            return degrees * degreeToRadiansFactor;
        };
    }(),
    radToDeg: function() {
        var radianToDegreesFactor = 180 / Math.PI;
        return function(radians) {
            return radians * radianToDegreesFactor;
        };
    }(),
    isPowerOfTwo: function(value) {
        return (value & value - 1) === 0 && value !== 0;
    },
    nextPowerOfTwo: function(value) {
        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;
        return value;
    }
};

THREE.Spline = function(points) {
    this.points = points;
    var c = [], v3 = {
        x: 0,
        y: 0,
        z: 0
    }, point, intPoint, weight, w2, w3, pa, pb, pc, pd;
    this.initFromArray = function(a) {
        this.points = [];
        for (var i = 0; i < a.length; i++) {
            this.points[i] = {
                x: a[i][0],
                y: a[i][1],
                z: a[i][2]
            };
        }
    };
    this.getPoint = function(k) {
        point = (this.points.length - 1) * k;
        intPoint = Math.floor(point);
        weight = point - intPoint;
        c[0] = intPoint === 0 ? intPoint : intPoint - 1;
        c[1] = intPoint;
        c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
        pa = this.points[c[0]];
        pb = this.points[c[1]];
        pc = this.points[c[2]];
        pd = this.points[c[3]];
        w2 = weight * weight;
        w3 = weight * w2;
        v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
        v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
        v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
        return v3;
    };
    this.getControlPointsArray = function() {
        var i, p, l = this.points.length, coords = [];
        for (i = 0; i < l; i++) {
            p = this.points[i];
            coords[i] = [ p.x, p.y, p.z ];
        }
        return coords;
    };
    this.getLength = function(nSubDivisions) {
        var i, index, nSamples, position, point = 0, intPoint = 0, oldIntPoint = 0, oldPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3(), chunkLengths = [], totalLength = 0;
        chunkLengths[0] = 0;
        if (!nSubDivisions) nSubDivisions = 100;
        nSamples = this.points.length * nSubDivisions;
        oldPosition.copy(this.points[0]);
        for (i = 1; i < nSamples; i++) {
            index = i / nSamples;
            position = this.getPoint(index);
            tmpVec.copy(position);
            totalLength += tmpVec.distanceTo(oldPosition);
            oldPosition.copy(position);
            point = (this.points.length - 1) * index;
            intPoint = Math.floor(point);
            if (intPoint != oldIntPoint) {
                chunkLengths[intPoint] = totalLength;
                oldIntPoint = intPoint;
            }
        }
        chunkLengths[chunkLengths.length] = totalLength;
        return {
            chunks: chunkLengths,
            total: totalLength
        };
    };
    this.reparametrizeByArcLength = function(samplingCoef) {
        var i, j, index, indexCurrent, indexNext, realDistance, sampling, position, newpoints = [], tmpVec = new THREE.Vector3(), sl = this.getLength();
        newpoints.push(tmpVec.copy(this.points[0]).clone());
        for (i = 1; i < this.points.length; i++) {
            realDistance = sl.chunks[i] - sl.chunks[i - 1];
            sampling = Math.ceil(samplingCoef * realDistance / sl.total);
            indexCurrent = (i - 1) / (this.points.length - 1);
            indexNext = i / (this.points.length - 1);
            for (j = 1; j < sampling - 1; j++) {
                index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
                position = this.getPoint(index);
                newpoints.push(tmpVec.copy(position).clone());
            }
            newpoints.push(tmpVec.copy(this.points[i]).clone());
        }
        this.points = newpoints;
    };
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * .5, v1 = (p3 - p1) * .5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
};

THREE.Triangle = function(a, b, c) {
    this.a = a !== undefined ? a : new THREE.Vector3();
    this.b = b !== undefined ? b : new THREE.Vector3();
    this.c = c !== undefined ? c : new THREE.Vector3();
};

THREE.Triangle.normal = function() {
    var v0 = new THREE.Vector3();
    return function(a, b, c, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        result.subVectors(c, b);
        v0.subVectors(a, b);
        result.cross(v0);
        var resultLengthSq = result.lengthSq();
        if (resultLengthSq > 0) {
            return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
        }
        return result.set(0, 0, 0);
    };
}();

THREE.Triangle.barycoordFromPoint = function() {
    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    return function(point, a, b, c, optionalTarget) {
        v0.subVectors(c, a);
        v1.subVectors(b, a);
        v2.subVectors(point, a);
        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);
        var denom = dot00 * dot11 - dot01 * dot01;
        var result = optionalTarget || new THREE.Vector3();
        if (denom == 0) {
            return result.set(-2, -1, -1);
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return result.set(1 - u - v, v, u);
    };
}();

THREE.Triangle.containsPoint = function() {
    var v1 = new THREE.Vector3();
    return function(point, a, b, c) {
        var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);
        return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
    };
}();

THREE.Triangle.prototype = {
    constructor: THREE.Triangle,
    set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    },
    setFromPointsAndIndices: function(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
    },
    copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    },
    area: function() {
        var v0 = new THREE.Vector3();
        var v1 = new THREE.Vector3();
        return function() {
            v0.subVectors(this.c, this.b);
            v1.subVectors(this.a, this.b);
            return v0.cross(v1).length() * .5;
        };
    }(),
    midpoint: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    normal: function(optionalTarget) {
        return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);
    },
    plane: function(optionalTarget) {
        var result = optionalTarget || new THREE.Plane();
        return result.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    barycoordFromPoint: function(point, optionalTarget) {
        return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
    },
    containsPoint: function(point) {
        return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);
    },
    equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    },
    clone: function() {
        return new THREE.Triangle().copy(this);
    }
};

THREE.Clock = function(autoStart) {
    this.autoStart = autoStart !== undefined ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
};

THREE.Clock.prototype = {
    constructor: THREE.Clock,
    start: function() {
        this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
        this.oldTime = this.startTime;
        this.running = true;
    },
    stop: function() {
        this.getElapsedTime();
        this.running = false;
    },
    getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
    },
    getDelta: function() {
        var diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
        }
        if (this.running) {
            var newTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
            diff = .001 * (newTime - this.oldTime);
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
};

THREE.EventDispatcher = function() {};

THREE.EventDispatcher.prototype = {
    constructor: THREE.EventDispatcher,
    apply: function(object) {
        object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
    },
    addEventListener: function(type, listener) {
        if (this._listeners === undefined) this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === undefined) {
            listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
        }
    },
    hasEventListener: function(type, listener) {
        if (this._listeners === undefined) return false;
        var listeners = this._listeners;
        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
            return true;
        }
        return false;
    },
    removeEventListener: function(type, listener) {
        if (this._listeners === undefined) return;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            var index = listenerArray.indexOf(listener);
            if (index !== -1) {
                listenerArray.splice(index, 1);
            }
        }
    },
    dispatchEvent: function(event) {
        if (this._listeners === undefined) return;
        var listeners = this._listeners;
        var listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            var array = [];
            var length = listenerArray.length;
            for (var i = 0; i < length; i++) {
                array[i] = listenerArray[i];
            }
            for (var i = 0; i < length; i++) {
                array[i].call(this, event);
            }
        }
    }
};

(function(THREE) {
    THREE.Raycaster = function(origin, direction, near, far) {
        this.ray = new THREE.Ray(origin, direction);
        this.near = near || 0;
        this.far = far || Infinity;
        this.params = {
            Sprite: {},
            Mesh: {},
            PointCloud: {
                threshold: 1
            },
            LOD: {},
            Line: {}
        };
    };
    var descSort = function(a, b) {
        return a.distance - b.distance;
    };
    var intersectObject = function(object, raycaster, intersects, recursive) {
        object.raycast(raycaster, intersects);
        if (recursive === true) {
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                intersectObject(children[i], raycaster, intersects, true);
            }
        }
    };
    THREE.Raycaster.prototype = {
        constructor: THREE.Raycaster,
        precision: 1e-4,
        linePrecision: 1,
        set: function(origin, direction) {
            this.ray.set(origin, direction);
        },
        setFromCamera: function(coords, camera) {
            if (camera instanceof THREE.PerspectiveCamera) {
                this.ray.origin.copy(camera.position);
                this.ray.direction.set(coords.x, coords.y, .5).unproject(camera).sub(camera.position).normalize();
            } else if (camera instanceof THREE.OrthographicCamera) {
                this.ray.origin.set(coords.x, coords.y, -1).unproject(camera);
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            } else {
                THREE.error("THREE.Raycaster: Unsupported camera type.");
            }
        },
        intersectObject: function(object, recursive) {
            var intersects = [];
            intersectObject(object, this, intersects, recursive);
            intersects.sort(descSort);
            return intersects;
        },
        intersectObjects: function(objects, recursive) {
            var intersects = [];
            if (objects instanceof Array === false) {
                THREE.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
                return intersects;
            }
            for (var i = 0, l = objects.length; i < l; i++) {
                intersectObject(objects[i], this, intersects, recursive);
            }
            intersects.sort(descSort);
            return intersects;
        }
    };
})(THREE);

THREE.Object3D = function() {
    Object.defineProperty(this, "id", {
        value: THREE.Object3DIdCount++
    });
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = undefined;
    this.children = [];
    this.up = THREE.Object3D.DefaultUp.clone();
    var position = new THREE.Vector3();
    var rotation = new THREE.Euler();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3(1, 1, 1);
    var onRotationChange = function() {
        quaternion.setFromEuler(rotation, false);
    };
    var onQuaternionChange = function() {
        rotation.setFromQuaternion(quaternion, undefined, false);
    };
    rotation.onChange(onRotationChange);
    quaternion.onChange(onQuaternionChange);
    Object.defineProperties(this, {
        position: {
            enumerable: true,
            value: position
        },
        rotation: {
            enumerable: true,
            value: rotation
        },
        quaternion: {
            enumerable: true,
            value: quaternion
        },
        scale: {
            enumerable: true,
            value: scale
        }
    });
    this.rotationAutoUpdate = true;
    this.matrix = new THREE.Matrix4();
    this.matrixWorld = new THREE.Matrix4();
    this.matrixAutoUpdate = true;
    this.matrixWorldNeedsUpdate = false;
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {};
};

THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);

THREE.Object3D.prototype = {
    constructor: THREE.Object3D,
    get eulerOrder() {
        THREE.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order.");
        return this.rotation.order;
    },
    set eulerOrder(value) {
        THREE.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order.");
        this.rotation.order = value;
    },
    get useQuaternion() {
        THREE.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set useQuaternion(value) {
        THREE.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    applyMatrix: function(matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    setRotationFromAxisAngle: function(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function(m) {
        this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q) {
        this.quaternion.copy(q);
    },
    rotateOnAxis: function() {
        var q1 = new THREE.Quaternion();
        return function(axis, angle) {
            q1.setFromAxisAngle(axis, angle);
            this.quaternion.multiply(q1);
            return this;
        };
    }(),
    rotateX: function() {
        var v1 = new THREE.Vector3(1, 0, 0);
        return function(angle) {
            return this.rotateOnAxis(v1, angle);
        };
    }(),
    rotateY: function() {
        var v1 = new THREE.Vector3(0, 1, 0);
        return function(angle) {
            return this.rotateOnAxis(v1, angle);
        };
    }(),
    rotateZ: function() {
        var v1 = new THREE.Vector3(0, 0, 1);
        return function(angle) {
            return this.rotateOnAxis(v1, angle);
        };
    }(),
    translateOnAxis: function() {
        var v1 = new THREE.Vector3();
        return function(axis, distance) {
            v1.copy(axis).applyQuaternion(this.quaternion);
            this.position.add(v1.multiplyScalar(distance));
            return this;
        };
    }(),
    translate: function(distance, axis) {
        THREE.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(axis, distance);
    },
    translateX: function() {
        var v1 = new THREE.Vector3(1, 0, 0);
        return function(distance) {
            return this.translateOnAxis(v1, distance);
        };
    }(),
    translateY: function() {
        var v1 = new THREE.Vector3(0, 1, 0);
        return function(distance) {
            return this.translateOnAxis(v1, distance);
        };
    }(),
    translateZ: function() {
        var v1 = new THREE.Vector3(0, 0, 1);
        return function(distance) {
            return this.translateOnAxis(v1, distance);
        };
    }(),
    localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
        var m1 = new THREE.Matrix4();
        return function(vector) {
            return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
        };
    }(),
    lookAt: function() {
        var m1 = new THREE.Matrix4();
        return function(vector) {
            m1.lookAt(vector, this.position, this.up);
            this.quaternion.setFromRotationMatrix(m1);
        };
    }(),
    add: function(object) {
        if (arguments.length > 1) {
            for (var i = 0; i < arguments.length; i++) {
                this.add(arguments[i]);
            }
            return this;
        }
        if (object === this) {
            THREE.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
        }
        if (object instanceof THREE.Object3D) {
            if (object.parent !== undefined) {
                object.parent.remove(object);
            }
            object.parent = this;
            object.dispatchEvent({
                type: "added"
            });
            this.children.push(object);
        } else {
            THREE.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
    },
    remove: function(object) {
        if (arguments.length > 1) {
            for (var i = 0; i < arguments.length; i++) {
                this.remove(arguments[i]);
            }
        }
        var index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = undefined;
            object.dispatchEvent({
                type: "removed"
            });
            this.children.splice(index, 1);
        }
    },
    getChildByName: function(name) {
        THREE.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
    },
    getObjectById: function(id) {
        return this.getObjectByProperty("id", id);
    },
    getObjectByName: function(name) {
        return this.getObjectByProperty("name", name);
    },
    getObjectByProperty: function(name, value) {
        if (this[name] === value) return this;
        for (var i = 0, l = this.children.length; i < l; i++) {
            var child = this.children[i];
            var object = child.getObjectByProperty(name, value);
            if (object !== undefined) {
                return object;
            }
        }
        return undefined;
    },
    getWorldPosition: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.updateMatrixWorld(true);
        return result.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();
        return function(optionalTarget) {
            var result = optionalTarget || new THREE.Quaternion();
            this.updateMatrixWorld(true);
            this.matrixWorld.decompose(position, result, scale);
            return result;
        };
    }(),
    getWorldRotation: function() {
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
            var result = optionalTarget || new THREE.Euler();
            this.getWorldQuaternion(quaternion);
            return result.setFromQuaternion(quaternion, this.rotation.order, false);
        };
    }(),
    getWorldScale: function() {
        var position = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            this.updateMatrixWorld(true);
            this.matrixWorld.decompose(position, quaternion, result);
            return result;
        };
    }(),
    getWorldDirection: function() {
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            this.getWorldQuaternion(quaternion);
            return result.set(0, 0, 1).applyQuaternion(quaternion);
        };
    }(),
    raycast: function() {},
    traverse: function(callback) {
        callback(this);
        for (var i = 0, l = this.children.length; i < l; i++) {
            this.children[i].traverse(callback);
        }
    },
    traverseVisible: function(callback) {
        if (this.visible === false) return;
        callback(this);
        for (var i = 0, l = this.children.length; i < l; i++) {
            this.children[i].traverseVisible(callback);
        }
    },
    traverseAncestors: function(callback) {
        if (this.parent) {
            callback(this.parent);
            this.parent.traverseAncestors(callback);
        }
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate === true) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate === true || force === true) {
            if (this.parent === undefined) {
                this.matrixWorld.copy(this.matrix);
            } else {
                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        for (var i = 0, l = this.children.length; i < l; i++) {
            this.children[i].updateMatrixWorld(force);
        }
    },
    toJSON: function() {
        var output = {
            metadata: {
                version: 4.3,
                type: "Object",
                generator: "ObjectExporter"
            }
        };
        var geometries = {};
        var parseGeometry = function(geometry) {
            if (output.geometries === undefined) {
                output.geometries = [];
            }
            if (geometries[geometry.uuid] === undefined) {
                var json = geometry.toJSON();
                delete json.metadata;
                geometries[geometry.uuid] = json;
                output.geometries.push(json);
            }
            return geometry.uuid;
        };
        var materials = {};
        var parseMaterial = function(material) {
            if (output.materials === undefined) {
                output.materials = [];
            }
            if (materials[material.uuid] === undefined) {
                var json = material.toJSON();
                delete json.metadata;
                materials[material.uuid] = json;
                output.materials.push(json);
            }
            return material.uuid;
        };
        var parseObject = function(object) {
            var data = {};
            data.uuid = object.uuid;
            data.type = object.type;
            if (object.name !== "") data.name = object.name;
            if (JSON.stringify(object.userData) !== "{}") data.userData = object.userData;
            if (object.visible !== true) data.visible = object.visible;
            if (object instanceof THREE.PerspectiveCamera) {
                data.fov = object.fov;
                data.aspect = object.aspect;
                data.near = object.near;
                data.far = object.far;
            } else if (object instanceof THREE.OrthographicCamera) {
                data.left = object.left;
                data.right = object.right;
                data.top = object.top;
                data.bottom = object.bottom;
                data.near = object.near;
                data.far = object.far;
            } else if (object instanceof THREE.AmbientLight) {
                data.color = object.color.getHex();
            } else if (object instanceof THREE.DirectionalLight) {
                data.color = object.color.getHex();
                data.intensity = object.intensity;
            } else if (object instanceof THREE.PointLight) {
                data.color = object.color.getHex();
                data.intensity = object.intensity;
                data.distance = object.distance;
                data.decay = object.decay;
            } else if (object instanceof THREE.SpotLight) {
                data.color = object.color.getHex();
                data.intensity = object.intensity;
                data.distance = object.distance;
                data.angle = object.angle;
                data.exponent = object.exponent;
                data.decay = object.decay;
            } else if (object instanceof THREE.HemisphereLight) {
                data.color = object.color.getHex();
                data.groundColor = object.groundColor.getHex();
            } else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud) {
                data.geometry = parseGeometry(object.geometry);
                data.material = parseMaterial(object.material);
                if (object instanceof THREE.Line) data.mode = object.mode;
            } else if (object instanceof THREE.Sprite) {
                data.material = parseMaterial(object.material);
            }
            data.matrix = object.matrix.toArray();
            if (object.children.length > 0) {
                data.children = [];
                for (var i = 0; i < object.children.length; i++) {
                    data.children.push(parseObject(object.children[i]));
                }
            }
            return data;
        };
        output.object = parseObject(this);
        return output;
    },
    clone: function(object, recursive) {
        if (object === undefined) object = new THREE.Object3D();
        if (recursive === undefined) recursive = true;
        object.name = this.name;
        object.up.copy(this.up);
        object.position.copy(this.position);
        object.quaternion.copy(this.quaternion);
        object.scale.copy(this.scale);
        object.rotationAutoUpdate = this.rotationAutoUpdate;
        object.matrix.copy(this.matrix);
        object.matrixWorld.copy(this.matrixWorld);
        object.matrixAutoUpdate = this.matrixAutoUpdate;
        object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
        object.visible = this.visible;
        object.castShadow = this.castShadow;
        object.receiveShadow = this.receiveShadow;
        object.frustumCulled = this.frustumCulled;
        object.userData = JSON.parse(JSON.stringify(this.userData));
        if (recursive === true) {
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                object.add(child.clone());
            }
        }
        return object;
    }
};

THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);

THREE.Object3DIdCount = 0;

THREE.Face3 = function(a, b, c, normal, color, materialIndex) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
    this.vertexNormals = normal instanceof Array ? normal : [];
    this.color = color instanceof THREE.Color ? color : new THREE.Color();
    this.vertexColors = color instanceof Array ? color : [];
    this.vertexTangents = [];
    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
};

THREE.Face3.prototype = {
    constructor: THREE.Face3,
    clone: function() {
        var face = new THREE.Face3(this.a, this.b, this.c);
        face.normal.copy(this.normal);
        face.color.copy(this.color);
        face.materialIndex = this.materialIndex;
        for (var i = 0, il = this.vertexNormals.length; i < il; i++) {
            face.vertexNormals[i] = this.vertexNormals[i].clone();
        }
        for (var i = 0, il = this.vertexColors.length; i < il; i++) {
            face.vertexColors[i] = this.vertexColors[i].clone();
        }
        for (var i = 0, il = this.vertexTangents.length; i < il; i++) {
            face.vertexTangents[i] = this.vertexTangents[i].clone();
        }
        return face;
    }
};

THREE.Face4 = function(a, b, c, d, normal, color, materialIndex) {
    THREE.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
    return new THREE.Face3(a, b, c, normal, color, materialIndex);
};

THREE.BufferAttribute = function(array, itemSize) {
    this.array = array;
    this.itemSize = itemSize;
    this.needsUpdate = false;
};

THREE.BufferAttribute.prototype = {
    constructor: THREE.BufferAttribute,
    get length() {
        return this.array.length;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (var i = 0, l = this.itemSize; i < l; i++) {
            this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
    },
    set: function(value, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value, offset);
        return this;
    },
    setX: function(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
    },
    setY: function(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
    },
    setZ: function(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
    },
    setXY: function(index, x, y) {
        index *= this.itemSize;
        this.array[index] = x;
        this.array[index + 1] = y;
        return this;
    },
    setXYZ: function(index, x, y, z) {
        index *= this.itemSize;
        this.array[index] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
    },
    setXYZW: function(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
    },
    clone: function() {
        return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize);
    }
};

THREE.Int8Attribute = function(data, itemSize) {
    THREE.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
    return new THREE.BufferAttribute(data, itemSize);
};

THREE.Uint8Attribute = function(data, itemSize) {
    THREE.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
    return new THREE.BufferAttribute(data, itemSize);
};

THREE.Uint8ClampedAttribute = function(data, itemSize) {
    THREE.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
    return new THREE.BufferAttribute(data, itemSize);
};

THREE.Int16Attribute = function(data, itemSize) {
    THREE.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
    return new THREE.BufferAttribute(data, itemSize);
};

THREE.Uint16Attribute = function(data, itemSize) {
    THREE.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
    return new THREE.BufferAttribute(data, itemSize);
};

THREE.Int32Attribute = function(data, itemSize) {
    THREE.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
    return new THREE.BufferAttribute(data, itemSize);
};

THREE.Uint32Attribute = function(data, itemSize) {
    THREE.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
    return new THREE.BufferAttribute(data, itemSize);
};

THREE.Float32Attribute = function(data, itemSize) {
    THREE.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
    return new THREE.BufferAttribute(data, itemSize);
};

THREE.Float64Attribute = function(data, itemSize) {
    THREE.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
    return new THREE.BufferAttribute(data, itemSize);
};

THREE.DynamicBufferAttribute = function(array, itemSize) {
    THREE.BufferAttribute.call(this, array, itemSize);
    this.updateRange = {
        offset: 0,
        count: -1
    };
};

THREE.DynamicBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);

THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;

THREE.DynamicBufferAttribute.prototype.clone = function() {
    return new THREE.DynamicBufferAttribute(new this.array.constructor(this.array), this.itemSize);
};

THREE.BufferGeometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    });
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.attributes = {};
    this.attributesKeys = [];
    this.drawcalls = [];
    this.offsets = this.drawcalls;
    this.boundingBox = null;
    this.boundingSphere = null;
};

THREE.BufferGeometry.prototype = {
    constructor: THREE.BufferGeometry,
    addAttribute: function(name, attribute) {
        if (attribute instanceof THREE.BufferAttribute === false) {
            THREE.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
            this.attributes[name] = {
                array: arguments[1],
                itemSize: arguments[2]
            };
            return;
        }
        this.attributes[name] = attribute;
        this.attributesKeys = Object.keys(this.attributes);
    },
    getAttribute: function(name) {
        return this.attributes[name];
    },
    addDrawCall: function(start, count, indexOffset) {
        this.drawcalls.push({
            start: start,
            count: count,
            index: indexOffset !== undefined ? indexOffset : 0
        });
    },
    applyMatrix: function(matrix) {
        var position = this.attributes.position;
        if (position !== undefined) {
            matrix.applyToVector3Array(position.array);
            position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== undefined) {
            var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
            normalMatrix.applyToVector3Array(normal.array);
            normal.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
        }
    },
    center: function() {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.applyMatrix(new THREE.Matrix4().setPosition(offset));
        return offset;
    },
    fromGeometry: function(geometry, settings) {
        settings = settings || {
            vertexColors: THREE.NoColors
        };
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var faceVertexUvs = geometry.faceVertexUvs;
        var vertexColors = settings.vertexColors;
        var hasFaceVertexUv = faceVertexUvs[0].length > 0;
        var hasFaceVertexNormals = faces[0].vertexNormals.length == 3;
        var positions = new Float32Array(faces.length * 3 * 3);
        this.addAttribute("position", new THREE.BufferAttribute(positions, 3));
        var normals = new Float32Array(faces.length * 3 * 3);
        this.addAttribute("normal", new THREE.BufferAttribute(normals, 3));
        if (vertexColors !== THREE.NoColors) {
            var colors = new Float32Array(faces.length * 3 * 3);
            this.addAttribute("color", new THREE.BufferAttribute(colors, 3));
        }
        if (hasFaceVertexUv === true) {
            var uvs = new Float32Array(faces.length * 3 * 2);
            this.addAttribute("uv", new THREE.BufferAttribute(uvs, 2));
        }
        for (var i = 0, i2 = 0, i3 = 0; i < faces.length; i++, i2 += 6, i3 += 9) {
            var face = faces[i];
            var a = vertices[face.a];
            var b = vertices[face.b];
            var c = vertices[face.c];
            positions[i3] = a.x;
            positions[i3 + 1] = a.y;
            positions[i3 + 2] = a.z;
            positions[i3 + 3] = b.x;
            positions[i3 + 4] = b.y;
            positions[i3 + 5] = b.z;
            positions[i3 + 6] = c.x;
            positions[i3 + 7] = c.y;
            positions[i3 + 8] = c.z;
            if (hasFaceVertexNormals === true) {
                var na = face.vertexNormals[0];
                var nb = face.vertexNormals[1];
                var nc = face.vertexNormals[2];
                normals[i3] = na.x;
                normals[i3 + 1] = na.y;
                normals[i3 + 2] = na.z;
                normals[i3 + 3] = nb.x;
                normals[i3 + 4] = nb.y;
                normals[i3 + 5] = nb.z;
                normals[i3 + 6] = nc.x;
                normals[i3 + 7] = nc.y;
                normals[i3 + 8] = nc.z;
            } else {
                var n = face.normal;
                normals[i3] = n.x;
                normals[i3 + 1] = n.y;
                normals[i3 + 2] = n.z;
                normals[i3 + 3] = n.x;
                normals[i3 + 4] = n.y;
                normals[i3 + 5] = n.z;
                normals[i3 + 6] = n.x;
                normals[i3 + 7] = n.y;
                normals[i3 + 8] = n.z;
            }
            if (vertexColors === THREE.FaceColors) {
                var fc = face.color;
                colors[i3] = fc.r;
                colors[i3 + 1] = fc.g;
                colors[i3 + 2] = fc.b;
                colors[i3 + 3] = fc.r;
                colors[i3 + 4] = fc.g;
                colors[i3 + 5] = fc.b;
                colors[i3 + 6] = fc.r;
                colors[i3 + 7] = fc.g;
                colors[i3 + 8] = fc.b;
            } else if (vertexColors === THREE.VertexColors) {
                var vca = face.vertexColors[0];
                var vcb = face.vertexColors[1];
                var vcc = face.vertexColors[2];
                colors[i3] = vca.r;
                colors[i3 + 1] = vca.g;
                colors[i3 + 2] = vca.b;
                colors[i3 + 3] = vcb.r;
                colors[i3 + 4] = vcb.g;
                colors[i3 + 5] = vcb.b;
                colors[i3 + 6] = vcc.r;
                colors[i3 + 7] = vcc.g;
                colors[i3 + 8] = vcc.b;
            }
            if (hasFaceVertexUv === true) {
                var uva = faceVertexUvs[0][i][0];
                var uvb = faceVertexUvs[0][i][1];
                var uvc = faceVertexUvs[0][i][2];
                uvs[i2] = uva.x;
                uvs[i2 + 1] = uva.y;
                uvs[i2 + 2] = uvb.x;
                uvs[i2 + 3] = uvb.y;
                uvs[i2 + 4] = uvc.x;
                uvs[i2 + 5] = uvc.y;
            }
        }
        this.computeBoundingSphere();
        return this;
    },
    computeBoundingBox: function() {
        var vector = new THREE.Vector3();
        return function() {
            if (this.boundingBox === null) {
                this.boundingBox = new THREE.Box3();
            }
            var positions = this.attributes.position.array;
            if (positions) {
                var bb = this.boundingBox;
                bb.makeEmpty();
                for (var i = 0, il = positions.length; i < il; i += 3) {
                    vector.set(positions[i], positions[i + 1], positions[i + 2]);
                    bb.expandByPoint(vector);
                }
            }
            if (positions === undefined || positions.length === 0) {
                this.boundingBox.min.set(0, 0, 0);
                this.boundingBox.max.set(0, 0, 0);
            }
            if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                THREE.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.');
            }
        };
    }(),
    computeBoundingSphere: function() {
        var box = new THREE.Box3();
        var vector = new THREE.Vector3();
        return function() {
            if (this.boundingSphere === null) {
                this.boundingSphere = new THREE.Sphere();
            }
            var positions = this.attributes.position.array;
            if (positions) {
                box.makeEmpty();
                var center = this.boundingSphere.center;
                for (var i = 0, il = positions.length; i < il; i += 3) {
                    vector.set(positions[i], positions[i + 1], positions[i + 2]);
                    box.expandByPoint(vector);
                }
                box.center(center);
                var maxRadiusSq = 0;
                for (var i = 0, il = positions.length; i < il; i += 3) {
                    vector.set(positions[i], positions[i + 1], positions[i + 2]);
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                }
                this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                if (isNaN(this.boundingSphere.radius)) {
                    THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.');
                }
            }
        };
    }(),
    computeFaceNormals: function() {},
    computeVertexNormals: function() {
        var attributes = this.attributes;
        if (attributes.position) {
            var positions = attributes.position.array;
            if (attributes.normal === undefined) {
                this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(positions.length), 3));
            } else {
                var normals = attributes.normal.array;
                for (var i = 0, il = normals.length; i < il; i++) {
                    normals[i] = 0;
                }
            }
            var normals = attributes.normal.array;
            var vA, vB, vC, pA = new THREE.Vector3(), pB = new THREE.Vector3(), pC = new THREE.Vector3(), cb = new THREE.Vector3(), ab = new THREE.Vector3();
            if (attributes.index) {
                var indices = attributes.index.array;
                var offsets = this.offsets.length > 0 ? this.offsets : [ {
                    start: 0,
                    count: indices.length,
                    index: 0
                } ];
                for (var j = 0, jl = offsets.length; j < jl; ++j) {
                    var start = offsets[j].start;
                    var count = offsets[j].count;
                    var index = offsets[j].index;
                    for (var i = start, il = start + count; i < il; i += 3) {
                        vA = (index + indices[i]) * 3;
                        vB = (index + indices[i + 1]) * 3;
                        vC = (index + indices[i + 2]) * 3;
                        pA.fromArray(positions, vA);
                        pB.fromArray(positions, vB);
                        pC.fromArray(positions, vC);
                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);
                        normals[vA] += cb.x;
                        normals[vA + 1] += cb.y;
                        normals[vA + 2] += cb.z;
                        normals[vB] += cb.x;
                        normals[vB + 1] += cb.y;
                        normals[vB + 2] += cb.z;
                        normals[vC] += cb.x;
                        normals[vC + 1] += cb.y;
                        normals[vC + 2] += cb.z;
                    }
                }
            } else {
                for (var i = 0, il = positions.length; i < il; i += 9) {
                    pA.fromArray(positions, i);
                    pB.fromArray(positions, i + 3);
                    pC.fromArray(positions, i + 6);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    normals[i] = cb.x;
                    normals[i + 1] = cb.y;
                    normals[i + 2] = cb.z;
                    normals[i + 3] = cb.x;
                    normals[i + 4] = cb.y;
                    normals[i + 5] = cb.z;
                    normals[i + 6] = cb.x;
                    normals[i + 7] = cb.y;
                    normals[i + 8] = cb.z;
                }
            }
            this.normalizeNormals();
            attributes.normal.needsUpdate = true;
        }
    },
    computeTangents: function() {
        if (this.attributes.index === undefined || this.attributes.position === undefined || this.attributes.normal === undefined || this.attributes.uv === undefined) {
            THREE.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
            return;
        }
        var indices = this.attributes.index.array;
        var positions = this.attributes.position.array;
        var normals = this.attributes.normal.array;
        var uvs = this.attributes.uv.array;
        var nVertices = positions.length / 3;
        if (this.attributes.tangent === undefined) {
            this.addAttribute("tangent", new THREE.BufferAttribute(new Float32Array(4 * nVertices), 4));
        }
        var tangents = this.attributes.tangent.array;
        var tan1 = [], tan2 = [];
        for (var k = 0; k < nVertices; k++) {
            tan1[k] = new THREE.Vector3();
            tan2[k] = new THREE.Vector3();
        }
        var vA = new THREE.Vector3(), vB = new THREE.Vector3(), vC = new THREE.Vector3(), uvA = new THREE.Vector2(), uvB = new THREE.Vector2(), uvC = new THREE.Vector2(), x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r;
        var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();
        function handleTriangle(a, b, c) {
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            x1 = vB.x - vA.x;
            x2 = vC.x - vA.x;
            y1 = vB.y - vA.y;
            y2 = vC.y - vA.y;
            z1 = vB.z - vA.z;
            z2 = vC.z - vA.z;
            s1 = uvB.x - uvA.x;
            s2 = uvC.x - uvA.x;
            t1 = uvB.y - uvA.y;
            t2 = uvC.y - uvA.y;
            r = 1 / (s1 * t2 - s2 * t1);
            sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
            tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
            tan1[a].add(sdir);
            tan1[b].add(sdir);
            tan1[c].add(sdir);
            tan2[a].add(tdir);
            tan2[b].add(tdir);
            tan2[c].add(tdir);
        }
        var i, il;
        var j, jl;
        var iA, iB, iC;
        if (this.drawcalls.length === 0) {
            this.addDrawCall(0, indices.length, 0);
        }
        var drawcalls = this.drawcalls;
        for (j = 0, jl = drawcalls.length; j < jl; ++j) {
            var start = drawcalls[j].start;
            var count = drawcalls[j].count;
            var index = drawcalls[j].index;
            for (i = start, il = start + count; i < il; i += 3) {
                iA = index + indices[i];
                iB = index + indices[i + 1];
                iC = index + indices[i + 2];
                handleTriangle(iA, iB, iC);
            }
        }
        var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
        var n = new THREE.Vector3(), n2 = new THREE.Vector3();
        var w, t, test;
        function handleVertex(v) {
            n.fromArray(normals, v * 3);
            n2.copy(n);
            t = tan1[v];
            tmp.copy(t);
            tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
            tmp2.crossVectors(n2, t);
            test = tmp2.dot(tan2[v]);
            w = test < 0 ? -1 : 1;
            tangents[v * 4] = tmp.x;
            tangents[v * 4 + 1] = tmp.y;
            tangents[v * 4 + 2] = tmp.z;
            tangents[v * 4 + 3] = w;
        }
        for (j = 0, jl = drawcalls.length; j < jl; ++j) {
            var start = drawcalls[j].start;
            var count = drawcalls[j].count;
            var index = drawcalls[j].index;
            for (i = start, il = start + count; i < il; i += 3) {
                iA = index + indices[i];
                iB = index + indices[i + 1];
                iC = index + indices[i + 2];
                handleVertex(iA);
                handleVertex(iB);
                handleVertex(iC);
            }
        }
    },
    computeOffsets: function(size) {
        if (size === undefined) size = 65535;
        var indices = this.attributes.index.array;
        var vertices = this.attributes.position.array;
        var facesCount = indices.length / 3;
        var sortedIndices = new Uint16Array(indices.length);
        var indexPtr = 0;
        var vertexPtr = 0;
        var offsets = [ {
            start: 0,
            count: 0,
            index: 0
        } ];
        var offset = offsets[0];
        var duplicatedVertices = 0;
        var newVerticeMaps = 0;
        var faceVertices = new Int32Array(6);
        var vertexMap = new Int32Array(vertices.length);
        var revVertexMap = new Int32Array(vertices.length);
        for (var j = 0; j < vertices.length; j++) {
            vertexMap[j] = -1;
            revVertexMap[j] = -1;
        }
        for (var findex = 0; findex < facesCount; findex++) {
            newVerticeMaps = 0;
            for (var vo = 0; vo < 3; vo++) {
                var vid = indices[findex * 3 + vo];
                if (vertexMap[vid] == -1) {
                    faceVertices[vo * 2] = vid;
                    faceVertices[vo * 2 + 1] = -1;
                    newVerticeMaps++;
                } else if (vertexMap[vid] < offset.index) {
                    faceVertices[vo * 2] = vid;
                    faceVertices[vo * 2 + 1] = -1;
                    duplicatedVertices++;
                } else {
                    faceVertices[vo * 2] = vid;
                    faceVertices[vo * 2 + 1] = vertexMap[vid];
                }
            }
            var faceMax = vertexPtr + newVerticeMaps;
            if (faceMax > offset.index + size) {
                var new_offset = {
                    start: indexPtr,
                    count: 0,
                    index: vertexPtr
                };
                offsets.push(new_offset);
                offset = new_offset;
                for (var v = 0; v < 6; v += 2) {
                    var new_vid = faceVertices[v + 1];
                    if (new_vid > -1 && new_vid < offset.index) faceVertices[v + 1] = -1;
                }
            }
            for (var v = 0; v < 6; v += 2) {
                var vid = faceVertices[v];
                var new_vid = faceVertices[v + 1];
                if (new_vid === -1) new_vid = vertexPtr++;
                vertexMap[vid] = new_vid;
                revVertexMap[new_vid] = vid;
                sortedIndices[indexPtr++] = new_vid - offset.index;
                offset.count++;
            }
        }
        this.reorderBuffers(sortedIndices, revVertexMap, vertexPtr);
        this.offsets = offsets;
        this.drawcalls = offsets;
        return offsets;
    },
    merge: function(geometry, offset) {
        if (geometry instanceof THREE.BufferGeometry === false) {
            THREE.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            return;
        }
        if (offset === undefined) offset = 0;
        var attributes = this.attributes;
        for (var key in attributes) {
            if (geometry.attributes[key] === undefined) continue;
            var attribute1 = attributes[key];
            var attributeArray1 = attribute1.array;
            var attribute2 = geometry.attributes[key];
            var attributeArray2 = attribute2.array;
            var attributeSize = attribute2.itemSize;
            for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
                attributeArray1[j] = attributeArray2[i];
            }
        }
        return this;
    },
    normalizeNormals: function() {
        var normals = this.attributes.normal.array;
        var x, y, z, n;
        for (var i = 0, il = normals.length; i < il; i += 3) {
            x = normals[i];
            y = normals[i + 1];
            z = normals[i + 2];
            n = 1 / Math.sqrt(x * x + y * y + z * z);
            normals[i] *= n;
            normals[i + 1] *= n;
            normals[i + 2] *= n;
        }
    },
    reorderBuffers: function(indexBuffer, indexMap, vertexCount) {
        var sortedAttributes = {};
        for (var attr in this.attributes) {
            if (attr == "index") continue;
            var sourceArray = this.attributes[attr].array;
            sortedAttributes[attr] = new sourceArray.constructor(this.attributes[attr].itemSize * vertexCount);
        }
        for (var new_vid = 0; new_vid < vertexCount; new_vid++) {
            var vid = indexMap[new_vid];
            for (var attr in this.attributes) {
                if (attr == "index") continue;
                var attrArray = this.attributes[attr].array;
                var attrSize = this.attributes[attr].itemSize;
                var sortedAttr = sortedAttributes[attr];
                for (var k = 0; k < attrSize; k++) sortedAttr[new_vid * attrSize + k] = attrArray[vid * attrSize + k];
            }
        }
        this.attributes["index"].array = indexBuffer;
        for (var attr in this.attributes) {
            if (attr == "index") continue;
            this.attributes[attr].array = sortedAttributes[attr];
            this.attributes[attr].numItems = this.attributes[attr].itemSize * vertexCount;
        }
    },
    toJSON: function() {
        var output = {
            metadata: {
                version: 4,
                type: "BufferGeometry",
                generator: "BufferGeometryExporter"
            },
            uuid: this.uuid,
            type: this.type,
            data: {
                attributes: {}
            }
        };
        var attributes = this.attributes;
        var offsets = this.offsets;
        var boundingSphere = this.boundingSphere;
        for (var key in attributes) {
            var attribute = attributes[key];
            var array = Array.prototype.slice.call(attribute.array);
            output.data.attributes[key] = {
                itemSize: attribute.itemSize,
                type: attribute.array.constructor.name,
                array: array
            };
        }
        if (offsets.length > 0) {
            output.data.offsets = JSON.parse(JSON.stringify(offsets));
        }
        if (boundingSphere !== null) {
            output.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            };
        }
        return output;
    },
    clone: function() {
        var geometry = new THREE.BufferGeometry();
        for (var attr in this.attributes) {
            var sourceAttr = this.attributes[attr];
            geometry.addAttribute(attr, sourceAttr.clone());
        }
        for (var i = 0, il = this.offsets.length; i < il; i++) {
            var offset = this.offsets[i];
            geometry.offsets.push({
                start: offset.start,
                index: offset.index,
                count: offset.count
            });
        }
        return geometry;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
};

THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);

THREE.Geometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    });
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [ [] ];
    this.morphTargets = [];
    this.morphColors = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.hasTangents = false;
    this.dynamic = true;
    this.verticesNeedUpdate = false;
    this.elementsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.tangentsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
};

THREE.Geometry.prototype = {
    constructor: THREE.Geometry,
    applyMatrix: function(matrix) {
        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        for (var i = 0, il = this.vertices.length; i < il; i++) {
            var vertex = this.vertices[i];
            vertex.applyMatrix4(matrix);
        }
        for (var i = 0, il = this.faces.length; i < il; i++) {
            var face = this.faces[i];
            face.normal.applyMatrix3(normalMatrix).normalize();
            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
            }
        }
        if (this.boundingBox !== null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
    },
    fromBufferGeometry: function(geometry) {
        var scope = this;
        var attributes = geometry.attributes;
        var vertices = attributes.position.array;
        var indices = attributes.index !== undefined ? attributes.index.array : undefined;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var tempNormals = [];
        var tempUVs = [];
        for (var i = 0, j = 0; i < vertices.length; i += 3, j += 2) {
            scope.vertices.push(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
            if (normals !== undefined) {
                tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));
            }
            if (colors !== undefined) {
                scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));
            }
            if (uvs !== undefined) {
                tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));
            }
        }
        var addFace = function(a, b, c) {
            var vertexNormals = normals !== undefined ? [ tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone() ] : [];
            var vertexColors = colors !== undefined ? [ scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone() ] : [];
            scope.faces.push(new THREE.Face3(a, b, c, vertexNormals, vertexColors));
            if (uvs !== undefined) {
                scope.faceVertexUvs[0].push([ tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone() ]);
            }
        };
        if (indices !== undefined) {
            var drawcalls = geometry.drawcalls;
            if (drawcalls.length > 0) {
                for (var i = 0; i < drawcalls.length; i++) {
                    var drawcall = drawcalls[i];
                    var start = drawcall.start;
                    var count = drawcall.count;
                    var index = drawcall.index;
                    for (var j = start, jl = start + count; j < jl; j += 3) {
                        addFace(index + indices[j], index + indices[j + 1], index + indices[j + 2]);
                    }
                }
            } else {
                for (var i = 0; i < indices.length; i += 3) {
                    addFace(indices[i], indices[i + 1], indices[i + 2]);
                }
            }
        } else {
            for (var i = 0; i < vertices.length / 3; i += 3) {
                addFace(i, i + 1, i + 2);
            }
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
        }
        if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
        }
        return this;
    },
    center: function() {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.applyMatrix(new THREE.Matrix4().setPosition(offset));
        return offset;
    },
    computeFaceNormals: function() {
        var cb = new THREE.Vector3(), ab = new THREE.Vector3();
        for (var f = 0, fl = this.faces.length; f < fl; f++) {
            var face = this.faces[f];
            var vA = this.vertices[face.a];
            var vB = this.vertices[face.b];
            var vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            cb.normalize();
            face.normal.copy(cb);
        }
    },
    computeVertexNormals: function(areaWeighted) {
        var v, vl, f, fl, face, vertices;
        vertices = new Array(this.vertices.length);
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
            vertices[v] = new THREE.Vector3();
        }
        if (areaWeighted) {
            var vA, vB, vC;
            var cb = new THREE.Vector3(), ab = new THREE.Vector3();
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                vA = this.vertices[face.a];
                vB = this.vertices[face.b];
                vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                vertices[face.a].add(cb);
                vertices[face.b].add(cb);
                vertices[face.c].add(cb);
            }
        } else {
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                vertices[face.a].add(face.normal);
                vertices[face.b].add(face.normal);
                vertices[face.c].add(face.normal);
            }
        }
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
            vertices[v].normalize();
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            face.vertexNormals[0] = vertices[face.a].clone();
            face.vertexNormals[1] = vertices[face.b].clone();
            face.vertexNormals[2] = vertices[face.c].clone();
        }
    },
    computeMorphNormals: function() {
        var i, il, f, fl, face;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            if (!face.__originalFaceNormal) {
                face.__originalFaceNormal = face.normal.clone();
            } else {
                face.__originalFaceNormal.copy(face.normal);
            }
            if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
            for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                if (!face.__originalVertexNormals[i]) {
                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                } else {
                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                }
            }
        }
        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;
        for (i = 0, il = this.morphTargets.length; i < il; i++) {
            if (!this.morphNormals[i]) {
                this.morphNormals[i] = {};
                this.morphNormals[i].faceNormals = [];
                this.morphNormals[i].vertexNormals = [];
                var dstNormalsFace = this.morphNormals[i].faceNormals;
                var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                var faceNormal, vertexNormals;
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    faceNormal = new THREE.Vector3();
                    vertexNormals = {
                        a: new THREE.Vector3(),
                        b: new THREE.Vector3(),
                        c: new THREE.Vector3()
                    };
                    dstNormalsFace.push(faceNormal);
                    dstNormalsVertex.push(vertexNormals);
                }
            }
            var morphNormals = this.morphNormals[i];
            tmpGeo.vertices = this.morphTargets[i].vertices;
            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();
            var faceNormal, vertexNormals;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                faceNormal = morphNormals.faceNormals[f];
                vertexNormals = morphNormals.vertexNormals[f];
                faceNormal.copy(face.normal);
                vertexNormals.a.copy(face.vertexNormals[0]);
                vertexNormals.b.copy(face.vertexNormals[1]);
                vertexNormals.c.copy(face.vertexNormals[2]);
            }
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;
        }
    },
    computeTangents: function() {
        var f, fl, v, vl, i, vertexIndex, face, uv, vA, vB, vC, uvA, uvB, uvC, x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r, t, test, tan1 = [], tan2 = [], sdir = new THREE.Vector3(), tdir = new THREE.Vector3(), tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(), n = new THREE.Vector3(), w;
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
            tan1[v] = new THREE.Vector3();
            tan2[v] = new THREE.Vector3();
        }
        function handleTriangle(context, a, b, c, ua, ub, uc) {
            vA = context.vertices[a];
            vB = context.vertices[b];
            vC = context.vertices[c];
            uvA = uv[ua];
            uvB = uv[ub];
            uvC = uv[uc];
            x1 = vB.x - vA.x;
            x2 = vC.x - vA.x;
            y1 = vB.y - vA.y;
            y2 = vC.y - vA.y;
            z1 = vB.z - vA.z;
            z2 = vC.z - vA.z;
            s1 = uvB.x - uvA.x;
            s2 = uvC.x - uvA.x;
            t1 = uvB.y - uvA.y;
            t2 = uvC.y - uvA.y;
            r = 1 / (s1 * t2 - s2 * t1);
            sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
            tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
            tan1[a].add(sdir);
            tan1[b].add(sdir);
            tan1[c].add(sdir);
            tan2[a].add(tdir);
            tan2[b].add(tdir);
            tan2[c].add(tdir);
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            uv = this.faceVertexUvs[0][f];
            handleTriangle(this, face.a, face.b, face.c, 0, 1, 2);
        }
        var faceIndex = [ "a", "b", "c", "d" ];
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            for (i = 0; i < Math.min(face.vertexNormals.length, 3); i++) {
                n.copy(face.vertexNormals[i]);
                vertexIndex = face[faceIndex[i]];
                t = tan1[vertexIndex];
                tmp.copy(t);
                tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
                tmp2.crossVectors(face.vertexNormals[i], t);
                test = tmp2.dot(tan2[vertexIndex]);
                w = test < 0 ? -1 : 1;
                face.vertexTangents[i] = new THREE.Vector4(tmp.x, tmp.y, tmp.z, w);
            }
        }
        this.hasTangents = true;
    },
    computeLineDistances: function() {
        var d = 0;
        var vertices = this.vertices;
        for (var i = 0, il = vertices.length; i < il; i++) {
            if (i > 0) {
                d += vertices[i].distanceTo(vertices[i - 1]);
            }
            this.lineDistances[i] = d;
        }
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) {
            this.boundingBox = new THREE.Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
            this.boundingSphere = new THREE.Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(geometry, matrix, materialIndexOffset) {
        if (geometry instanceof THREE.Geometry === false) {
            THREE.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
            return;
        }
        var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0];
        if (materialIndexOffset === undefined) materialIndexOffset = 0;
        if (matrix !== undefined) {
            normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        }
        for (var i = 0, il = vertices2.length; i < il; i++) {
            var vertex = vertices2[i];
            var vertexCopy = vertex.clone();
            if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
            vertices1.push(vertexCopy);
        }
        for (i = 0, il = faces2.length; i < il; i++) {
            var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
            faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
            faceCopy.normal.copy(face.normal);
            if (normalMatrix !== undefined) {
                faceCopy.normal.applyMatrix3(normalMatrix).normalize();
            }
            for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                normal = faceVertexNormals[j].clone();
                if (normalMatrix !== undefined) {
                    normal.applyMatrix3(normalMatrix).normalize();
                }
                faceCopy.vertexNormals.push(normal);
            }
            faceCopy.color.copy(face.color);
            for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                color = faceVertexColors[j];
                faceCopy.vertexColors.push(color.clone());
            }
            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
            faces1.push(faceCopy);
        }
        for (i = 0, il = uvs2.length; i < il; i++) {
            var uv = uvs2[i], uvCopy = [];
            if (uv === undefined) {
                continue;
            }
            for (var j = 0, jl = uv.length; j < jl; j++) {
                uvCopy.push(uv[j].clone());
            }
            uvs1.push(uvCopy);
        }
    },
    mergeMesh: function(mesh) {
        if (mesh instanceof THREE.Mesh === false) {
            THREE.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
            return;
        }
        mesh.matrixAutoUpdate && mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
    },
    mergeVertices: function() {
        var verticesMap = {};
        var unique = [], changes = [];
        var v, key;
        var precisionPoints = 4;
        var precision = Math.pow(10, precisionPoints);
        var i, il, face;
        var indices, j, jl;
        for (i = 0, il = this.vertices.length; i < il; i++) {
            v = this.vertices[i];
            key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
            if (verticesMap[key] === undefined) {
                verticesMap[key] = i;
                unique.push(this.vertices[i]);
                changes[i] = unique.length - 1;
            } else {
                changes[i] = changes[verticesMap[key]];
            }
        }
        var faceIndicesToRemove = [];
        for (i = 0, il = this.faces.length; i < il; i++) {
            face = this.faces[i];
            face.a = changes[face.a];
            face.b = changes[face.b];
            face.c = changes[face.c];
            indices = [ face.a, face.b, face.c ];
            var dupIndex = -1;
            for (var n = 0; n < 3; n++) {
                if (indices[n] == indices[(n + 1) % 3]) {
                    dupIndex = n;
                    faceIndicesToRemove.push(i);
                    break;
                }
            }
        }
        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
            var idx = faceIndicesToRemove[i];
            this.faces.splice(idx, 1);
            for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                this.faceVertexUvs[j].splice(idx, 1);
            }
        }
        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
    },
    toJSON: function() {
        var output = {
            metadata: {
                version: 4,
                type: "BufferGeometry",
                generator: "BufferGeometryExporter"
            },
            uuid: this.uuid,
            type: this.type
        };
        if (this.name !== "") output.name = this.name;
        if (this.parameters !== undefined) {
            var parameters = this.parameters;
            for (var key in parameters) {
                if (parameters[key] !== undefined) output[key] = parameters[key];
            }
            return output;
        }
        var vertices = [];
        for (var i = 0; i < this.vertices.length; i++) {
            var vertex = this.vertices[i];
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};
        for (var i = 0; i < this.faces.length; i++) {
            var face = this.faces[i];
            var hasMaterial = false;
            var hasFaceUv = false;
            var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
            var hasFaceNormal = face.normal.length() > 0;
            var hasFaceVertexNormal = face.vertexNormals.length > 0;
            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            var hasFaceVertexColor = face.vertexColors.length > 0;
            var faceType = 0;
            faceType = setBit(faceType, 0, 0);
            faceType = setBit(faceType, 1, hasMaterial);
            faceType = setBit(faceType, 2, hasFaceUv);
            faceType = setBit(faceType, 3, hasFaceVertexUv);
            faceType = setBit(faceType, 4, hasFaceNormal);
            faceType = setBit(faceType, 5, hasFaceVertexNormal);
            faceType = setBit(faceType, 6, hasFaceColor);
            faceType = setBit(faceType, 7, hasFaceVertexColor);
            faces.push(faceType);
            faces.push(face.a, face.b, face.c);
            if (hasFaceVertexUv) {
                var faceVertexUvs = this.faceVertexUvs[0][i];
                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
            }
            if (hasFaceNormal) {
                faces.push(getNormalIndex(face.normal));
            }
            if (hasFaceVertexNormal) {
                var vertexNormals = face.vertexNormals;
                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
            }
            if (hasFaceColor) {
                faces.push(getColorIndex(face.color));
            }
            if (hasFaceVertexColor) {
                var vertexColors = face.vertexColors;
                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
            }
        }
        function setBit(value, position, enabled) {
            return enabled ? value | 1 << position : value & ~(1 << position);
        }
        function getNormalIndex(normal) {
            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
            if (normalsHash[hash] !== undefined) {
                return normalsHash[hash];
            }
            normalsHash[hash] = normals.length / 3;
            normals.push(normal.x, normal.y, normal.z);
            return normalsHash[hash];
        }
        function getColorIndex(color) {
            var hash = color.r.toString() + color.g.toString() + color.b.toString();
            if (colorsHash[hash] !== undefined) {
                return colorsHash[hash];
            }
            colorsHash[hash] = colors.length;
            colors.push(color.getHex());
            return colorsHash[hash];
        }
        function getUvIndex(uv) {
            var hash = uv.x.toString() + uv.y.toString();
            if (uvsHash[hash] !== undefined) {
                return uvsHash[hash];
            }
            uvsHash[hash] = uvs.length / 2;
            uvs.push(uv.x, uv.y);
            return uvsHash[hash];
        }
        output.data = {};
        output.data.vertices = vertices;
        output.data.normals = normals;
        if (colors.length > 0) output.data.colors = colors;
        if (uvs.length > 0) output.data.uvs = [ uvs ];
        output.data.faces = faces;
        return output;
    },
    clone: function() {
        var geometry = new THREE.Geometry();
        var vertices = this.vertices;
        for (var i = 0, il = vertices.length; i < il; i++) {
            geometry.vertices.push(vertices[i].clone());
        }
        var faces = this.faces;
        for (var i = 0, il = faces.length; i < il; i++) {
            geometry.faces.push(faces[i].clone());
        }
        for (var i = 0, il = this.faceVertexUvs.length; i < il; i++) {
            var faceVertexUvs = this.faceVertexUvs[i];
            if (geometry.faceVertexUvs[i] === undefined) {
                geometry.faceVertexUvs[i] = [];
            }
            for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                var uvs = faceVertexUvs[j], uvsCopy = [];
                for (var k = 0, kl = uvs.length; k < kl; k++) {
                    var uv = uvs[k];
                    uvsCopy.push(uv.clone());
                }
                geometry.faceVertexUvs[i].push(uvsCopy);
            }
        }
        return geometry;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
};

THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);

THREE.GeometryIdCount = 0;

THREE.Camera = function() {
    THREE.Object3D.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new THREE.Matrix4();
    this.projectionMatrix = new THREE.Matrix4();
};

THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);

THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function() {
    var quaternion = new THREE.Quaternion();
    return function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.getWorldQuaternion(quaternion);
        return result.set(0, 0, -1).applyQuaternion(quaternion);
    };
}();

THREE.Camera.prototype.lookAt = function() {
    var m1 = new THREE.Matrix4();
    return function(vector) {
        m1.lookAt(this.position, vector, this.up);
        this.quaternion.setFromRotationMatrix(m1);
    };
}();

THREE.Camera.prototype.clone = function(camera) {
    if (camera === undefined) camera = new THREE.Camera();
    THREE.Object3D.prototype.clone.call(this, camera);
    camera.matrixWorldInverse.copy(this.matrixWorldInverse);
    camera.projectionMatrix.copy(this.projectionMatrix);
    return camera;
};

THREE.CubeCamera = function(near, far, cubeResolution) {
    THREE.Object3D.call(this);
    this.type = "CubeCamera";
    var fov = 90, aspect = 1;
    var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
    this.add(cameraPX);
    var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
    this.add(cameraNX);
    var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
    this.add(cameraPY);
    var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
    this.add(cameraNY);
    var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
    this.add(cameraPZ);
    var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
    this.add(cameraNZ);
    this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    });
    this.updateCubeMap = function(renderer, scene) {
        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.generateMipmaps;
        renderTarget.generateMipmaps = false;
        renderTarget.activeCubeFace = 0;
        renderer.render(scene, cameraPX, renderTarget);
        renderTarget.activeCubeFace = 1;
        renderer.render(scene, cameraNX, renderTarget);
        renderTarget.activeCubeFace = 2;
        renderer.render(scene, cameraPY, renderTarget);
        renderTarget.activeCubeFace = 3;
        renderer.render(scene, cameraNY, renderTarget);
        renderTarget.activeCubeFace = 4;
        renderer.render(scene, cameraPZ, renderTarget);
        renderTarget.generateMipmaps = generateMipmaps;
        renderTarget.activeCubeFace = 5;
        renderer.render(scene, cameraNZ, renderTarget);
    };
};

THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);

THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

THREE.OrthographicCamera = function(left, right, top, bottom, near, far) {
    THREE.Camera.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near !== undefined ? near : .1;
    this.far = far !== undefined ? far : 2e3;
    this.updateProjectionMatrix();
};

THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);

THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
    var dx = (this.right - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.right + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    this.projectionMatrix.makeOrthographic(cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far);
};

THREE.OrthographicCamera.prototype.clone = function() {
    var camera = new THREE.OrthographicCamera();
    THREE.Camera.prototype.clone.call(this, camera);
    camera.zoom = this.zoom;
    camera.left = this.left;
    camera.right = this.right;
    camera.top = this.top;
    camera.bottom = this.bottom;
    camera.near = this.near;
    camera.far = this.far;
    camera.projectionMatrix.copy(this.projectionMatrix);
    return camera;
};

THREE.PerspectiveCamera = function(fov, aspect, near, far) {
    THREE.Camera.call(this);
    this.type = "PerspectiveCamera";
    this.zoom = 1;
    this.fov = fov !== undefined ? fov : 50;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.near = near !== undefined ? near : .1;
    this.far = far !== undefined ? far : 2e3;
    this.updateProjectionMatrix();
};

THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);

THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;

THREE.PerspectiveCamera.prototype.setLens = function(focalLength, frameHeight) {
    if (frameHeight === undefined) frameHeight = 24;
    this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
    this.updateProjectionMatrix();
};

THREE.PerspectiveCamera.prototype.setViewOffset = function(fullWidth, fullHeight, x, y, width, height) {
    this.fullWidth = fullWidth;
    this.fullHeight = fullHeight;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.updateProjectionMatrix();
};

THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
    var fov = THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(this.fov) * .5) / this.zoom));
    if (this.fullWidth) {
        var aspect = this.fullWidth / this.fullHeight;
        var top = Math.tan(THREE.Math.degToRad(fov * .5)) * this.near;
        var bottom = -top;
        var left = aspect * bottom;
        var right = aspect * top;
        var width = Math.abs(right - left);
        var height = Math.abs(top - bottom);
        this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);
    } else {
        this.projectionMatrix.makePerspective(fov, this.aspect, this.near, this.far);
    }
};

THREE.PerspectiveCamera.prototype.clone = function() {
    var camera = new THREE.PerspectiveCamera();
    THREE.Camera.prototype.clone.call(this, camera);
    camera.zoom = this.zoom;
    camera.fov = this.fov;
    camera.aspect = this.aspect;
    camera.near = this.near;
    camera.far = this.far;
    camera.projectionMatrix.copy(this.projectionMatrix);
    return camera;
};

THREE.Light = function(color) {
    THREE.Object3D.call(this);
    this.type = "Light";
    this.color = new THREE.Color(color);
};

THREE.Light.prototype = Object.create(THREE.Object3D.prototype);

THREE.Light.prototype.constructor = THREE.Light;

THREE.Light.prototype.clone = function(light) {
    if (light === undefined) light = new THREE.Light();
    THREE.Object3D.prototype.clone.call(this, light);
    light.color.copy(this.color);
    return light;
};

THREE.AmbientLight = function(color) {
    THREE.Light.call(this, color);
    this.type = "AmbientLight";
};

THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);

THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

THREE.AmbientLight.prototype.clone = function() {
    var light = new THREE.AmbientLight();
    THREE.Light.prototype.clone.call(this, light);
    return light;
};

THREE.AreaLight = function(color, intensity) {
    THREE.Light.call(this, color);
    this.type = "AreaLight";
    this.normal = new THREE.Vector3(0, -1, 0);
    this.right = new THREE.Vector3(1, 0, 0);
    this.intensity = intensity !== undefined ? intensity : 1;
    this.width = 1;
    this.height = 1;
    this.constantAttenuation = 1.5;
    this.linearAttenuation = .5;
    this.quadraticAttenuation = .1;
};

THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);

THREE.AreaLight.prototype.constructor = THREE.AreaLight;

THREE.DirectionalLight = function(color, intensity) {
    THREE.Light.call(this, color);
    this.type = "DirectionalLight";
    this.position.set(0, 1, 0);
    this.target = new THREE.Object3D();
    this.intensity = intensity !== undefined ? intensity : 1;
    this.castShadow = false;
    this.onlyShadow = false;
    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5e3;
    this.shadowCameraLeft = -500;
    this.shadowCameraRight = 500;
    this.shadowCameraTop = 500;
    this.shadowCameraBottom = -500;
    this.shadowCameraVisible = false;
    this.shadowBias = 0;
    this.shadowDarkness = .5;
    this.shadowMapWidth = 512;
    this.shadowMapHeight = 512;
    this.shadowCascade = false;
    this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3);
    this.shadowCascadeCount = 2;
    this.shadowCascadeBias = [ 0, 0, 0 ];
    this.shadowCascadeWidth = [ 512, 512, 512 ];
    this.shadowCascadeHeight = [ 512, 512, 512 ];
    this.shadowCascadeNearZ = [ -1, .99, .998 ];
    this.shadowCascadeFarZ = [ .99, .998, 1 ];
    this.shadowCascadeArray = [];
    this.shadowMap = null;
    this.shadowMapSize = null;
    this.shadowCamera = null;
    this.shadowMatrix = null;
};

THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);

THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.clone = function() {
    var light = new THREE.DirectionalLight();
    THREE.Light.prototype.clone.call(this, light);
    light.target = this.target.clone();
    light.intensity = this.intensity;
    light.castShadow = this.castShadow;
    light.onlyShadow = this.onlyShadow;
    light.shadowCameraNear = this.shadowCameraNear;
    light.shadowCameraFar = this.shadowCameraFar;
    light.shadowCameraLeft = this.shadowCameraLeft;
    light.shadowCameraRight = this.shadowCameraRight;
    light.shadowCameraTop = this.shadowCameraTop;
    light.shadowCameraBottom = this.shadowCameraBottom;
    light.shadowCameraVisible = this.shadowCameraVisible;
    light.shadowBias = this.shadowBias;
    light.shadowDarkness = this.shadowDarkness;
    light.shadowMapWidth = this.shadowMapWidth;
    light.shadowMapHeight = this.shadowMapHeight;
    light.shadowCascade = this.shadowCascade;
    light.shadowCascadeOffset.copy(this.shadowCascadeOffset);
    light.shadowCascadeCount = this.shadowCascadeCount;
    light.shadowCascadeBias = this.shadowCascadeBias.slice(0);
    light.shadowCascadeWidth = this.shadowCascadeWidth.slice(0);
    light.shadowCascadeHeight = this.shadowCascadeHeight.slice(0);
    light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0);
    light.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0);
    return light;
};

THREE.HemisphereLight = function(skyColor, groundColor, intensity) {
    THREE.Light.call(this, skyColor);
    this.type = "HemisphereLight";
    this.position.set(0, 100, 0);
    this.groundColor = new THREE.Color(groundColor);
    this.intensity = intensity !== undefined ? intensity : 1;
};

THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);

THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.clone = function() {
    var light = new THREE.HemisphereLight();
    THREE.Light.prototype.clone.call(this, light);
    light.groundColor.copy(this.groundColor);
    light.intensity = this.intensity;
    return light;
};

THREE.PointLight = function(color, intensity, distance, decay) {
    THREE.Light.call(this, color);
    this.type = "PointLight";
    this.intensity = intensity !== undefined ? intensity : 1;
    this.distance = distance !== undefined ? distance : 0;
    this.decay = decay !== undefined ? decay : 1;
};

THREE.PointLight.prototype = Object.create(THREE.Light.prototype);

THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.clone = function() {
    var light = new THREE.PointLight();
    THREE.Light.prototype.clone.call(this, light);
    light.intensity = this.intensity;
    light.distance = this.distance;
    light.decay = this.decay;
    return light;
};

THREE.SpotLight = function(color, intensity, distance, angle, exponent, decay) {
    THREE.Light.call(this, color);
    this.type = "SpotLight";
    this.position.set(0, 1, 0);
    this.target = new THREE.Object3D();
    this.intensity = intensity !== undefined ? intensity : 1;
    this.distance = distance !== undefined ? distance : 0;
    this.angle = angle !== undefined ? angle : Math.PI / 3;
    this.exponent = exponent !== undefined ? exponent : 10;
    this.decay = decay !== undefined ? decay : 1;
    this.castShadow = false;
    this.onlyShadow = false;
    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5e3;
    this.shadowCameraFov = 50;
    this.shadowCameraVisible = false;
    this.shadowBias = 0;
    this.shadowDarkness = .5;
    this.shadowMapWidth = 512;
    this.shadowMapHeight = 512;
    this.shadowMap = null;
    this.shadowMapSize = null;
    this.shadowCamera = null;
    this.shadowMatrix = null;
};

THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);

THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.clone = function() {
    var light = new THREE.SpotLight();
    THREE.Light.prototype.clone.call(this, light);
    light.target = this.target.clone();
    light.intensity = this.intensity;
    light.distance = this.distance;
    light.angle = this.angle;
    light.exponent = this.exponent;
    light.decay = this.decay;
    light.castShadow = this.castShadow;
    light.onlyShadow = this.onlyShadow;
    light.shadowCameraNear = this.shadowCameraNear;
    light.shadowCameraFar = this.shadowCameraFar;
    light.shadowCameraFov = this.shadowCameraFov;
    light.shadowCameraVisible = this.shadowCameraVisible;
    light.shadowBias = this.shadowBias;
    light.shadowDarkness = this.shadowDarkness;
    light.shadowMapWidth = this.shadowMapWidth;
    light.shadowMapHeight = this.shadowMapHeight;
    return light;
};

THREE.Cache = {
    files: {},
    add: function(key, file) {
        this.files[key] = file;
    },
    get: function(key) {
        return this.files[key];
    },
    remove: function(key) {
        delete this.files[key];
    },
    clear: function() {
        this.files = {};
    }
};

THREE.Loader = function(showStatus) {
    this.showStatus = showStatus;
    this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;
    this.imageLoader = new THREE.ImageLoader();
    this.onLoadStart = function() {};
    this.onLoadProgress = function() {};
    this.onLoadComplete = function() {};
};

THREE.Loader.prototype = {
    constructor: THREE.Loader,
    crossOrigin: undefined,
    addStatusElement: function() {
        var e = document.createElement("div");
        e.style.position = "absolute";
        e.style.right = "0px";
        e.style.top = "0px";
        e.style.fontSize = "0.8em";
        e.style.textAlign = "left";
        e.style.background = "rgba(0,0,0,0.25)";
        e.style.color = "#fff";
        e.style.width = "120px";
        e.style.padding = "0.5em 0.5em 0.5em 0.5em";
        e.style.zIndex = 1e3;
        e.innerHTML = "Loading ...";
        return e;
    },
    updateProgress: function(progress) {
        var message = "Loaded ";
        if (progress.total) {
            message += (100 * progress.loaded / progress.total).toFixed(0) + "%";
        } else {
            message += (progress.loaded / 1024).toFixed(2) + " KB";
        }
        this.statusDomElement.innerHTML = message;
    },
    extractUrlBase: function(url) {
        var parts = url.split("/");
        if (parts.length === 1) return "./";
        parts.pop();
        return parts.join("/") + "/";
    },
    initMaterials: function(materials, texturePath) {
        var array = [];
        for (var i = 0; i < materials.length; ++i) {
            array[i] = this.createMaterial(materials[i], texturePath);
        }
        return array;
    },
    needsTangents: function(materials) {
        for (var i = 0, il = materials.length; i < il; i++) {
            var m = materials[i];
            if (m instanceof THREE.ShaderMaterial) return true;
        }
        return false;
    },
    createMaterial: function(m, texturePath) {
        var scope = this;
        function nearest_pow2(n) {
            var l = Math.log(n) / Math.LN2;
            return Math.pow(2, Math.round(l));
        }
        function create_texture(where, name, sourceFile, repeat, offset, wrap, anisotropy) {
            var fullPath = texturePath + sourceFile;
            var texture;
            var loader = THREE.Loader.Handlers.get(fullPath);
            if (loader !== null) {
                texture = loader.load(fullPath);
            } else {
                texture = new THREE.Texture();
                loader = scope.imageLoader;
                loader.crossOrigin = scope.crossOrigin;
                loader.load(fullPath, function(image) {
                    if (THREE.Math.isPowerOfTwo(image.width) === false || THREE.Math.isPowerOfTwo(image.height) === false) {
                        var width = nearest_pow2(image.width);
                        var height = nearest_pow2(image.height);
                        var canvas = document.createElement("canvas");
                        canvas.width = width;
                        canvas.height = height;
                        var context = canvas.getContext("2d");
                        context.drawImage(image, 0, 0, width, height);
                        texture.image = canvas;
                    } else {
                        texture.image = image;
                    }
                    texture.needsUpdate = true;
                });
            }
            texture.sourceFile = sourceFile;
            if (repeat) {
                texture.repeat.set(repeat[0], repeat[1]);
                if (repeat[0] !== 1) texture.wrapS = THREE.RepeatWrapping;
                if (repeat[1] !== 1) texture.wrapT = THREE.RepeatWrapping;
            }
            if (offset) {
                texture.offset.set(offset[0], offset[1]);
            }
            if (wrap) {
                var wrapMap = {
                    repeat: THREE.RepeatWrapping,
                    mirror: THREE.MirroredRepeatWrapping
                };
                if (wrapMap[wrap[0]] !== undefined) texture.wrapS = wrapMap[wrap[0]];
                if (wrapMap[wrap[1]] !== undefined) texture.wrapT = wrapMap[wrap[1]];
            }
            if (anisotropy) {
                texture.anisotropy = anisotropy;
            }
            where[name] = texture;
        }
        function rgb2hex(rgb) {
            return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;
        }
        var mtype = "MeshLambertMaterial";
        var mpars = {
            color: 15658734,
            opacity: 1,
            map: null,
            lightMap: null,
            normalMap: null,
            bumpMap: null,
            wireframe: false
        };
        if (m.shading) {
            var shading = m.shading.toLowerCase();
            if (shading === "phong") mtype = "MeshPhongMaterial"; else if (shading === "basic") mtype = "MeshBasicMaterial";
        }
        if (m.blending !== undefined && THREE[m.blending] !== undefined) {
            mpars.blending = THREE[m.blending];
        }
        if (m.transparent !== undefined) {
            mpars.transparent = m.transparent;
        }
        if (m.opacity !== undefined && m.opacity < 1) {
            mpars.transparent = true;
        }
        if (m.depthTest !== undefined) {
            mpars.depthTest = m.depthTest;
        }
        if (m.depthWrite !== undefined) {
            mpars.depthWrite = m.depthWrite;
        }
        if (m.visible !== undefined) {
            mpars.visible = m.visible;
        }
        if (m.flipSided !== undefined) {
            mpars.side = THREE.BackSide;
        }
        if (m.doubleSided !== undefined) {
            mpars.side = THREE.DoubleSide;
        }
        if (m.wireframe !== undefined) {
            mpars.wireframe = m.wireframe;
        }
        if (m.vertexColors !== undefined) {
            if (m.vertexColors === "face") {
                mpars.vertexColors = THREE.FaceColors;
            } else if (m.vertexColors) {
                mpars.vertexColors = THREE.VertexColors;
            }
        }
        if (m.colorDiffuse) {
            mpars.color = rgb2hex(m.colorDiffuse);
        } else if (m.DbgColor) {
            mpars.color = m.DbgColor;
        }
        if (m.colorSpecular) {
            mpars.specular = rgb2hex(m.colorSpecular);
        }
        if (m.colorEmissive) {
            mpars.emissive = rgb2hex(m.colorEmissive);
        }
        if (m.transparency !== undefined) {
            console.warn("THREE.Loader: transparency has been renamed to opacity");
            m.opacity = m.transparency;
        }
        if (m.opacity !== undefined) {
            mpars.opacity = m.opacity;
        }
        if (m.specularCoef) {
            mpars.shininess = m.specularCoef;
        }
        if (m.mapDiffuse && texturePath) {
            create_texture(mpars, "map", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
        }
        if (m.mapLight && texturePath) {
            create_texture(mpars, "lightMap", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
        }
        if (m.mapBump && texturePath) {
            create_texture(mpars, "bumpMap", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
        }
        if (m.mapNormal && texturePath) {
            create_texture(mpars, "normalMap", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
        }
        if (m.mapSpecular && texturePath) {
            create_texture(mpars, "specularMap", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
        }
        if (m.mapAlpha && texturePath) {
            create_texture(mpars, "alphaMap", m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
        }
        if (m.mapBumpScale) {
            mpars.bumpScale = m.mapBumpScale;
        }
        if (m.mapNormalFactor) {
            mpars.normalScale = new THREE.Vector2(m.mapNormalFactor, m.mapNormalFactor);
        }
        var material = new THREE[mtype](mpars);
        if (m.DbgName !== undefined) material.name = m.DbgName;
        return material;
    }
};

THREE.Loader.Handlers = {
    handlers: [],
    add: function(regex, loader) {
        this.handlers.push(regex, loader);
    },
    get: function(file) {
        for (var i = 0, l = this.handlers.length; i < l; i += 2) {
            var regex = this.handlers[i];
            var loader = this.handlers[i + 1];
            if (regex.test(file)) {
                return loader;
            }
        }
        return null;
    }
};

THREE.XHRLoader = function(manager) {
    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader,
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var cached = THREE.Cache.get(url);
        if (cached !== undefined) {
            if (onLoad) onLoad(cached);
            return;
        }
        var request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.addEventListener("load", function(event) {
            THREE.Cache.add(url, this.response);
            if (onLoad) onLoad(this.response);
            scope.manager.itemEnd(url);
        }, false);
        if (onProgress !== undefined) {
            request.addEventListener("progress", function(event) {
                onProgress(event);
            }, false);
        }
        if (onError !== undefined) {
            request.addEventListener("error", function(event) {
                onError(event);
            }, false);
        }
        if (this.crossOrigin !== undefined) request.crossOrigin = this.crossOrigin;
        if (this.responseType !== undefined) request.responseType = this.responseType;
        request.send(null);
        scope.manager.itemStart(url);
    },
    setResponseType: function(value) {
        this.responseType = value;
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
    }
};

THREE.ImageLoader = function(manager) {
    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader,
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var cached = THREE.Cache.get(url);
        if (cached !== undefined) {
            onLoad(cached);
            return;
        }
        var image = document.createElement("img");
        image.addEventListener("load", function(event) {
            THREE.Cache.add(url, this);
            if (onLoad) onLoad(this);
            scope.manager.itemEnd(url);
        }, false);
        if (onProgress !== undefined) {
            image.addEventListener("progress", function(event) {
                onProgress(event);
            }, false);
        }
        if (onError !== undefined) {
            image.addEventListener("error", function(event) {
                onError(event);
            }, false);
        }
        if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
        image.src = url;
        scope.manager.itemStart(url);
        return image;
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
    }
};

THREE.JSONLoader = function(showStatus) {
    THREE.Loader.call(this, showStatus);
    this.withCredentials = false;
};

THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);

THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;

THREE.JSONLoader.prototype.load = function(url, callback, texturePath) {
    texturePath = texturePath && typeof texturePath === "string" ? texturePath : this.extractUrlBase(url);
    this.onLoadStart();
    this.loadAjaxJSON(this, url, callback, texturePath);
};

THREE.JSONLoader.prototype.loadAjaxJSON = function(context, url, callback, texturePath, callbackProgress) {
    var xhr = new XMLHttpRequest();
    var length = 0;
    xhr.onreadystatechange = function() {
        if (xhr.readyState === xhr.DONE) {
            if (xhr.status === 200 || xhr.status === 0) {
                if (xhr.responseText) {
                    var json = JSON.parse(xhr.responseText);
                    var metadata = json.metadata;
                    if (metadata !== undefined) {
                        if (metadata.type === "object") {
                            THREE.error("THREE.JSONLoader: " + url + " should be loaded with THREE.ObjectLoader instead.");
                            return;
                        }
                        if (metadata.type === "scene") {
                            THREE.error("THREE.JSONLoader: " + url + " seems to be a Scene. Use THREE.SceneLoader instead.");
                            return;
                        }
                    }
                    var result = context.parse(json, texturePath);
                    callback(result.geometry, result.materials);
                } else {
                    THREE.error("THREE.JSONLoader: " + url + " seems to be unreachable or the file is empty.");
                }
                context.onLoadComplete();
            } else {
                THREE.error("THREE.JSONLoader: Couldn't load " + url + " (" + xhr.status + ")");
            }
        } else if (xhr.readyState === xhr.LOADING) {
            if (callbackProgress) {
                if (length === 0) {
                    length = xhr.getResponseHeader("Content-Length");
                }
                callbackProgress({
                    total: length,
                    loaded: xhr.responseText.length
                });
            }
        } else if (xhr.readyState === xhr.HEADERS_RECEIVED) {
            if (callbackProgress !== undefined) {
                length = xhr.getResponseHeader("Content-Length");
            }
        }
    };
    xhr.open("GET", url, true);
    xhr.withCredentials = this.withCredentials;
    xhr.send(null);
};

THREE.JSONLoader.prototype.parse = function(json, texturePath) {
    var geometry = new THREE.Geometry(), scale = json.scale !== undefined ? 1 / json.scale : 1;
    parseModel(scale);
    parseSkin();
    parseMorphing(scale);
    geometry.computeFaceNormals();
    geometry.computeBoundingSphere();
    function parseModel(scale) {
        function isBitSet(value, position) {
            return value & 1 << position;
        }
        var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
        if (json.uvs !== undefined) {
            for (i = 0; i < json.uvs.length; i++) {
                if (json.uvs[i].length) nUvLayers++;
            }
            for (i = 0; i < nUvLayers; i++) {
                geometry.faceVertexUvs[i] = [];
            }
        }
        offset = 0;
        zLength = vertices.length;
        while (offset < zLength) {
            vertex = new THREE.Vector3();
            vertex.x = vertices[offset++] * scale;
            vertex.y = vertices[offset++] * scale;
            vertex.z = vertices[offset++] * scale;
            geometry.vertices.push(vertex);
        }
        offset = 0;
        zLength = faces.length;
        while (offset < zLength) {
            type = faces[offset++];
            isQuad = isBitSet(type, 0);
            hasMaterial = isBitSet(type, 1);
            hasFaceVertexUv = isBitSet(type, 3);
            hasFaceNormal = isBitSet(type, 4);
            hasFaceVertexNormal = isBitSet(type, 5);
            hasFaceColor = isBitSet(type, 6);
            hasFaceVertexColor = isBitSet(type, 7);
            if (isQuad) {
                faceA = new THREE.Face3();
                faceA.a = faces[offset];
                faceA.b = faces[offset + 1];
                faceA.c = faces[offset + 3];
                faceB = new THREE.Face3();
                faceB.a = faces[offset + 1];
                faceB.b = faces[offset + 2];
                faceB.c = faces[offset + 3];
                offset += 4;
                if (hasMaterial) {
                    materialIndex = faces[offset++];
                    faceA.materialIndex = materialIndex;
                    faceB.materialIndex = materialIndex;
                }
                fi = geometry.faces.length;
                if (hasFaceVertexUv) {
                    for (i = 0; i < nUvLayers; i++) {
                        uvLayer = json.uvs[i];
                        geometry.faceVertexUvs[i][fi] = [];
                        geometry.faceVertexUvs[i][fi + 1] = [];
                        for (j = 0; j < 4; j++) {
                            uvIndex = faces[offset++];
                            u = uvLayer[uvIndex * 2];
                            v = uvLayer[uvIndex * 2 + 1];
                            uv = new THREE.Vector2(u, v);
                            if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);
                            if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);
                        }
                    }
                }
                if (hasFaceNormal) {
                    normalIndex = faces[offset++] * 3;
                    faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                    faceB.normal.copy(faceA.normal);
                }
                if (hasFaceVertexNormal) {
                    for (i = 0; i < 4; i++) {
                        normalIndex = faces[offset++] * 3;
                        normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                        if (i !== 2) faceA.vertexNormals.push(normal);
                        if (i !== 0) faceB.vertexNormals.push(normal);
                    }
                }
                if (hasFaceColor) {
                    colorIndex = faces[offset++];
                    hex = colors[colorIndex];
                    faceA.color.setHex(hex);
                    faceB.color.setHex(hex);
                }
                if (hasFaceVertexColor) {
                    for (i = 0; i < 4; i++) {
                        colorIndex = faces[offset++];
                        hex = colors[colorIndex];
                        if (i !== 2) faceA.vertexColors.push(new THREE.Color(hex));
                        if (i !== 0) faceB.vertexColors.push(new THREE.Color(hex));
                    }
                }
                geometry.faces.push(faceA);
                geometry.faces.push(faceB);
            } else {
                face = new THREE.Face3();
                face.a = faces[offset++];
                face.b = faces[offset++];
                face.c = faces[offset++];
                if (hasMaterial) {
                    materialIndex = faces[offset++];
                    face.materialIndex = materialIndex;
                }
                fi = geometry.faces.length;
                if (hasFaceVertexUv) {
                    for (i = 0; i < nUvLayers; i++) {
                        uvLayer = json.uvs[i];
                        geometry.faceVertexUvs[i][fi] = [];
                        for (j = 0; j < 3; j++) {
                            uvIndex = faces[offset++];
                            u = uvLayer[uvIndex * 2];
                            v = uvLayer[uvIndex * 2 + 1];
                            uv = new THREE.Vector2(u, v);
                            geometry.faceVertexUvs[i][fi].push(uv);
                        }
                    }
                }
                if (hasFaceNormal) {
                    normalIndex = faces[offset++] * 3;
                    face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                }
                if (hasFaceVertexNormal) {
                    for (i = 0; i < 3; i++) {
                        normalIndex = faces[offset++] * 3;
                        normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                        face.vertexNormals.push(normal);
                    }
                }
                if (hasFaceColor) {
                    colorIndex = faces[offset++];
                    face.color.setHex(colors[colorIndex]);
                }
                if (hasFaceVertexColor) {
                    for (i = 0; i < 3; i++) {
                        colorIndex = faces[offset++];
                        face.vertexColors.push(new THREE.Color(colors[colorIndex]));
                    }
                }
                geometry.faces.push(face);
            }
        }
    }
    function parseSkin() {
        var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;
        if (json.skinWeights) {
            for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                var x = json.skinWeights[i];
                var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
                var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
                var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
                geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
            }
        }
        if (json.skinIndices) {
            for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                var a = json.skinIndices[i];
                var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
                var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
                var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
                geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
            }
        }
        geometry.bones = json.bones;
        if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
            THREE.warn("THREE.JSONLoader: When skinning, number of vertices (" + geometry.vertices.length + "), skinIndices (" + geometry.skinIndices.length + "), and skinWeights (" + geometry.skinWeights.length + ") should match.");
        }
        geometry.animation = json.animation;
        geometry.animations = json.animations;
    }
    function parseMorphing(scale) {
        if (json.morphTargets !== undefined) {
            var i, l, v, vl, dstVertices, srcVertices;
            for (i = 0, l = json.morphTargets.length; i < l; i++) {
                geometry.morphTargets[i] = {};
                geometry.morphTargets[i].name = json.morphTargets[i].name;
                geometry.morphTargets[i].vertices = [];
                dstVertices = geometry.morphTargets[i].vertices;
                srcVertices = json.morphTargets[i].vertices;
                for (v = 0, vl = srcVertices.length; v < vl; v += 3) {
                    var vertex = new THREE.Vector3();
                    vertex.x = srcVertices[v] * scale;
                    vertex.y = srcVertices[v + 1] * scale;
                    vertex.z = srcVertices[v + 2] * scale;
                    dstVertices.push(vertex);
                }
            }
        }
        if (json.morphColors !== undefined) {
            var i, l, c, cl, dstColors, srcColors, color;
            for (i = 0, l = json.morphColors.length; i < l; i++) {
                geometry.morphColors[i] = {};
                geometry.morphColors[i].name = json.morphColors[i].name;
                geometry.morphColors[i].colors = [];
                dstColors = geometry.morphColors[i].colors;
                srcColors = json.morphColors[i].colors;
                for (c = 0, cl = srcColors.length; c < cl; c += 3) {
                    color = new THREE.Color(16755200);
                    color.setRGB(srcColors[c], srcColors[c + 1], srcColors[c + 2]);
                    dstColors.push(color);
                }
            }
        }
    }
    if (json.materials === undefined || json.materials.length === 0) {
        return {
            geometry: geometry
        };
    } else {
        var materials = this.initMaterials(json.materials, texturePath);
        if (this.needsTangents(materials)) {
            geometry.computeTangents();
        }
        return {
            geometry: geometry,
            materials: materials
        };
    }
};

THREE.LoadingManager = function(onLoad, onProgress, onError) {
    var scope = this;
    var loaded = 0, total = 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
        total++;
    };
    this.itemEnd = function(url) {
        loaded++;
        if (scope.onProgress !== undefined) {
            scope.onProgress(url, loaded, total);
        }
        if (loaded === total && scope.onLoad !== undefined) {
            scope.onLoad();
        }
    };
};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

THREE.BufferGeometryLoader = function(manager) {
    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

THREE.BufferGeometryLoader.prototype = {
    constructor: THREE.BufferGeometryLoader,
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
            onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
    },
    parse: function(json) {
        var geometry = new THREE.BufferGeometry();
        var attributes = json.data.attributes;
        for (var key in attributes) {
            var attribute = attributes[key];
            var typedArray = new self[attribute.type](attribute.array);
            geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize));
        }
        var offsets = json.data.offsets;
        if (offsets !== undefined) {
            geometry.offsets = JSON.parse(JSON.stringify(offsets));
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
            var center = new THREE.Vector3();
            if (boundingSphere.center !== undefined) {
                center.fromArray(boundingSphere.center);
            }
            geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);
        }
        return geometry;
    }
};

THREE.MaterialLoader = function(manager) {
    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

THREE.MaterialLoader.prototype = {
    constructor: THREE.MaterialLoader,
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
            onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
    },
    parse: function(json) {
        var material = new THREE[json.type]();
        if (json.color !== undefined) material.color.setHex(json.color);
        if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
        if (json.specular !== undefined) material.specular.setHex(json.specular);
        if (json.shininess !== undefined) material.shininess = json.shininess;
        if (json.uniforms !== undefined) material.uniforms = json.uniforms;
        if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
        if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
        if (json.shading !== undefined) material.shading = json.shading;
        if (json.blending !== undefined) material.blending = json.blending;
        if (json.side !== undefined) material.side = json.side;
        if (json.opacity !== undefined) material.opacity = json.opacity;
        if (json.transparent !== undefined) material.transparent = json.transparent;
        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
        if (json.size !== undefined) material.size = json.size;
        if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
        if (json.materials !== undefined) {
            for (var i = 0, l = json.materials.length; i < l; i++) {
                material.materials.push(this.parse(json.materials[i]));
            }
        }
        return material;
    }
};

THREE.ObjectLoader = function(manager) {
    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
    this.texturePath = "";
};

THREE.ObjectLoader.prototype = {
    constructor: THREE.ObjectLoader,
    load: function(url, onLoad, onProgress, onError) {
        if (this.texturePath === "") {
            this.texturePath = url.substring(0, url.lastIndexOf("/") + 1);
        }
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
            scope.parse(JSON.parse(text), onLoad);
        }, onProgress, onError);
    },
    setTexturePath: function(value) {
        this.texturePath = value;
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
    },
    parse: function(json, onLoad) {
        var geometries = this.parseGeometries(json.geometries);
        var images = this.parseImages(json.images, function() {
            if (onLoad !== undefined) onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials);
        if (json.images === undefined || json.images.length === 0) {
            if (onLoad !== undefined) onLoad(object);
        }
        return object;
    },
    parseGeometries: function(json) {
        var geometries = {};
        if (json !== undefined) {
            var geometryLoader = new THREE.JSONLoader();
            var bufferGeometryLoader = new THREE.BufferGeometryLoader();
            for (var i = 0, l = json.length; i < l; i++) {
                var geometry;
                var data = json[i];
                switch (data.type) {
                  case "PlaneGeometry":
                  case "PlaneBufferGeometry":
                    geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                    break;

                  case "BoxGeometry":
                  case "CubeGeometry":
                    geometry = new THREE.BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                    break;

                  case "CircleGeometry":
                    geometry = new THREE.CircleGeometry(data.radius, data.segments);
                    break;

                  case "CylinderGeometry":
                    geometry = new THREE.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded);
                    break;

                  case "SphereGeometry":
                    geometry = new THREE.SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                    break;

                  case "IcosahedronGeometry":
                    geometry = new THREE.IcosahedronGeometry(data.radius, data.detail);
                    break;

                  case "TorusGeometry":
                    geometry = new THREE.TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                    break;

                  case "TorusKnotGeometry":
                    geometry = new THREE.TorusKnotGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.p, data.q, data.heightScale);
                    break;

                  case "BufferGeometry":
                    geometry = bufferGeometryLoader.parse(data);
                    break;

                  case "Geometry":
                    geometry = geometryLoader.parse(data.data).geometry;
                    break;
                }
                geometry.uuid = data.uuid;
                if (data.name !== undefined) geometry.name = data.name;
                geometries[data.uuid] = geometry;
            }
        }
        return geometries;
    },
    parseMaterials: function(json, textures) {
        var materials = {};
        if (json !== undefined) {
            var getTexture = function(name) {
                if (textures[name] === undefined) {
                    THREE.warn("THREE.ObjectLoader: Undefined texture", name);
                }
                return textures[name];
            };
            var loader = new THREE.MaterialLoader();
            for (var i = 0, l = json.length; i < l; i++) {
                var data = json[i];
                var material = loader.parse(data);
                material.uuid = data.uuid;
                if (data.name !== undefined) material.name = data.name;
                if (data.map !== undefined) {
                    material.map = getTexture(data.map);
                }
                if (data.bumpMap !== undefined) {
                    material.bumpMap = getTexture(data.bumpMap);
                    if (data.bumpScale) {
                        material.bumpScale = new THREE.Vector2(data.bumpScale, data.bumpScale);
                    }
                }
                if (data.alphaMap !== undefined) {
                    material.alphaMap = getTexture(data.alphaMap);
                }
                if (data.envMap !== undefined) {
                    material.envMap = getTexture(data.envMap);
                }
                if (data.normalMap !== undefined) {
                    material.normalMap = getTexture(data.normalMap);
                    if (data.normalScale) {
                        material.normalScale = new THREE.Vector2(data.normalScale, data.normalScale);
                    }
                }
                if (data.lightMap !== undefined) {
                    material.lightMap = getTexture(data.lightMap);
                }
                if (data.specularMap !== undefined) {
                    material.specularMap = getTexture(data.specularMap);
                }
                materials[data.uuid] = material;
            }
        }
        return materials;
    },
    parseImages: function(json, onLoad) {
        var scope = this;
        var images = {};
        if (json !== undefined && json.length > 0) {
            var manager = new THREE.LoadingManager(onLoad);
            var loader = new THREE.ImageLoader(manager);
            loader.setCrossOrigin(this.crossOrigin);
            var loadImage = function(url) {
                scope.manager.itemStart(url);
                return loader.load(url, function() {
                    scope.manager.itemEnd(url);
                });
            };
            for (var i = 0, l = json.length; i < l; i++) {
                var image = json[i];
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                images[image.uuid] = loadImage(path);
            }
        }
        return images;
    },
    parseTextures: function(json, images) {
        var textures = {};
        if (json !== undefined) {
            for (var i = 0, l = json.length; i < l; i++) {
                var data = json[i];
                if (data.image === undefined) {
                    THREE.warn('THREE.ObjectLoader: No "image" speficied for', data.uuid);
                }
                if (images[data.image] === undefined) {
                    THREE.warn("THREE.ObjectLoader: Undefined image", data.image);
                }
                var texture = new THREE.Texture(images[data.image]);
                texture.needsUpdate = true;
                texture.uuid = data.uuid;
                if (data.name !== undefined) texture.name = data.name;
                if (data.repeat !== undefined) texture.repeat = new THREE.Vector2(data.repeat[0], data.repeat[1]);
                if (data.minFilter !== undefined) texture.minFilter = THREE[data.minFilter];
                if (data.magFilter !== undefined) texture.magFilter = THREE[data.magFilter];
                if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
                if (data.wrap instanceof Array) {
                    texture.wrapS = THREE[data.wrap[0]];
                    texture.wrapT = THREE[data.wrap[1]];
                }
                textures[data.uuid] = texture;
            }
        }
        return textures;
    },
    parseObject: function() {
        var matrix = new THREE.Matrix4();
        return function(data, geometries, materials) {
            var object;
            var getGeometry = function(name) {
                if (geometries[name] === undefined) {
                    THREE.warn("THREE.ObjectLoader: Undefined geometry", name);
                }
                return geometries[name];
            };
            var getMaterial = function(name) {
                if (materials[name] === undefined) {
                    THREE.warn("THREE.ObjectLoader: Undefined material", name);
                }
                return materials[name];
            };
            switch (data.type) {
              case "Scene":
                object = new THREE.Scene();
                break;

              case "PerspectiveCamera":
                object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                break;

              case "OrthographicCamera":
                object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                break;

              case "AmbientLight":
                object = new THREE.AmbientLight(data.color);
                break;

              case "DirectionalLight":
                object = new THREE.DirectionalLight(data.color, data.intensity);
                break;

              case "PointLight":
                object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);
                break;

              case "SpotLight":
                object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay);
                break;

              case "HemisphereLight":
                object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
                break;

              case "Mesh":
                object = new THREE.Mesh(getGeometry(data.geometry), getMaterial(data.material));
                break;

              case "Line":
                object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                break;

              case "PointCloud":
                object = new THREE.PointCloud(getGeometry(data.geometry), getMaterial(data.material));
                break;

              case "Sprite":
                object = new THREE.Sprite(getMaterial(data.material));
                break;

              case "Group":
                object = new THREE.Group();
                break;

              default:
                object = new THREE.Object3D();
            }
            object.uuid = data.uuid;
            if (data.name !== undefined) object.name = data.name;
            if (data.matrix !== undefined) {
                matrix.fromArray(data.matrix);
                matrix.decompose(object.position, object.quaternion, object.scale);
            } else {
                if (data.position !== undefined) object.position.fromArray(data.position);
                if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
                if (data.scale !== undefined) object.scale.fromArray(data.scale);
            }
            if (data.visible !== undefined) object.visible = data.visible;
            if (data.userData !== undefined) object.userData = data.userData;
            if (data.children !== undefined) {
                for (var child in data.children) {
                    object.add(this.parseObject(data.children[child], geometries, materials));
                }
            }
            return object;
        };
    }()
};

THREE.TextureLoader = function(manager) {
    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.ImageLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(image) {
            var texture = new THREE.Texture(image);
            texture.needsUpdate = true;
            if (onLoad !== undefined) {
                onLoad(texture);
            }
        }, onProgress, onError);
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
    }
};

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function() {
    this._parser = null;
};

THREE.BinaryTextureLoader.prototype = {
    constructor: THREE.BinaryTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new THREE.DataTexture();
        var loader = new THREE.XHRLoader();
        loader.setResponseType("arraybuffer");
        loader.load(url, function(buffer) {
            var texData = scope._parser(buffer);
            if (!texData) return;
            if (undefined !== texData.image) {
                texture.image = texData.image;
            } else if (undefined !== texData.data) {
                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;
            }
            texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
            texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
            texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
            texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
            texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
            if (undefined !== texData.format) {
                texture.format = texData.format;
            }
            if (undefined !== texData.type) {
                texture.type = texData.type;
            }
            if (undefined !== texData.mipmaps) {
                texture.mipmaps = texData.mipmaps;
            }
            if (1 === texData.mipmapCount) {
                texture.minFilter = THREE.LinearFilter;
            }
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
    }
};

THREE.CompressedTextureLoader = function() {
    this._parser = null;
};

THREE.CompressedTextureLoader.prototype = {
    constructor: THREE.CompressedTextureLoader,
    load: function(url, onLoad, onError) {
        var scope = this;
        var images = [];
        var texture = new THREE.CompressedTexture();
        texture.image = images;
        var loader = new THREE.XHRLoader();
        loader.setResponseType("arraybuffer");
        if (url instanceof Array) {
            var loaded = 0;
            var loadTexture = function(i) {
                loader.load(url[i], function(buffer) {
                    var texDatas = scope._parser(buffer, true);
                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };
                    loaded += 1;
                    if (loaded === 6) {
                        if (texDatas.mipmapCount == 1) texture.minFilter = THREE.LinearFilter;
                        texture.format = texDatas.format;
                        texture.needsUpdate = true;
                        if (onLoad) onLoad(texture);
                    }
                });
            };
            for (var i = 0, il = url.length; i < il; ++i) {
                loadTexture(i);
            }
        } else {
            loader.load(url, function(buffer) {
                var texDatas = scope._parser(buffer, true);
                if (texDatas.isCubemap) {
                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                    for (var f = 0; f < faces; f++) {
                        images[f] = {
                            mipmaps: []
                        };
                        for (var i = 0; i < texDatas.mipmapCount; i++) {
                            images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                            images[f].format = texDatas.format;
                            images[f].width = texDatas.width;
                            images[f].height = texDatas.height;
                        }
                    }
                } else {
                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;
                }
                if (texDatas.mipmapCount === 1) {
                    texture.minFilter = THREE.LinearFilter;
                }
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad) onLoad(texture);
            });
        }
        return texture;
    }
};

THREE.Material = function() {
    Object.defineProperty(this, "id", {
        value: THREE.MaterialIdCount++
    });
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.type = "Material";
    this.side = THREE.FrontSide;
    this.opacity = 1;
    this.transparent = false;
    this.blending = THREE.NormalBlending;
    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthTest = true;
    this.depthWrite = true;
    this.colorWrite = true;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.alphaTest = 0;
    this.overdraw = 0;
    this.visible = true;
    this._needsUpdate = true;
};

THREE.Material.prototype = {
    constructor: THREE.Material,
    get needsUpdate() {
        return this._needsUpdate;
    },
    set needsUpdate(value) {
        if (value === true) this.update();
        this._needsUpdate = value;
    },
    setValues: function(values) {
        if (values === undefined) return;
        for (var key in values) {
            var newValue = values[key];
            if (newValue === undefined) {
                THREE.warn("THREE.Material: '" + key + "' parameter is undefined.");
                continue;
            }
            if (key in this) {
                var currentValue = this[key];
                if (currentValue instanceof THREE.Color) {
                    currentValue.set(newValue);
                } else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {
                    currentValue.copy(newValue);
                } else if (key == "overdraw") {
                    this[key] = Number(newValue);
                } else {
                    this[key] = newValue;
                }
            }
        }
    },
    toJSON: function() {
        var output = {
            metadata: {
                version: 4.2,
                type: "material",
                generator: "MaterialExporter"
            },
            uuid: this.uuid,
            type: this.type
        };
        if (this.name !== "") output.name = this.name;
        if (this instanceof THREE.MeshBasicMaterial) {
            output.color = this.color.getHex();
            if (this.vertexColors !== THREE.NoColors) output.vertexColors = this.vertexColors;
            if (this.blending !== THREE.NormalBlending) output.blending = this.blending;
            if (this.side !== THREE.FrontSide) output.side = this.side;
        } else if (this instanceof THREE.MeshLambertMaterial) {
            output.color = this.color.getHex();
            output.emissive = this.emissive.getHex();
            if (this.vertexColors !== THREE.NoColors) output.vertexColors = this.vertexColors;
            if (this.shading !== THREE.SmoothShading) output.shading = this.shading;
            if (this.blending !== THREE.NormalBlending) output.blending = this.blending;
            if (this.side !== THREE.FrontSide) output.side = this.side;
        } else if (this instanceof THREE.MeshPhongMaterial) {
            output.color = this.color.getHex();
            output.emissive = this.emissive.getHex();
            output.specular = this.specular.getHex();
            output.shininess = this.shininess;
            if (this.vertexColors !== THREE.NoColors) output.vertexColors = this.vertexColors;
            if (this.shading !== THREE.SmoothShading) output.shading = this.shading;
            if (this.blending !== THREE.NormalBlending) output.blending = this.blending;
            if (this.side !== THREE.FrontSide) output.side = this.side;
        } else if (this instanceof THREE.MeshNormalMaterial) {
            if (this.blending !== THREE.NormalBlending) output.blending = this.blending;
            if (this.side !== THREE.FrontSide) output.side = this.side;
        } else if (this instanceof THREE.MeshDepthMaterial) {
            if (this.blending !== THREE.NormalBlending) output.blending = this.blending;
            if (this.side !== THREE.FrontSide) output.side = this.side;
        } else if (this instanceof THREE.PointCloudMaterial) {
            output.size = this.size;
            output.sizeAttenuation = this.sizeAttenuation;
            output.color = this.color.getHex();
            if (this.vertexColors !== THREE.NoColors) output.vertexColors = this.vertexColors;
            if (this.blending !== THREE.NormalBlending) output.blending = this.blending;
        } else if (this instanceof THREE.ShaderMaterial) {
            output.uniforms = this.uniforms;
            output.vertexShader = this.vertexShader;
            output.fragmentShader = this.fragmentShader;
        } else if (this instanceof THREE.SpriteMaterial) {
            output.color = this.color.getHex();
        }
        if (this.opacity < 1) output.opacity = this.opacity;
        if (this.transparent !== false) output.transparent = this.transparent;
        if (this.wireframe !== false) output.wireframe = this.wireframe;
        return output;
    },
    clone: function(material) {
        if (material === undefined) material = new THREE.Material();
        material.name = this.name;
        material.side = this.side;
        material.opacity = this.opacity;
        material.transparent = this.transparent;
        material.blending = this.blending;
        material.blendSrc = this.blendSrc;
        material.blendDst = this.blendDst;
        material.blendEquation = this.blendEquation;
        material.blendSrcAlpha = this.blendSrcAlpha;
        material.blendDstAlpha = this.blendDstAlpha;
        material.blendEquationAlpha = this.blendEquationAlpha;
        material.depthTest = this.depthTest;
        material.depthWrite = this.depthWrite;
        material.polygonOffset = this.polygonOffset;
        material.polygonOffsetFactor = this.polygonOffsetFactor;
        material.polygonOffsetUnits = this.polygonOffsetUnits;
        material.alphaTest = this.alphaTest;
        material.overdraw = this.overdraw;
        material.visible = this.visible;
        return material;
    },
    update: function() {
        this.dispatchEvent({
            type: "update"
        });
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
};

THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);

THREE.MaterialIdCount = 0;

THREE.LineBasicMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = "LineBasicMaterial";
    this.color = new THREE.Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.vertexColors = THREE.NoColors;
    this.fog = true;
    this.setValues(parameters);
};

THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);

THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.clone = function() {
    var material = new THREE.LineBasicMaterial();
    THREE.Material.prototype.clone.call(this, material);
    material.color.copy(this.color);
    material.linewidth = this.linewidth;
    material.linecap = this.linecap;
    material.linejoin = this.linejoin;
    material.vertexColors = this.vertexColors;
    material.fog = this.fog;
    return material;
};

THREE.LineDashedMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = "LineDashedMaterial";
    this.color = new THREE.Color(16777215);
    this.linewidth = 1;
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.vertexColors = false;
    this.fog = true;
    this.setValues(parameters);
};

THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);

THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.clone = function() {
    var material = new THREE.LineDashedMaterial();
    THREE.Material.prototype.clone.call(this, material);
    material.color.copy(this.color);
    material.linewidth = this.linewidth;
    material.scale = this.scale;
    material.dashSize = this.dashSize;
    material.gapSize = this.gapSize;
    material.vertexColors = this.vertexColors;
    material.fog = this.fog;
    return material;
};

THREE.MeshBasicMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new THREE.Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.fog = true;
    this.shading = THREE.SmoothShading;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.vertexColors = THREE.NoColors;
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
};

THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);

THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.clone = function() {
    var material = new THREE.MeshBasicMaterial();
    THREE.Material.prototype.clone.call(this, material);
    material.color.copy(this.color);
    material.map = this.map;
    material.lightMap = this.lightMap;
    material.specularMap = this.specularMap;
    material.alphaMap = this.alphaMap;
    material.envMap = this.envMap;
    material.combine = this.combine;
    material.reflectivity = this.reflectivity;
    material.refractionRatio = this.refractionRatio;
    material.fog = this.fog;
    material.shading = this.shading;
    material.wireframe = this.wireframe;
    material.wireframeLinewidth = this.wireframeLinewidth;
    material.wireframeLinecap = this.wireframeLinecap;
    material.wireframeLinejoin = this.wireframeLinejoin;
    material.vertexColors = this.vertexColors;
    material.skinning = this.skinning;
    material.morphTargets = this.morphTargets;
    return material;
};

THREE.MeshLambertMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new THREE.Color(16777215);
    this.emissive = new THREE.Color(0);
    this.wrapAround = false;
    this.wrapRGB = new THREE.Vector3(1, 1, 1);
    this.map = null;
    this.lightMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.fog = true;
    this.shading = THREE.SmoothShading;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.vertexColors = THREE.NoColors;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
};

THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);

THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.clone = function() {
    var material = new THREE.MeshLambertMaterial();
    THREE.Material.prototype.clone.call(this, material);
    material.color.copy(this.color);
    material.emissive.copy(this.emissive);
    material.wrapAround = this.wrapAround;
    material.wrapRGB.copy(this.wrapRGB);
    material.map = this.map;
    material.lightMap = this.lightMap;
    material.specularMap = this.specularMap;
    material.alphaMap = this.alphaMap;
    material.envMap = this.envMap;
    material.combine = this.combine;
    material.reflectivity = this.reflectivity;
    material.refractionRatio = this.refractionRatio;
    material.fog = this.fog;
    material.shading = this.shading;
    material.wireframe = this.wireframe;
    material.wireframeLinewidth = this.wireframeLinewidth;
    material.wireframeLinecap = this.wireframeLinecap;
    material.wireframeLinejoin = this.wireframeLinejoin;
    material.vertexColors = this.vertexColors;
    material.skinning = this.skinning;
    material.morphTargets = this.morphTargets;
    material.morphNormals = this.morphNormals;
    return material;
};

THREE.MeshPhongMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new THREE.Color(16777215);
    this.emissive = new THREE.Color(0);
    this.specular = new THREE.Color(1118481);
    this.shininess = 30;
    this.metal = false;
    this.wrapAround = false;
    this.wrapRGB = new THREE.Vector3(1, 1, 1);
    this.map = null;
    this.lightMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalScale = new THREE.Vector2(1, 1);
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.fog = true;
    this.shading = THREE.SmoothShading;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.vertexColors = THREE.NoColors;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
};

THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);

THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.clone = function() {
    var material = new THREE.MeshPhongMaterial();
    THREE.Material.prototype.clone.call(this, material);
    material.color.copy(this.color);
    material.emissive.copy(this.emissive);
    material.specular.copy(this.specular);
    material.shininess = this.shininess;
    material.metal = this.metal;
    material.wrapAround = this.wrapAround;
    material.wrapRGB.copy(this.wrapRGB);
    material.map = this.map;
    material.lightMap = this.lightMap;
    material.bumpMap = this.bumpMap;
    material.bumpScale = this.bumpScale;
    material.normalMap = this.normalMap;
    material.normalScale.copy(this.normalScale);
    material.specularMap = this.specularMap;
    material.alphaMap = this.alphaMap;
    material.envMap = this.envMap;
    material.combine = this.combine;
    material.reflectivity = this.reflectivity;
    material.refractionRatio = this.refractionRatio;
    material.fog = this.fog;
    material.shading = this.shading;
    material.wireframe = this.wireframe;
    material.wireframeLinewidth = this.wireframeLinewidth;
    material.wireframeLinecap = this.wireframeLinecap;
    material.wireframeLinejoin = this.wireframeLinejoin;
    material.vertexColors = this.vertexColors;
    material.skinning = this.skinning;
    material.morphTargets = this.morphTargets;
    material.morphNormals = this.morphNormals;
    return material;
};

THREE.MeshDepthMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = "MeshDepthMaterial";
    this.morphTargets = false;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
};

THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);

THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.clone = function() {
    var material = new THREE.MeshDepthMaterial();
    THREE.Material.prototype.clone.call(this, material);
    material.wireframe = this.wireframe;
    material.wireframeLinewidth = this.wireframeLinewidth;
    return material;
};

THREE.MeshNormalMaterial = function(parameters) {
    THREE.Material.call(this, parameters);
    this.type = "MeshNormalMaterial";
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.morphTargets = false;
    this.setValues(parameters);
};

THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);

THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.clone = function() {
    var material = new THREE.MeshNormalMaterial();
    THREE.Material.prototype.clone.call(this, material);
    material.wireframe = this.wireframe;
    material.wireframeLinewidth = this.wireframeLinewidth;
    return material;
};

THREE.MeshFaceMaterial = function(materials) {
    this.uuid = THREE.Math.generateUUID();
    this.type = "MeshFaceMaterial";
    this.materials = materials instanceof Array ? materials : [];
};

THREE.MeshFaceMaterial.prototype = {
    constructor: THREE.MeshFaceMaterial,
    toJSON: function() {
        var output = {
            metadata: {
                version: 4.2,
                type: "material",
                generator: "MaterialExporter"
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        };
        for (var i = 0, l = this.materials.length; i < l; i++) {
            output.materials.push(this.materials[i].toJSON());
        }
        return output;
    },
    clone: function() {
        var material = new THREE.MeshFaceMaterial();
        for (var i = 0; i < this.materials.length; i++) {
            material.materials.push(this.materials[i].clone());
        }
        return material;
    }
};

THREE.PointCloudMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = "PointCloudMaterial";
    this.color = new THREE.Color(16777215);
    this.map = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.vertexColors = THREE.NoColors;
    this.fog = true;
    this.setValues(parameters);
};

THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype);

THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;

THREE.PointCloudMaterial.prototype.clone = function() {
    var material = new THREE.PointCloudMaterial();
    THREE.Material.prototype.clone.call(this, material);
    material.color.copy(this.color);
    material.map = this.map;
    material.size = this.size;
    material.sizeAttenuation = this.sizeAttenuation;
    material.vertexColors = this.vertexColors;
    material.fog = this.fog;
    return material;
};

THREE.ParticleBasicMaterial = function(parameters) {
    THREE.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.");
    return new THREE.PointCloudMaterial(parameters);
};

THREE.ParticleSystemMaterial = function(parameters) {
    THREE.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.");
    return new THREE.PointCloudMaterial(parameters);
};

THREE.ShaderMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.attributes = null;
    this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    this.shading = THREE.SmoothShading;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.vertexColors = THREE.NoColors;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.defaultAttributeValues = {
        color: [ 1, 1, 1 ],
        uv: [ 0, 0 ],
        uv2: [ 0, 0 ]
    };
    this.index0AttributeName = undefined;
    this.setValues(parameters);
};

THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);

THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.clone = function() {
    var material = new THREE.ShaderMaterial();
    THREE.Material.prototype.clone.call(this, material);
    material.fragmentShader = this.fragmentShader;
    material.vertexShader = this.vertexShader;
    material.uniforms = THREE.UniformsUtils.clone(this.uniforms);
    material.attributes = this.attributes;
    material.defines = this.defines;
    material.shading = this.shading;
    material.wireframe = this.wireframe;
    material.wireframeLinewidth = this.wireframeLinewidth;
    material.fog = this.fog;
    material.lights = this.lights;
    material.vertexColors = this.vertexColors;
    material.skinning = this.skinning;
    material.morphTargets = this.morphTargets;
    material.morphNormals = this.morphNormals;
    return material;
};

THREE.RawShaderMaterial = function(parameters) {
    THREE.ShaderMaterial.call(this, parameters);
    this.type = "RawShaderMaterial";
};

THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);

THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;

THREE.RawShaderMaterial.prototype.clone = function() {
    var material = new THREE.RawShaderMaterial();
    THREE.ShaderMaterial.prototype.clone.call(this, material);
    return material;
};

THREE.SpriteMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = "SpriteMaterial";
    this.color = new THREE.Color(16777215);
    this.map = null;
    this.rotation = 0;
    this.fog = false;
    this.setValues(parameters);
};

THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);

THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.clone = function() {
    var material = new THREE.SpriteMaterial();
    THREE.Material.prototype.clone.call(this, material);
    material.color.copy(this.color);
    material.map = this.map;
    material.rotation = this.rotation;
    material.fog = this.fog;
    return material;
};

THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Object.defineProperty(this, "id", {
        value: THREE.TextureIdCount++
    });
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.sourceFile = "";
    this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
    this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
    this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
    this.format = format !== undefined ? format : THREE.RGBAFormat;
    this.type = type !== undefined ? type : THREE.UnsignedByteType;
    this.offset = new THREE.Vector2(0, 0);
    this.repeat = new THREE.Vector2(1, 1);
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this._needsUpdate = false;
    this.onUpdate = null;
};

THREE.Texture.DEFAULT_IMAGE = undefined;

THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {
    constructor: THREE.Texture,
    get needsUpdate() {
        return this._needsUpdate;
    },
    set needsUpdate(value) {
        if (value === true) this.update();
        this._needsUpdate = value;
    },
    clone: function(texture) {
        if (texture === undefined) texture = new THREE.Texture();
        texture.image = this.image;
        texture.mipmaps = this.mipmaps.slice(0);
        texture.mapping = this.mapping;
        texture.wrapS = this.wrapS;
        texture.wrapT = this.wrapT;
        texture.magFilter = this.magFilter;
        texture.minFilter = this.minFilter;
        texture.anisotropy = this.anisotropy;
        texture.format = this.format;
        texture.type = this.type;
        texture.offset.copy(this.offset);
        texture.repeat.copy(this.repeat);
        texture.generateMipmaps = this.generateMipmaps;
        texture.premultiplyAlpha = this.premultiplyAlpha;
        texture.flipY = this.flipY;
        texture.unpackAlignment = this.unpackAlignment;
        return texture;
    },
    update: function() {
        this.dispatchEvent({
            type: "update"
        });
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
};

THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);

THREE.TextureIdCount = 0;

THREE.CubeTexture = function(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
    THREE.Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.images = images;
};

THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);

THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.clone = function(texture) {
    if (texture === undefined) texture = new THREE.CubeTexture();
    THREE.Texture.prototype.clone.call(this, texture);
    texture.images = this.images;
    return texture;
};

THREE.CompressedTexture = function(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
    THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
        width: width,
        height: height
    };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
};

THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);

THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

THREE.CompressedTexture.prototype.clone = function() {
    var texture = new THREE.CompressedTexture();
    THREE.Texture.prototype.clone.call(this, texture);
    return texture;
};

THREE.DataTexture = function(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
    THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
        data: data,
        width: width,
        height: height
    };
};

THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);

THREE.DataTexture.prototype.constructor = THREE.DataTexture;

THREE.DataTexture.prototype.clone = function() {
    var texture = new THREE.DataTexture();
    THREE.Texture.prototype.clone.call(this, texture);
    return texture;
};

THREE.VideoTexture = function(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    THREE.Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.generateMipmaps = false;
    var scope = this;
    var update = function() {
        requestAnimationFrame(update);
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
            scope.needsUpdate = true;
        }
    };
    update();
};

THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);

THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

THREE.Group = function() {
    THREE.Object3D.call(this);
    this.type = "Group";
};

THREE.Group.prototype = Object.create(THREE.Object3D.prototype);

THREE.Group.prototype.constructor = THREE.Group;

THREE.PointCloud = function(geometry, material) {
    THREE.Object3D.call(this);
    this.type = "PointCloud";
    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.PointCloudMaterial({
        color: Math.random() * 16777215
    });
};

THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype);

THREE.PointCloud.prototype.constructor = THREE.PointCloud;

THREE.PointCloud.prototype.raycast = function() {
    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    return function(raycaster, intersects) {
        var object = this;
        var geometry = object.geometry;
        var threshold = raycaster.params.PointCloud.threshold;
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null) {
            if (ray.isIntersectionBox(geometry.boundingBox) === false) {
                return;
            }
        }
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var position = new THREE.Vector3();
        var testPoint = function(point, index) {
            var rayPointDistance = ray.distanceToPoint(point);
            if (rayPointDistance < localThreshold) {
                var intersectPoint = ray.closestPointToPoint(point);
                intersectPoint.applyMatrix4(object.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                intersects.push({
                    distance: distance,
                    distanceToRay: rayPointDistance,
                    point: intersectPoint.clone(),
                    index: index,
                    face: null,
                    object: object
                });
            }
        };
        if (geometry instanceof THREE.BufferGeometry) {
            var attributes = geometry.attributes;
            var positions = attributes.position.array;
            if (attributes.index !== undefined) {
                var indices = attributes.index.array;
                var offsets = geometry.offsets;
                if (offsets.length === 0) {
                    var offset = {
                        start: 0,
                        count: indices.length,
                        index: 0
                    };
                    offsets = [ offset ];
                }
                for (var oi = 0, ol = offsets.length; oi < ol; ++oi) {
                    var start = offsets[oi].start;
                    var count = offsets[oi].count;
                    var index = offsets[oi].index;
                    for (var i = start, il = start + count; i < il; i++) {
                        var a = index + indices[i];
                        position.fromArray(positions, a * 3);
                        testPoint(position, a);
                    }
                }
            } else {
                var pointCount = positions.length / 3;
                for (var i = 0; i < pointCount; i++) {
                    position.set(positions[3 * i], positions[3 * i + 1], positions[3 * i + 2]);
                    testPoint(position, i);
                }
            }
        } else {
            var vertices = this.geometry.vertices;
            for (var i = 0; i < vertices.length; i++) {
                testPoint(vertices[i], i);
            }
        }
    };
}();

THREE.PointCloud.prototype.clone = function(object) {
    if (object === undefined) object = new THREE.PointCloud(this.geometry, this.material);
    THREE.Object3D.prototype.clone.call(this, object);
    return object;
};

THREE.ParticleSystem = function(geometry, material) {
    THREE.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud.");
    return new THREE.PointCloud(geometry, material);
};

THREE.Line = function(geometry, material, mode) {
    THREE.Object3D.call(this);
    this.type = "Line";
    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.LineBasicMaterial({
        color: Math.random() * 16777215
    });
    this.mode = mode !== undefined ? mode : THREE.LineStrip;
};

THREE.LineStrip = 0;

THREE.LinePieces = 1;

THREE.Line.prototype = Object.create(THREE.Object3D.prototype);

THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = function() {
    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();
    return function(raycaster, intersects) {
        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;
        var geometry = this.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(this.matrixWorld);
        if (raycaster.ray.isIntersectionSphere(sphere) === false) {
            return;
        }
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        var vStart = new THREE.Vector3();
        var vEnd = new THREE.Vector3();
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = this.mode === THREE.LineStrip ? 1 : 2;
        if (geometry instanceof THREE.BufferGeometry) {
            var attributes = geometry.attributes;
            if (attributes.index !== undefined) {
                var indices = attributes.index.array;
                var positions = attributes.position.array;
                var offsets = geometry.offsets;
                if (offsets.length === 0) {
                    offsets = [ {
                        start: 0,
                        count: indices.length,
                        index: 0
                    } ];
                }
                for (var oi = 0; oi < offsets.length; oi++) {
                    var start = offsets[oi].start;
                    var count = offsets[oi].count;
                    var index = offsets[oi].index;
                    for (var i = start; i < start + count - 1; i += step) {
                        var a = index + indices[i];
                        var b = index + indices[i + 1];
                        vStart.fromArray(positions, a * 3);
                        vEnd.fromArray(positions, b * 3);
                        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                        if (distSq > precisionSq) continue;
                        var distance = ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far) continue;
                        intersects.push({
                            distance: distance,
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            offsetIndex: oi,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                }
            } else {
                var positions = attributes.position.array;
                for (var i = 0; i < positions.length / 3 - 1; i += step) {
                    vStart.fromArray(positions, 3 * i);
                    vEnd.fromArray(positions, 3 * i + 3);
                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > precisionSq) continue;
                    var distance = ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects.push({
                        distance: distance,
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
        } else if (geometry instanceof THREE.Geometry) {
            var vertices = geometry.vertices;
            var nbVertices = vertices.length;
            for (var i = 0; i < nbVertices - 1; i += step) {
                var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                if (distSq > precisionSq) continue;
                var distance = ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far) continue;
                intersects.push({
                    distance: distance,
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        }
    };
}();

THREE.Line.prototype.clone = function(object) {
    if (object === undefined) object = new THREE.Line(this.geometry, this.material, this.mode);
    THREE.Object3D.prototype.clone.call(this, object);
    return object;
};

THREE.Mesh = function(geometry, material) {
    THREE.Object3D.call(this);
    this.type = "Mesh";
    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({
        color: Math.random() * 16777215
    });
    this.updateMorphTargets();
};

THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);

THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function() {
    if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {
        this.morphTargetBase = -1;
        this.morphTargetForcedOrder = [];
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++) {
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
        }
    }
};

THREE.Mesh.prototype.getMorphTargetIndexByName = function(name) {
    if (this.morphTargetDictionary[name] !== undefined) {
        return this.morphTargetDictionary[name];
    }
    THREE.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + name + " does not exist. Returning 0.");
    return 0;
};

THREE.Mesh.prototype.raycast = function() {
    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();
    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();
    return function(raycaster, intersects) {
        var geometry = this.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(this.matrixWorld);
        if (raycaster.ray.isIntersectionSphere(sphere) === false) {
            return;
        }
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null) {
            if (ray.isIntersectionBox(geometry.boundingBox) === false) {
                return;
            }
        }
        if (geometry instanceof THREE.BufferGeometry) {
            var material = this.material;
            if (material === undefined) return;
            var attributes = geometry.attributes;
            var a, b, c;
            var precision = raycaster.precision;
            if (attributes.index !== undefined) {
                var indices = attributes.index.array;
                var positions = attributes.position.array;
                var offsets = geometry.offsets;
                if (offsets.length === 0) {
                    offsets = [ {
                        start: 0,
                        count: indices.length,
                        index: 0
                    } ];
                }
                for (var oi = 0, ol = offsets.length; oi < ol; ++oi) {
                    var start = offsets[oi].start;
                    var count = offsets[oi].count;
                    var index = offsets[oi].index;
                    for (var i = start, il = start + count; i < il; i += 3) {
                        a = index + indices[i];
                        b = index + indices[i + 1];
                        c = index + indices[i + 2];
                        vA.fromArray(positions, a * 3);
                        vB.fromArray(positions, b * 3);
                        vC.fromArray(positions, c * 3);
                        if (material.side === THREE.BackSide) {
                            var intersectionPoint = ray.intersectTriangle(vC, vB, vA, true);
                        } else {
                            var intersectionPoint = ray.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);
                        }
                        if (intersectionPoint === null) continue;
                        intersectionPoint.applyMatrix4(this.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
                        if (distance < precision || distance < raycaster.near || distance > raycaster.far) continue;
                        intersects.push({
                            distance: distance,
                            point: intersectionPoint,
                            face: new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC)),
                            faceIndex: null,
                            object: this
                        });
                    }
                }
            } else {
                var positions = attributes.position.array;
                for (var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9) {
                    a = i;
                    b = i + 1;
                    c = i + 2;
                    vA.fromArray(positions, j);
                    vB.fromArray(positions, j + 3);
                    vC.fromArray(positions, j + 6);
                    if (material.side === THREE.BackSide) {
                        var intersectionPoint = ray.intersectTriangle(vC, vB, vA, true);
                    } else {
                        var intersectionPoint = ray.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);
                    }
                    if (intersectionPoint === null) continue;
                    intersectionPoint.applyMatrix4(this.matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
                    if (distance < precision || distance < raycaster.near || distance > raycaster.far) continue;
                    intersects.push({
                        distance: distance,
                        point: intersectionPoint,
                        face: new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC)),
                        faceIndex: null,
                        object: this
                    });
                }
            }
        } else if (geometry instanceof THREE.Geometry) {
            var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
            var objectMaterials = isFaceMaterial === true ? this.material.materials : null;
            var a, b, c;
            var precision = raycaster.precision;
            var vertices = geometry.vertices;
            for (var f = 0, fl = geometry.faces.length; f < fl; f++) {
                var face = geometry.faces[f];
                var material = isFaceMaterial === true ? objectMaterials[face.materialIndex] : this.material;
                if (material === undefined) continue;
                a = vertices[face.a];
                b = vertices[face.b];
                c = vertices[face.c];
                if (material.morphTargets === true) {
                    var morphTargets = geometry.morphTargets;
                    var morphInfluences = this.morphTargetInfluences;
                    vA.set(0, 0, 0);
                    vB.set(0, 0, 0);
                    vC.set(0, 0, 0);
                    for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                        var influence = morphInfluences[t];
                        if (influence === 0) continue;
                        var targets = morphTargets[t].vertices;
                        vA.x += (targets[face.a].x - a.x) * influence;
                        vA.y += (targets[face.a].y - a.y) * influence;
                        vA.z += (targets[face.a].z - a.z) * influence;
                        vB.x += (targets[face.b].x - b.x) * influence;
                        vB.y += (targets[face.b].y - b.y) * influence;
                        vB.z += (targets[face.b].z - b.z) * influence;
                        vC.x += (targets[face.c].x - c.x) * influence;
                        vC.y += (targets[face.c].y - c.y) * influence;
                        vC.z += (targets[face.c].z - c.z) * influence;
                    }
                    vA.add(a);
                    vB.add(b);
                    vC.add(c);
                    a = vA;
                    b = vB;
                    c = vC;
                }
                if (material.side === THREE.BackSide) {
                    var intersectionPoint = ray.intersectTriangle(c, b, a, true);
                } else {
                    var intersectionPoint = ray.intersectTriangle(a, b, c, material.side !== THREE.DoubleSide);
                }
                if (intersectionPoint === null) continue;
                intersectionPoint.applyMatrix4(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
                if (distance < precision || distance < raycaster.near || distance > raycaster.far) continue;
                intersects.push({
                    distance: distance,
                    point: intersectionPoint,
                    face: face,
                    faceIndex: f,
                    object: this
                });
            }
        }
    };
}();

THREE.Mesh.prototype.clone = function(object, recursive) {
    if (object === undefined) object = new THREE.Mesh(this.geometry, this.material);
    THREE.Object3D.prototype.clone.call(this, object, recursive);
    return object;
};

THREE.Bone = function(skin) {
    THREE.Object3D.call(this);
    this.type = "Bone";
    this.skin = skin;
};

THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);

THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Skeleton = function(bones, boneInverses, useVertexTexture) {
    this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
    this.identityMatrix = new THREE.Matrix4();
    bones = bones || [];
    this.bones = bones.slice(0);
    if (this.useVertexTexture) {
        var size;
        if (this.bones.length > 256) size = 64; else if (this.bones.length > 64) size = 32; else if (this.bones.length > 16) size = 16; else size = 8;
        this.boneTextureWidth = size;
        this.boneTextureHeight = size;
        this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
        this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
        this.boneTexture.minFilter = THREE.NearestFilter;
        this.boneTexture.magFilter = THREE.NearestFilter;
        this.boneTexture.generateMipmaps = false;
        this.boneTexture.flipY = false;
    } else {
        this.boneMatrices = new Float32Array(16 * this.bones.length);
    }
    if (boneInverses === undefined) {
        this.calculateInverses();
    } else {
        if (this.bones.length === boneInverses.length) {
            this.boneInverses = boneInverses.slice(0);
        } else {
            THREE.warn("THREE.Skeleton bonInverses is the wrong length.");
            this.boneInverses = [];
            for (var b = 0, bl = this.bones.length; b < bl; b++) {
                this.boneInverses.push(new THREE.Matrix4());
            }
        }
    }
};

THREE.Skeleton.prototype.calculateInverses = function() {
    this.boneInverses = [];
    for (var b = 0, bl = this.bones.length; b < bl; b++) {
        var inverse = new THREE.Matrix4();
        if (this.bones[b]) {
            inverse.getInverse(this.bones[b].matrixWorld);
        }
        this.boneInverses.push(inverse);
    }
};

THREE.Skeleton.prototype.pose = function() {
    var bone;
    for (var b = 0, bl = this.bones.length; b < bl; b++) {
        bone = this.bones[b];
        if (bone) {
            bone.matrixWorld.getInverse(this.boneInverses[b]);
        }
    }
    for (var b = 0, bl = this.bones.length; b < bl; b++) {
        bone = this.bones[b];
        if (bone) {
            if (bone.parent) {
                bone.matrix.getInverse(bone.parent.matrixWorld);
                bone.matrix.multiply(bone.matrixWorld);
            } else {
                bone.matrix.copy(bone.matrixWorld);
            }
            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
    }
};

THREE.Skeleton.prototype.update = function() {
    var offsetMatrix = new THREE.Matrix4();
    return function() {
        for (var b = 0, bl = this.bones.length; b < bl; b++) {
            var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
            offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
            offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);
        }
        if (this.useVertexTexture) {
            this.boneTexture.needsUpdate = true;
        }
    };
}();

THREE.SkinnedMesh = function(geometry, material, useVertexTexture) {
    THREE.Mesh.call(this, geometry, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new THREE.Matrix4();
    this.bindMatrixInverse = new THREE.Matrix4();
    var bones = [];
    if (this.geometry && this.geometry.bones !== undefined) {
        var bone, gbone, p, q, s;
        for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
            gbone = this.geometry.bones[b];
            p = gbone.pos;
            q = gbone.rotq;
            s = gbone.scl;
            bone = new THREE.Bone(this);
            bones.push(bone);
            bone.name = gbone.name;
            bone.position.set(p[0], p[1], p[2]);
            bone.quaternion.set(q[0], q[1], q[2], q[3]);
            if (s !== undefined) {
                bone.scale.set(s[0], s[1], s[2]);
            } else {
                bone.scale.set(1, 1, 1);
            }
        }
        for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
            gbone = this.geometry.bones[b];
            if (gbone.parent !== -1) {
                bones[gbone.parent].add(bones[b]);
            } else {
                this.add(bones[b]);
            }
        }
    }
    this.normalizeSkinWeights();
    this.updateMatrixWorld(true);
    this.bind(new THREE.Skeleton(bones, undefined, useVertexTexture));
};

THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);

THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === undefined) {
        this.updateMatrixWorld(true);
        bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.getInverse(bindMatrix);
};

THREE.SkinnedMesh.prototype.pose = function() {
    this.skeleton.pose();
};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
    if (this.geometry instanceof THREE.Geometry) {
        for (var i = 0; i < this.geometry.skinIndices.length; i++) {
            var sw = this.geometry.skinWeights[i];
            var scale = 1 / sw.lengthManhattan();
            if (scale !== Infinity) {
                sw.multiplyScalar(scale);
            } else {
                sw.set(1);
            }
        }
    } else {}
};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function(force) {
    THREE.Mesh.prototype.updateMatrixWorld.call(this, true);
    if (this.bindMode === "attached") {
        this.bindMatrixInverse.getInverse(this.matrixWorld);
    } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.getInverse(this.bindMatrix);
    } else {
        THREE.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode);
    }
};

THREE.SkinnedMesh.prototype.clone = function(object) {
    if (object === undefined) {
        object = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture);
    }
    THREE.Mesh.prototype.clone.call(this, object);
    return object;
};

THREE.MorphAnimMesh = function(geometry, material) {
    THREE.Mesh.call(this, geometry, material);
    this.type = "MorphAnimMesh";
    this.duration = 1e3;
    this.mirroredLoop = false;
    this.time = 0;
    this.lastKeyframe = 0;
    this.currentKeyframe = 0;
    this.direction = 1;
    this.directionBackwards = false;
    this.setFrameRange(0, this.geometry.morphTargets.length - 1);
};

THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);

THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

THREE.MorphAnimMesh.prototype.setFrameRange = function(start, end) {
    this.startKeyframe = start;
    this.endKeyframe = end;
    this.length = this.endKeyframe - this.startKeyframe + 1;
};

THREE.MorphAnimMesh.prototype.setDirectionForward = function() {
    this.direction = 1;
    this.directionBackwards = false;
};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {
    this.direction = -1;
    this.directionBackwards = true;
};

THREE.MorphAnimMesh.prototype.parseAnimations = function() {
    var geometry = this.geometry;
    if (!geometry.animations) geometry.animations = {};
    var firstAnimation, animations = geometry.animations;
    var pattern = /([a-z]+)_?(\d+)/;
    for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
        var morph = geometry.morphTargets[i];
        var parts = morph.name.match(pattern);
        if (parts && parts.length > 1) {
            var label = parts[1];
            if (!animations[label]) animations[label] = {
                start: Infinity,
                end: -Infinity
            };
            var animation = animations[label];
            if (i < animation.start) animation.start = i;
            if (i > animation.end) animation.end = i;
            if (!firstAnimation) firstAnimation = label;
        }
    }
    geometry.firstAnimation = firstAnimation;
};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function(label, start, end) {
    if (!this.geometry.animations) this.geometry.animations = {};
    this.geometry.animations[label] = {
        start: start,
        end: end
    };
};

THREE.MorphAnimMesh.prototype.playAnimation = function(label, fps) {
    var animation = this.geometry.animations[label];
    if (animation) {
        this.setFrameRange(animation.start, animation.end);
        this.duration = 1e3 * ((animation.end - animation.start) / fps);
        this.time = 0;
    } else {
        THREE.warn("THREE.MorphAnimMesh: animation[" + label + "] undefined in .playAnimation()");
    }
};

THREE.MorphAnimMesh.prototype.updateAnimation = function(delta) {
    var frameTime = this.duration / this.length;
    this.time += this.direction * delta;
    if (this.mirroredLoop) {
        if (this.time > this.duration || this.time < 0) {
            this.direction *= -1;
            if (this.time > this.duration) {
                this.time = this.duration;
                this.directionBackwards = true;
            }
            if (this.time < 0) {
                this.time = 0;
                this.directionBackwards = false;
            }
        }
    } else {
        this.time = this.time % this.duration;
        if (this.time < 0) this.time += this.duration;
    }
    var keyframe = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / frameTime), 0, this.length - 1);
    if (keyframe !== this.currentKeyframe) {
        this.morphTargetInfluences[this.lastKeyframe] = 0;
        this.morphTargetInfluences[this.currentKeyframe] = 1;
        this.morphTargetInfluences[keyframe] = 0;
        this.lastKeyframe = this.currentKeyframe;
        this.currentKeyframe = keyframe;
    }
    var mix = this.time % frameTime / frameTime;
    if (this.directionBackwards) {
        mix = 1 - mix;
    }
    this.morphTargetInfluences[this.currentKeyframe] = mix;
    this.morphTargetInfluences[this.lastKeyframe] = 1 - mix;
};

THREE.MorphAnimMesh.prototype.interpolateTargets = function(a, b, t) {
    var influences = this.morphTargetInfluences;
    for (var i = 0, l = influences.length; i < l; i++) {
        influences[i] = 0;
    }
    if (a > -1) influences[a] = 1 - t;
    if (b > -1) influences[b] = t;
};

THREE.MorphAnimMesh.prototype.clone = function(object) {
    if (object === undefined) object = new THREE.MorphAnimMesh(this.geometry, this.material);
    object.duration = this.duration;
    object.mirroredLoop = this.mirroredLoop;
    object.time = this.time;
    object.lastKeyframe = this.lastKeyframe;
    object.currentKeyframe = this.currentKeyframe;
    object.direction = this.direction;
    object.directionBackwards = this.directionBackwards;
    THREE.Mesh.prototype.clone.call(this, object);
    return object;
};

THREE.LOD = function() {
    THREE.Object3D.call(this);
    this.objects = [];
};

THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);

THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function(object, distance) {
    if (distance === undefined) distance = 0;
    distance = Math.abs(distance);
    for (var l = 0; l < this.objects.length; l++) {
        if (distance < this.objects[l].distance) {
            break;
        }
    }
    this.objects.splice(l, 0, {
        distance: distance,
        object: object
    });
    this.add(object);
};

THREE.LOD.prototype.getObjectForDistance = function(distance) {
    for (var i = 1, l = this.objects.length; i < l; i++) {
        if (distance < this.objects[i].distance) {
            break;
        }
    }
    return this.objects[i - 1].object;
};

THREE.LOD.prototype.raycast = function() {
    var matrixPosition = new THREE.Vector3();
    return function(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(matrixPosition);
        this.getObjectForDistance(distance).raycast(raycaster, intersects);
    };
}();

THREE.LOD.prototype.update = function() {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    return function(camera) {
        if (this.objects.length > 1) {
            v1.setFromMatrixPosition(camera.matrixWorld);
            v2.setFromMatrixPosition(this.matrixWorld);
            var distance = v1.distanceTo(v2);
            this.objects[0].object.visible = true;
            for (var i = 1, l = this.objects.length; i < l; i++) {
                if (distance >= this.objects[i].distance) {
                    this.objects[i - 1].object.visible = false;
                    this.objects[i].object.visible = true;
                } else {
                    break;
                }
            }
            for (;i < l; i++) {
                this.objects[i].object.visible = false;
            }
        }
    };
}();

THREE.LOD.prototype.clone = function(object) {
    if (object === undefined) object = new THREE.LOD();
    THREE.Object3D.prototype.clone.call(this, object);
    for (var i = 0, l = this.objects.length; i < l; i++) {
        var x = this.objects[i].object.clone();
        x.visible = i === 0;
        object.addLevel(x, this.objects[i].distance);
    }
    return object;
};

THREE.Sprite = function() {
    var indices = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
    var vertices = new Float32Array([ -.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0 ]);
    var uvs = new Float32Array([ 0, 0, 1, 0, 1, 1, 0, 1 ]);
    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute("index", new THREE.BufferAttribute(indices, 1));
    geometry.addAttribute("position", new THREE.BufferAttribute(vertices, 3));
    geometry.addAttribute("uv", new THREE.BufferAttribute(uvs, 2));
    return function(material) {
        THREE.Object3D.call(this);
        this.type = "Sprite";
        this.geometry = geometry;
        this.material = material !== undefined ? material : new THREE.SpriteMaterial();
    };
}();

THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);

THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = function() {
    var matrixPosition = new THREE.Vector3();
    return function(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.distanceToPoint(matrixPosition);
        if (distance > this.scale.x) {
            return;
        }
        intersects.push({
            distance: distance,
            point: this.position,
            face: null,
            object: this
        });
    };
}();

THREE.Sprite.prototype.clone = function(object) {
    if (object === undefined) object = new THREE.Sprite(this.material);
    THREE.Object3D.prototype.clone.call(this, object);
    return object;
};

THREE.Particle = THREE.Sprite;

THREE.LensFlare = function(texture, size, distance, blending, color) {
    THREE.Object3D.call(this);
    this.lensFlares = [];
    this.positionScreen = new THREE.Vector3();
    this.customUpdateCallback = undefined;
    if (texture !== undefined) {
        this.add(texture, size, distance, blending, color);
    }
};

THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);

THREE.LensFlare.prototype.constructor = THREE.LensFlare;

THREE.LensFlare.prototype.add = function(texture, size, distance, blending, color, opacity) {
    if (size === undefined) size = -1;
    if (distance === undefined) distance = 0;
    if (opacity === undefined) opacity = 1;
    if (color === undefined) color = new THREE.Color(16777215);
    if (blending === undefined) blending = THREE.NormalBlending;
    distance = Math.min(distance, Math.max(0, distance));
    this.lensFlares.push({
        texture: texture,
        size: size,
        distance: distance,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 1,
        opacity: opacity,
        color: color,
        blending: blending
    });
};

THREE.LensFlare.prototype.updateLensFlares = function() {
    var f, fl = this.lensFlares.length;
    var flare;
    var vecX = -this.positionScreen.x * 2;
    var vecY = -this.positionScreen.y * 2;
    for (f = 0; f < fl; f++) {
        flare = this.lensFlares[f];
        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;
        flare.wantedRotation = flare.x * Math.PI * .25;
        flare.rotation += (flare.wantedRotation - flare.rotation) * .25;
    }
};

THREE.Scene = function() {
    THREE.Object3D.call(this);
    this.type = "Scene";
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
};

THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);

THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.clone = function(object) {
    if (object === undefined) object = new THREE.Scene();
    THREE.Object3D.prototype.clone.call(this, object);
    if (this.fog !== null) object.fog = this.fog.clone();
    if (this.overrideMaterial !== null) object.overrideMaterial = this.overrideMaterial.clone();
    object.autoUpdate = this.autoUpdate;
    object.matrixAutoUpdate = this.matrixAutoUpdate;
    return object;
};

THREE.Fog = function(color, near, far) {
    this.name = "";
    this.color = new THREE.Color(color);
    this.near = near !== undefined ? near : 1;
    this.far = far !== undefined ? far : 1e3;
};

THREE.Fog.prototype.clone = function() {
    return new THREE.Fog(this.color.getHex(), this.near, this.far);
};

THREE.FogExp2 = function(color, density) {
    this.name = "";
    this.color = new THREE.Color(color);
    this.density = density !== undefined ? density : 25e-5;
};

THREE.FogExp2.prototype.clone = function() {
    return new THREE.FogExp2(this.color.getHex(), this.density);
};

THREE.ShaderChunk = {};

THREE.ShaderChunk["common"] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n float distance = dot( planeNormal, point-pointOnPlane );\n  return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n   return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n   if ( decayExponent > 0.0 ) {\n    return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n  }\n return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n   return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n  return a;\n#endif\n}\n";

THREE.ShaderChunk["alphatest_fragment"] = "#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

THREE.ShaderChunk["lights_lambert_vertex"] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n    vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n    vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n  float dotProduct = dot( transformedNormal, dirVector );\n   vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n    #ifdef DOUBLE_SIDED\n\n     vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n       #ifdef WRAP_AROUND\n\n          vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n       #endif\n\n  #endif\n\n  #ifdef WRAP_AROUND\n\n      vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n      directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n       #ifdef DOUBLE_SIDED\n\n         directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n       #endif\n\n  #endif\n\n  vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n  #ifdef DOUBLE_SIDED\n\n     vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n   #endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n   for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n       vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n      float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n       lVector = normalize( lVector );\n       float dotProduct = dot( transformedNormal, lVector );\n\n       vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n      #ifdef DOUBLE_SIDED\n\n         vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n         #ifdef WRAP_AROUND\n\n              vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n         #endif\n\n      #endif\n\n      #ifdef WRAP_AROUND\n\n          vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n            pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n         #ifdef DOUBLE_SIDED\n\n             pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n         #endif\n\n      #endif\n\n      vLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n        #ifdef DOUBLE_SIDED\n\n         vLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n     #endif\n\n  }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n       vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n      float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n     if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n            spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n         float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n         lVector = normalize( lVector );\n\n         float dotProduct = dot( transformedNormal, lVector );\n         vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n           #ifdef DOUBLE_SIDED\n\n             vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n              #ifdef WRAP_AROUND\n\n                  vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n              #endif\n\n          #endif\n\n          #ifdef WRAP_AROUND\n\n              vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n             spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n                #ifdef DOUBLE_SIDED\n\n                 spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n                #endif\n\n          #endif\n\n          vLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n         #ifdef DOUBLE_SIDED\n\n             vLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n          #endif\n\n      }\n\n   }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n       vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n     float dotProduct = dot( transformedNormal, lVector );\n\n       float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n     float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n      vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n     #ifdef DOUBLE_SIDED\n\n         vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n      #endif\n\n  }\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n vLightBack += ambientLightColor;\n\n#endif\n";

THREE.ShaderChunk["map_particle_pars_fragment"] = "#ifdef USE_MAP\n\n  uniform vec4 offsetRepeat;\n    uniform sampler2D map;\n\n#endif\n";

THREE.ShaderChunk["default_vertex"] = "#ifdef USE_SKINNING\n\n vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n   vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

THREE.ShaderChunk["map_pars_fragment"] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n   uniform sampler2D map;\n\n#endif";

THREE.ShaderChunk["skinnormal_vertex"] = "#ifdef USE_SKINNING\n\n  mat4 skinMatrix = mat4( 0.0 );\n    skinMatrix += skinWeight.x * boneMatX;\n    skinMatrix += skinWeight.y * boneMatY;\n    skinMatrix += skinWeight.z * boneMatZ;\n    skinMatrix += skinWeight.w * boneMatW;\n    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n  #ifdef USE_MORPHNORMALS\n\n vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n   #else\n\n   vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n  #endif\n\n#endif\n";

THREE.ShaderChunk["logdepthbuf_pars_vertex"] = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n      varying float vFragDepth;\n\n   #endif\n\n  uniform float logDepthBufFC;\n\n#endif";

THREE.ShaderChunk["lightmap_pars_vertex"] = "#ifdef USE_LIGHTMAP\n\n   varying vec2 vUv2;\n\n#endif";

THREE.ShaderChunk["lights_phong_fragment"] = "#ifndef FLAT_SHADED\n\n  vec3 normal = normalize( vNormal );\n\n #ifdef DOUBLE_SIDED\n\n     normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n #endif\n\n#else\n\n vec3 fdx = dFdx( vViewPosition );\n vec3 fdy = dFdy( vViewPosition );\n vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n  normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n   normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n    for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n     vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n       vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n       float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n       lVector = normalize( lVector );\n\n     // diffuse\n\n      float dotProduct = dot( normal, lVector );\n\n      #ifdef WRAP_AROUND\n\n          float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n            float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n          vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n       #else\n\n           float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n      #endif\n\n      totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n               // specular\n\n     vec3 pointHalfVector = normalize( lVector + viewPosition );\n       float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n        float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n        float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n     totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n  }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n      vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n       float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n     lVector = normalize( lVector );\n\n     float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n        if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n            spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n         // diffuse\n\n          float dotProduct = dot( normal, lVector );\n\n          #ifdef WRAP_AROUND\n\n              float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n             float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n               vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n          #else\n\n               float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n           #endif\n\n          totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n            // specular\n\n         vec3 spotHalfVector = normalize( lVector + viewPosition );\n            float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n          float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n          float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n            vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n          totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n        }\n\n   }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n   for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n        vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n      // diffuse\n\n      float dotProduct = dot( normal, dirVector );\n\n        #ifdef WRAP_AROUND\n\n          float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n          float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n            vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n     #else\n\n           float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n        #endif\n\n      totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n     // specular\n\n     vec3 dirHalfVector = normalize( dirVector + viewPosition );\n       float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n        float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n        /*\n        // fresnel term from skin shader\n      const float F0 = 0.128;\n\n     float base = 1.0 - dot( viewPosition, dirHalfVector );\n        float exponential = pow( base, 5.0 );\n\n       float fresnel = exponential + F0 * ( 1.0 - exponential );\n     */\n\n      /*\n        // fresnel term from fresnel shader\n       const float mFresnelBias = 0.08;\n      const float mFresnelScale = 0.3;\n      const float mFresnelPower = 5.0;\n\n        float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n     */\n\n      float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        //      dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n      vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n     totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n    }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n       vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n     // diffuse\n\n      float dotProduct = dot( normal, lVector );\n        float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n       vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n       totalDiffuseLight += hemiColor;\n\n     // specular (sky light)\n\n     vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n     float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n        float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n        // specular (ground light)\n\n      vec3 lVectorGround = -lVector;\n\n      vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n        float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n      float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n      float dotProductGround = dot( normal, lVectorGround );\n\n      float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n        vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n        totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n    }\n\n#endif\n\n#ifdef METAL\n\n outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n  outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n";

THREE.ShaderChunk["fog_pars_fragment"] = "#ifdef USE_FOG\n\n   uniform vec3 fogColor;\n\n  #ifdef FOG_EXP2\n\n     uniform float fogDensity;\n\n   #else\n\n       uniform float fogNear;\n        uniform float fogFar;\n #endif\n\n#endif";

THREE.ShaderChunk["morphnormal_vertex"] = "#ifdef USE_MORPHNORMALS\n\n vec3 morphedNormal = vec3( 0.0 );\n\n   morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n  morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n  morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n  morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n    morphedNormal += normal;\n\n#endif";

THREE.ShaderChunk["envmap_pars_fragment"] = "#ifdef USE_ENVMAP\n\n uniform float reflectivity;\n   #ifdef ENVMAP_TYPE_CUBE\n       uniform samplerCube envMap;\n   #else\n     uniform sampler2D envMap;\n #endif\n    uniform float flipEnvMap;\n\n   #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n      uniform float refractionRatio;\n\n  #else\n\n       varying vec3 vReflect;\n\n  #endif\n\n#endif\n";

THREE.ShaderChunk["logdepthbuf_fragment"] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n  gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

THREE.ShaderChunk["normalmap_pars_fragment"] = "#ifdef USE_NORMALMAP\n\n   uniform sampler2D normalMap;\n  uniform vec2 normalScale;\n\n   // Per-Pixel Tangent Space Normal Mapping\n // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n   vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n        vec3 q0 = dFdx( eye_pos.xyz );\n        vec3 q1 = dFdy( eye_pos.xyz );\n        vec2 st0 = dFdx( vUv.st );\n        vec2 st1 = dFdy( vUv.st );\n\n      vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n        vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n       vec3 N = normalize( surf_norm );\n\n        vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n      mapN.xy = normalScale * mapN.xy;\n      mat3 tsn = mat3( S, T, N );\n       return normalize( tsn * mapN );\n\n }\n\n#endif\n";

THREE.ShaderChunk["lights_phong_pars_vertex"] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    varying vec3 vWorldPosition;\n\n#endif\n";

THREE.ShaderChunk["lightmap_pars_fragment"] = "#ifdef USE_LIGHTMAP\n\n varying vec2 vUv2;\n    uniform sampler2D lightMap;\n\n#endif";

THREE.ShaderChunk["shadowmap_vertex"] = "#ifdef USE_SHADOWMAP\n\n  for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n       vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n  }\n\n#endif";

THREE.ShaderChunk["lights_phong_vertex"] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n vWorldPosition = worldPosition.xyz;\n\n#endif";

THREE.ShaderChunk["map_fragment"] = "#ifdef USE_MAP\n\n    vec4 texelColor = texture2D( map, vUv );\n\n    texelColor.xyz = inputToLinear( texelColor.xyz );\n\n   diffuseColor *= texelColor;\n\n#endif";

THREE.ShaderChunk["lightmap_vertex"] = "#ifdef USE_LIGHTMAP\n\n    vUv2 = uv2;\n\n#endif";

THREE.ShaderChunk["map_particle_fragment"] = "#ifdef USE_MAP\n\n   diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

THREE.ShaderChunk["color_pars_fragment"] = "#ifdef USE_COLOR\n\n   varying vec3 vColor;\n\n#endif\n";

THREE.ShaderChunk["color_vertex"] = "#ifdef USE_COLOR\n\n  vColor.xyz = inputToLinear( color.xyz );\n\n#endif";

THREE.ShaderChunk["skinning_vertex"] = "#ifdef USE_SKINNING\n\n    #ifdef USE_MORPHTARGETS\n\n vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n   vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n   #endif\n\n  vec4 skinned = vec4( 0.0 );\n   skinned += boneMatX * skinVertex * skinWeight.x;\n  skinned += boneMatY * skinVertex * skinWeight.y;\n  skinned += boneMatZ * skinVertex * skinWeight.z;\n  skinned += boneMatW * skinVertex * skinWeight.w;\n  skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

THREE.ShaderChunk["envmap_pars_vertex"] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n   varying vec3 vReflect;\n\n  uniform float refractionRatio;\n\n#endif\n";

THREE.ShaderChunk["linear_to_gamma_fragment"] = "\n    outgoingLight = linearToOutput( outgoingLight );\n";

THREE.ShaderChunk["color_pars_vertex"] = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif";

THREE.ShaderChunk["lights_lambert_pars_vertex"] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n   uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n  uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n   uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n  uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n   uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n    uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n   uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n   uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n   uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n   uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n    uniform vec3 wrapRGB;\n\n#endif\n";

THREE.ShaderChunk["map_pars_vertex"] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n  varying vec2 vUv;\n uniform vec4 offsetRepeat;\n\n#endif\n";

THREE.ShaderChunk["envmap_fragment"] = "#ifdef USE_ENVMAP\n\n  #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n      vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n     // Transforming Normal Vectors with the Inverse Transformation\n        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n     #ifdef ENVMAP_MODE_REFLECTION\n\n           vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n       #else\n\n           vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n      #endif\n\n  #else\n\n       vec3 reflectVec = vReflect;\n\n #endif\n\n  #ifdef DOUBLE_SIDED\n       float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n  #else\n     float flipNormal = 1.0;\n   #endif\n\n  #ifdef ENVMAP_TYPE_CUBE\n       vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n   #elif defined( ENVMAP_TYPE_EQUIREC )\n      vec2 sampleUV;\n        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n       sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n     vec4 envColor = texture2D( envMap, sampleUV );\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n       vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n  #endif\n\n  envColor.xyz = inputToLinear( envColor.xyz );\n\n   #ifdef ENVMAP_BLENDING_MULTIPLY\n\n     outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n    #elif defined( ENVMAP_BLENDING_MIX )\n\n        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n    #elif defined( ENVMAP_BLENDING_ADD )\n\n        outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n    #endif\n\n#endif\n";

THREE.ShaderChunk["specularmap_pars_fragment"] = "#ifdef USE_SPECULARMAP\n\n   uniform sampler2D specularMap;\n\n#endif";

THREE.ShaderChunk["logdepthbuf_vertex"] = "#ifdef USE_LOGDEPTHBUF\n\n  gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n      vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n      gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n  #endif\n\n#endif";

THREE.ShaderChunk["morphtarget_pars_vertex"] = "#ifdef USE_MORPHTARGETS\n\n    #ifndef USE_MORPHNORMALS\n\n    uniform float morphTargetInfluences[ 8 ];\n\n   #else\n\n   uniform float morphTargetInfluences[ 4 ];\n\n   #endif\n\n#endif";

THREE.ShaderChunk["specularmap_fragment"] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n vec4 texelSpecular = texture2D( specularMap, vUv );\n   specularStrength = texelSpecular.r;\n\n#else\n\n    specularStrength = 1.0;\n\n#endif";

THREE.ShaderChunk["fog_fragment"] = "#ifdef USE_FOG\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n      float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n #else\n\n       float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n  #endif\n\n  #ifdef FOG_EXP2\n\n     float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n        fogFactor = whiteCompliment( fogFactor );\n\n   #else\n\n       float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n #endif\n    \n  outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

THREE.ShaderChunk["bumpmap_pars_fragment"] = "#ifdef USE_BUMPMAP\n\n   uniform sampler2D bumpMap;\n    uniform float bumpScale;\n\n    // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd() {\n\n      vec2 dSTdx = dFdx( vUv );\n     vec2 dSTdy = dFdy( vUv );\n\n       float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n      float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n        float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n      return vec2( dBx, dBy );\n\n    }\n\n   vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n        vec3 vSigmaX = dFdx( surf_pos );\n      vec3 vSigmaY = dFdy( surf_pos );\n      vec3 vN = surf_norm;        // normalized\n\n       vec3 R1 = cross( vSigmaY, vN );\n       vec3 R2 = cross( vN, vSigmaX );\n\n     float fDet = dot( vSigmaX, R1 );\n\n        vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n      return normalize( abs( fDet ) * surf_norm - vGrad );\n\n    }\n\n#endif\n";

THREE.ShaderChunk["defaultnormal_vertex"] = "#ifdef USE_SKINNING\n\n   vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n vec3 objectNormal = morphedNormal;\n\n#else\n\n vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n  objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

THREE.ShaderChunk["lights_phong_pars_fragment"] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n   uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n  uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n   uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n   uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n  uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n   uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n    uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n   uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n   uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n   uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n   uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n    uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n   varying vec3 vNormal;\n\n#endif\n";

THREE.ShaderChunk["skinbase_vertex"] = "#ifdef USE_SKINNING\n\n    mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

THREE.ShaderChunk["map_vertex"] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n   vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

THREE.ShaderChunk["lightmap_fragment"] = "#ifdef USE_LIGHTMAP\n\n  outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif";

THREE.ShaderChunk["shadowmap_pars_vertex"] = "#ifdef USE_SHADOWMAP\n\n varying vec4 vShadowCoord[ MAX_SHADOWS ];\n uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

THREE.ShaderChunk["color_fragment"] = "#ifdef USE_COLOR\n\n    diffuseColor.rgb *= vColor;\n\n#endif";

THREE.ShaderChunk["morphtarget_vertex"] = "#ifdef USE_MORPHTARGETS\n\n vec3 morphed = vec3( 0.0 );\n   morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n  morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n  morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n  morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n    #ifndef USE_MORPHNORMALS\n\n    morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n  morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n  morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n  morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n    #endif\n\n  morphed += position;\n\n#endif";

THREE.ShaderChunk["envmap_vertex"] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n       vReflect = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n       vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n #endif\n\n#endif\n";

THREE.ShaderChunk["shadowmap_fragment"] = "#ifdef USE_SHADOWMAP\n\n    #ifdef SHADOWMAP_DEBUG\n\n      vec3 frustumColors[3];\n        frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n     frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n     frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n   #endif\n\n  #ifdef SHADOWMAP_CASCADE\n\n        int inFrustumCount = 0;\n\n #endif\n\n  float fDepth;\n vec3 shadowColor = vec3( 1.0 );\n\n for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n       vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n             // if ( something && something ) breaks ATI OpenGL shader compiler\n                // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n               // don't shadow pixels outside of light frustum\n               // use just first frustum (for cascades)\n              // don't shadow pixels behind far plane of light frustum\n\n        #ifdef SHADOWMAP_CASCADE\n\n            inFrustumCount += int( inFrustum );\n           bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n       #else\n\n           bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        #endif\n\n      bool frustumTest = all( frustumTestVec );\n\n       if ( frustumTest ) {\n\n            shadowCoord.z += shadowBias[ i ];\n\n           #if defined( SHADOWMAP_TYPE_PCF )\n\n                       // Percentage-close filtering\n                     // (9 pixel kernel)\n                       // http://fabiensanglard.net/shadowmappingPCF/\n\n              float shadow = 0.0;\n\n     /*\n                        // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n                        // must enroll loop manually\n\n                for ( float y = -1.25; y <= 1.25; y += 1.25 )\n                 for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n                     vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                              // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n                               //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n                       float fDepth = unpackDepth( rgbaDepth );\n\n                        if ( fDepth < shadowCoord.z )\n                         shadow += 1.0;\n\n              }\n\n               shadow /= 9.0;\n\n      */\n\n              const float shadowDelta = 1.0 / 9.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n              float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.25 * xPixelOffset;\n             float dy0 = -1.25 * yPixelOffset;\n             float dx1 = 1.25 * xPixelOffset;\n              float dy1 = 1.25 * yPixelOffset;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n               if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n               if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n               if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n               if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n              if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n               if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n               if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n               if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n               if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n         #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n                        // Percentage-close filtering\n                     // (9 pixel kernel)\n                       // http://fabiensanglard.net/shadowmappingPCF/\n\n              float shadow = 0.0;\n\n             float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n              float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.0 * xPixelOffset;\n              float dy0 = -1.0 * yPixelOffset;\n              float dx1 = 1.0 * xPixelOffset;\n               float dy1 = 1.0 * yPixelOffset;\n\n             mat3 shadowKernel;\n                mat3 depthKernel;\n\n               depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n               depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n              vec3 shadowZ = vec3( shadowCoord.z );\n             shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n               shadowKernel[0] *= vec3(0.25);\n\n              shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n               shadowKernel[1] *= vec3(0.25);\n\n              shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n               shadowKernel[2] *= vec3(0.25);\n\n              vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n             shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n             shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n               vec4 shadowValues;\n                shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n                shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n                shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n                shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n              shadow = dot( shadowValues, vec4( 1.0 ) );\n\n              shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n         #else\n\n               vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n             float fDepth = unpackDepth( rgbaDepth );\n\n                if ( fDepth < shadowCoord.z )\n\n       // spot with multiple shadows is darker\n\n                 shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n      // spot with multiple shadows has the same color as single shadow spot\n\n      //                  shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n          #endif\n\n      }\n\n\n     #ifdef SHADOWMAP_DEBUG\n\n          #ifdef SHADOWMAP_CASCADE\n\n                if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n            #else\n\n               if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n           #endif\n\n      #endif\n\n  }\n\n   // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n shadowColor = inputToLinear( shadowColor );\n\n outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

THREE.ShaderChunk["worldpos_vertex"] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n   #ifdef USE_SKINNING\n\n     vec4 worldPosition = modelMatrix * skinned;\n\n #elif defined( USE_MORPHTARGETS )\n\n       vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n       vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n   #endif\n\n#endif\n";

THREE.ShaderChunk["shadowmap_pars_fragment"] = "#ifdef USE_SHADOWMAP\n\n   uniform sampler2D shadowMap[ MAX_SHADOWS ];\n   uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n  uniform float shadowDarkness[ MAX_SHADOWS ];\n  uniform float shadowBias[ MAX_SHADOWS ];\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n   float unpackDepth( const in vec4 rgba_depth ) {\n\n     const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n        float depth = dot( rgba_depth, bit_shift );\n       return depth;\n\n   }\n\n#endif";

THREE.ShaderChunk["skinning_pars_vertex"] = "#ifdef USE_SKINNING\n\n   uniform mat4 bindMatrix;\n  uniform mat4 bindMatrixInverse;\n\n #ifdef BONE_TEXTURE\n\n     uniform sampler2D boneTexture;\n        uniform int boneTextureWidth;\n     uniform int boneTextureHeight;\n\n      mat4 getBoneMatrix( const in float i ) {\n\n            float j = i * 4.0;\n            float x = mod( j, float( boneTextureWidth ) );\n            float y = floor( j / float( boneTextureWidth ) );\n\n           float dx = 1.0 / float( boneTextureWidth );\n           float dy = 1.0 / float( boneTextureHeight );\n\n            y = dy * ( y + 0.5 );\n\n           vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n          vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n          vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n          vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n            mat4 bone = mat4( v1, v2, v3, v4 );\n\n         return bone;\n\n        }\n\n   #else\n\n       uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n       mat4 getBoneMatrix( const in float i ) {\n\n            mat4 bone = boneGlobalMatrices[ int(i) ];\n         return bone;\n\n        }\n\n   #endif\n\n#endif\n";

THREE.ShaderChunk["logdepthbuf_pars_fragment"] = "#ifdef USE_LOGDEPTHBUF\n\n   uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n      #extension GL_EXT_frag_depth : enable\n     varying float vFragDepth;\n\n   #endif\n\n#endif";

THREE.ShaderChunk["alphamap_fragment"] = "#ifdef USE_ALPHAMAP\n\n  diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

THREE.ShaderChunk["alphamap_pars_fragment"] = "#ifdef USE_ALPHAMAP\n\n uniform sampler2D alphaMap;\n\n#endif\n";

THREE.UniformsUtils = {
    merge: function(uniforms) {
        var merged = {};
        for (var u = 0; u < uniforms.length; u++) {
            var tmp = this.clone(uniforms[u]);
            for (var p in tmp) {
                merged[p] = tmp[p];
            }
        }
        return merged;
    },
    clone: function(uniforms_src) {
        var uniforms_dst = {};
        for (var u in uniforms_src) {
            uniforms_dst[u] = {};
            for (var p in uniforms_src[u]) {
                var parameter_src = uniforms_src[u][p];
                if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) {
                    uniforms_dst[u][p] = parameter_src.clone();
                } else if (parameter_src instanceof Array) {
                    uniforms_dst[u][p] = parameter_src.slice();
                } else {
                    uniforms_dst[u][p] = parameter_src;
                }
            }
        }
        return uniforms_dst;
    }
};

THREE.UniformsLib = {
    common: {
        diffuse: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        },
        lightMap: {
            type: "t",
            value: null
        },
        specularMap: {
            type: "t",
            value: null
        },
        alphaMap: {
            type: "t",
            value: null
        },
        envMap: {
            type: "t",
            value: null
        },
        flipEnvMap: {
            type: "f",
            value: -1
        },
        reflectivity: {
            type: "f",
            value: 1
        },
        refractionRatio: {
            type: "f",
            value: .98
        },
        morphTargetInfluences: {
            type: "f",
            value: 0
        }
    },
    bump: {
        bumpMap: {
            type: "t",
            value: null
        },
        bumpScale: {
            type: "f",
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            type: "t",
            value: null
        },
        normalScale: {
            type: "v2",
            value: new THREE.Vector2(1, 1)
        }
    },
    fog: {
        fogDensity: {
            type: "f",
            value: 25e-5
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            type: "fv",
            value: []
        },
        directionalLightDirection: {
            type: "fv",
            value: []
        },
        directionalLightColor: {
            type: "fv",
            value: []
        },
        hemisphereLightDirection: {
            type: "fv",
            value: []
        },
        hemisphereLightSkyColor: {
            type: "fv",
            value: []
        },
        hemisphereLightGroundColor: {
            type: "fv",
            value: []
        },
        pointLightColor: {
            type: "fv",
            value: []
        },
        pointLightPosition: {
            type: "fv",
            value: []
        },
        pointLightDistance: {
            type: "fv1",
            value: []
        },
        pointLightDecay: {
            type: "fv1",
            value: []
        },
        spotLightColor: {
            type: "fv",
            value: []
        },
        spotLightPosition: {
            type: "fv",
            value: []
        },
        spotLightDirection: {
            type: "fv",
            value: []
        },
        spotLightDistance: {
            type: "fv1",
            value: []
        },
        spotLightAngleCos: {
            type: "fv1",
            value: []
        },
        spotLightExponent: {
            type: "fv1",
            value: []
        },
        spotLightDecay: {
            type: "fv1",
            value: []
        }
    },
    particle: {
        psColor: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        size: {
            type: "f",
            value: 1
        },
        scale: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        },
        fogDensity: {
            type: "f",
            value: 25e-5
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    shadowmap: {
        shadowMap: {
            type: "tv",
            value: []
        },
        shadowMapSize: {
            type: "v2v",
            value: []
        },
        shadowBias: {
            type: "fv1",
            value: []
        },
        shadowDarkness: {
            type: "fv1",
            value: []
        },
        shadowMatrix: {
            type: "m4v",
            value: []
        }
    }
};

THREE.ShaderLib = {
    basic: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib["common"], THREE.UniformsLib["fog"], THREE.UniformsLib["shadowmap"] ]),
        vertexShader: [ THREE.ShaderChunk["common"], THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["skinbase_vertex"], "   #ifdef USE_ENVMAP", THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "   #endif", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "   vec3 outgoingLight = vec3( 0.0 );", "   vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], "   outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "   gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}" ].join("\n")
    },
    lambert: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib["common"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        } ]),
        vertexShader: [ "#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "   varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_lambert_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_lambert_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "   varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "   vec3 outgoingLight = vec3( 0.0 );", "   vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], "   #ifdef DOUBLE_SIDED", "       if ( gl_FrontFacing )", "           outgoingLight += diffuseColor.rgb * vLightFront + emissive;", "       else", "           outgoingLight += diffuseColor.rgb * vLightBack + emissive;", "   #else", "       outgoingLight += diffuseColor.rgb * vLightFront + emissive;", "   #endif", THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "   gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}" ].join("\n")
    },
    phong: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib["common"], THREE.UniformsLib["bump"], THREE.UniformsLib["normalmap"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            specular: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            shininess: {
                type: "f",
                value: 30
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        } ]),
        vertexShader: [ "#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "   varying vec3 vNormal;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_phong_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "#ifndef FLAT_SHADED", "   vNormal = normalize( transformedNormal );", "#endif", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "   vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_phong_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}" ].join("\n"),
        fragmentShader: [ "#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["lights_phong_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["bumpmap_pars_fragment"], THREE.ShaderChunk["normalmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "   vec3 outgoingLight = vec3( 0.0 );", "   vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["lights_phong_fragment"], THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "   gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}" ].join("\n")
    },
    particle_basic: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib["particle"], THREE.UniformsLib["shadowmap"] ]),
        vertexShader: [ "uniform float size;", "uniform float scale;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "   vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "   #ifdef USE_SIZEATTENUATION", "       gl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "   #else", "       gl_PointSize = size;", "   #endif", "   gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 psColor;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_particle_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "   vec3 outgoingLight = vec3( 0.0 );", "   vec4 diffuseColor = vec4( psColor, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_particle_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphatest_fragment"], "   outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["fog_fragment"], "   gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}" ].join("\n")
    },
    dashed: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib["common"], THREE.UniformsLib["fog"], {
            scale: {
                type: "f",
                value: 1
            },
            dashSize: {
                type: "f",
                value: 1
            },
            totalSize: {
                type: "f",
                value: 2
            }
        } ]),
        vertexShader: [ "uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "   vLineDistance = scale * lineDistance;", "   vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "   gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "   if ( mod( vLineDistance, totalSize ) > dashSize ) {", "       discard;", "   }", "   vec3 outgoingLight = vec3( 0.0 );", "   vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["color_fragment"], "   outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["fog_fragment"], "   gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}" ].join("\n")
    },
    depth: {
        uniforms: {
            mNear: {
                type: "f",
                value: 1
            },
            mFar: {
                type: "f",
                value: 2e3
            },
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: [ THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}" ].join("\n"),
        fragmentShader: [ "uniform float mNear;", "uniform float mFar;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "   #ifdef USE_LOGDEPTHBUF_EXT", "       float depth = gl_FragDepthEXT / gl_FragCoord.w;", "   #else", "       float depth = gl_FragCoord.z / gl_FragCoord.w;", "   #endif", "   float color = 1.0 - smoothstep( mNear, mFar, depth );", "   gl_FragColor = vec4( vec3( color ), opacity );", "}" ].join("\n")
    },
    normal: {
        uniforms: {
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: [ "varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "   vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}" ].join("\n"),
        fragmentShader: [ "uniform float opacity;", "varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "   gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], "}" ].join("\n")
    },
    cube: {
        uniforms: {
            tCube: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: [ "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "   vWorldPosition = transformDirection( position, modelMatrix );", "   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}" ].join("\n"),
        fragmentShader: [ "uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "   gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk["logdepthbuf_fragment"], "}" ].join("\n")
    },
    equirect: {
        uniforms: {
            tEquirect: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: [ "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "   vWorldPosition = transformDirection( position, modelMatrix );", "   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}" ].join("\n"),
        fragmentShader: [ "uniform sampler2D tEquirect;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "vec3 direction = normalize( vWorldPosition );", "vec2 sampleUV;", "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );", "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "gl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk["logdepthbuf_fragment"], "}" ].join("\n")
    },
    depthRGBA: {
        uniforms: {},
        vertexShader: [ THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}" ].join("\n"),
        fragmentShader: [ THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "vec4 pack_depth( const in float depth ) {", "   const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "   const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "   vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "   res -= res.xxyz * bit_mask;", "   return res;", "}", "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "   #ifdef USE_LOGDEPTHBUF_EXT", "       gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "   #else", "       gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "   #endif", "}" ].join("\n")
    }
};

THREE.WebGLRenderer = function(parameters) {
    console.log("THREE.WebGLRenderer", THREE.REVISION);
    parameters = parameters || {};
    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement("canvas"), _context = parameters.context !== undefined ? parameters.context : null, pixelRatio = 1, _precision = parameters.precision !== undefined ? parameters.precision : "highp", _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false, _clearColor = new THREE.Color(0), _clearAlpha = 0;
    var lights = [];
    var _webglObjects = {};
    var _webglObjectsImmediate = [];
    var opaqueObjects = [];
    var transparentObjects = [];
    var sprites = [];
    var lensFlares = [];
    this.domElement = _canvas;
    this.context = null;
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.gammaFactor = 2;
    this.gammaInput = false;
    this.gammaOutput = false;
    this.shadowMapEnabled = false;
    this.shadowMapType = THREE.PCFShadowMap;
    this.shadowMapCullFace = THREE.CullFaceFront;
    this.shadowMapDebug = false;
    this.shadowMapCascade = false;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    this.autoScaleCubemaps = true;
    this.info = {
        memory: {
            programs: 0,
            geometries: 0,
            textures: 0
        },
        render: {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        }
    };
    var _this = this, _programs = [], _currentProgram = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = "", _currentCamera = null, _usedTextureUnits = 0, _viewportX = 0, _viewportY = 0, _viewportWidth = _canvas.width, _viewportHeight = _canvas.height, _currentWidth = 0, _currentHeight = 0, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4(), _vector3 = new THREE.Vector3(), _direction = new THREE.Vector3(), _lightsNeedUpdate = true, _lights = {
        ambient: [ 0, 0, 0 ],
        directional: {
            length: 0,
            colors: [],
            positions: []
        },
        point: {
            length: 0,
            colors: [],
            positions: [],
            distances: [],
            decays: []
        },
        spot: {
            length: 0,
            colors: [],
            positions: [],
            distances: [],
            directions: [],
            anglesCos: [],
            exponents: [],
            decays: []
        },
        hemi: {
            length: 0,
            skyColors: [],
            groundColors: [],
            positions: []
        }
    };
    var _gl;
    try {
        var attributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer
        };
        _gl = _context || _canvas.getContext("webgl", attributes) || _canvas.getContext("experimental-webgl", attributes);
        if (_gl === null) {
            if (_canvas.getContext("webgl") !== null) {
                throw "Error creating WebGL context with your selected attributes.";
            } else {
                throw "Error creating WebGL context.";
            }
        }
        _canvas.addEventListener("webglcontextlost", function(event) {
            event.preventDefault();
            resetGLState();
            setDefaultGLState();
            _webglObjects = {};
        }, false);
    } catch (error) {
        THREE.error("THREE.WebGLRenderer: " + error);
    }
    var state = new THREE.WebGLState(_gl, paramThreeToGL);
    if (_gl.getShaderPrecisionFormat === undefined) {
        _gl.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            };
        };
    }
    var extensions = new THREE.WebGLExtensions(_gl);
    extensions.get("OES_texture_float");
    extensions.get("OES_texture_float_linear");
    extensions.get("OES_texture_half_float");
    extensions.get("OES_texture_half_float_linear");
    extensions.get("OES_standard_derivatives");
    if (_logarithmicDepthBuffer) {
        extensions.get("EXT_frag_depth");
    }
    var glClearColor = function(r, g, b, a) {
        if (_premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
        }
        _gl.clearColor(r, g, b, a);
    };
    var setDefaultGLState = function() {
        _gl.clearColor(0, 0, 0, 1);
        _gl.clearDepth(1);
        _gl.clearStencil(0);
        _gl.enable(_gl.DEPTH_TEST);
        _gl.depthFunc(_gl.LEQUAL);
        _gl.frontFace(_gl.CCW);
        _gl.cullFace(_gl.BACK);
        _gl.enable(_gl.CULL_FACE);
        _gl.enable(_gl.BLEND);
        _gl.blendEquation(_gl.FUNC_ADD);
        _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);
        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
    };
    var resetGLState = function() {
        _currentProgram = null;
        _currentCamera = null;
        _currentGeometryProgram = "";
        _currentMaterialId = -1;
        _lightsNeedUpdate = true;
        state.reset();
    };
    setDefaultGLState();
    this.context = _gl;
    this.state = state;
    var _maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);
    var _maxVertexTextures = _gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    var _maxTextureSize = _gl.getParameter(_gl.MAX_TEXTURE_SIZE);
    var _maxCubemapSize = _gl.getParameter(_gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    var _supportsVertexTextures = _maxVertexTextures > 0;
    var _supportsBoneTextures = _supportsVertexTextures && extensions.get("OES_texture_float");
    var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_FLOAT);
    var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT);
    var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT);
    var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT);
    var getCompressedTextureFormats = function() {
        var array;
        return function() {
            if (array !== undefined) {
                return array;
            }
            array = [];
            if (extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc")) {
                var formats = _gl.getParameter(_gl.COMPRESSED_TEXTURE_FORMATS);
                for (var i = 0; i < formats.length; i++) {
                    array.push(formats[i]);
                }
            }
            return array;
        };
    }();
    var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
    var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;
    if (_precision === "highp" && !highpAvailable) {
        if (mediumpAvailable) {
            _precision = "mediump";
            THREE.warn("THREE.WebGLRenderer: highp not supported, using mediump.");
        } else {
            _precision = "lowp";
            THREE.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp.");
        }
    }
    if (_precision === "mediump" && !mediumpAvailable) {
        _precision = "lowp";
        THREE.warn("THREE.WebGLRenderer: mediump not supported, using lowp.");
    }
    var shadowMapPlugin = new THREE.ShadowMapPlugin(this, lights, _webglObjects, _webglObjectsImmediate);
    var spritePlugin = new THREE.SpritePlugin(this, sprites);
    var lensFlarePlugin = new THREE.LensFlarePlugin(this, lensFlares);
    this.getContext = function() {
        return _gl;
    };
    this.forceContextLoss = function() {
        extensions.get("WEBGL_lose_context").loseContext();
    };
    this.supportsVertexTextures = function() {
        return _supportsVertexTextures;
    };
    this.supportsFloatTextures = function() {
        return extensions.get("OES_texture_float");
    };
    this.supportsHalfFloatTextures = function() {
        return extensions.get("OES_texture_half_float");
    };
    this.supportsStandardDerivatives = function() {
        return extensions.get("OES_standard_derivatives");
    };
    this.supportsCompressedTextureS3TC = function() {
        return extensions.get("WEBGL_compressed_texture_s3tc");
    };
    this.supportsCompressedTexturePVRTC = function() {
        return extensions.get("WEBGL_compressed_texture_pvrtc");
    };
    this.supportsBlendMinMax = function() {
        return extensions.get("EXT_blend_minmax");
    };
    this.getMaxAnisotropy = function() {
        var value;
        return function() {
            if (value !== undefined) {
                return value;
            }
            var extension = extensions.get("EXT_texture_filter_anisotropic");
            value = extension !== null ? _gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            return value;
        };
    }();
    this.getPrecision = function() {
        return _precision;
    };
    this.getPixelRatio = function() {
        return pixelRatio;
    };
    this.setPixelRatio = function(value) {
        pixelRatio = value;
    };
    this.setSize = function(width, height, updateStyle) {
        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;
        if (updateStyle !== false) {
            _canvas.style.width = width + "px";
            _canvas.style.height = height + "px";
        }
        this.setViewport(0, 0, width, height);
    };
    this.setViewport = function(x, y, width, height) {
        _viewportX = x * pixelRatio;
        _viewportY = y * pixelRatio;
        _viewportWidth = width * pixelRatio;
        _viewportHeight = height * pixelRatio;
        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
    };
    this.setScissor = function(x, y, width, height) {
        _gl.scissor(x * pixelRatio, y * pixelRatio, width * pixelRatio, height * pixelRatio);
    };
    this.enableScissorTest = function(enable) {
        enable ? _gl.enable(_gl.SCISSOR_TEST) : _gl.disable(_gl.SCISSOR_TEST);
    };
    this.getClearColor = function() {
        return _clearColor;
    };
    this.setClearColor = function(color, alpha) {
        _clearColor.set(color);
        _clearAlpha = alpha !== undefined ? alpha : 1;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
    };
    this.getClearAlpha = function() {
        return _clearAlpha;
    };
    this.setClearAlpha = function(alpha) {
        _clearAlpha = alpha;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
    };
    this.clear = function(color, depth, stencil) {
        var bits = 0;
        if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
        if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
        if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;
        _gl.clear(bits);
    };
    this.clearColor = function() {
        _gl.clear(_gl.COLOR_BUFFER_BIT);
    };
    this.clearDepth = function() {
        _gl.clear(_gl.DEPTH_BUFFER_BIT);
    };
    this.clearStencil = function() {
        _gl.clear(_gl.STENCIL_BUFFER_BIT);
    };
    this.clearTarget = function(renderTarget, color, depth, stencil) {
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
    };
    this.resetGLState = resetGLState;
    function createParticleBuffers(geometry) {
        geometry.__webglVertexBuffer = _gl.createBuffer();
        geometry.__webglColorBuffer = _gl.createBuffer();
        _this.info.memory.geometries++;
    }
    function createLineBuffers(geometry) {
        geometry.__webglVertexBuffer = _gl.createBuffer();
        geometry.__webglColorBuffer = _gl.createBuffer();
        geometry.__webglLineDistanceBuffer = _gl.createBuffer();
        _this.info.memory.geometries++;
    }
    function createMeshBuffers(geometryGroup) {
        geometryGroup.__webglVertexBuffer = _gl.createBuffer();
        geometryGroup.__webglNormalBuffer = _gl.createBuffer();
        geometryGroup.__webglTangentBuffer = _gl.createBuffer();
        geometryGroup.__webglColorBuffer = _gl.createBuffer();
        geometryGroup.__webglUVBuffer = _gl.createBuffer();
        geometryGroup.__webglUV2Buffer = _gl.createBuffer();
        geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
        geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();
        geometryGroup.__webglFaceBuffer = _gl.createBuffer();
        geometryGroup.__webglLineBuffer = _gl.createBuffer();
        var numMorphTargets = geometryGroup.numMorphTargets;
        if (numMorphTargets) {
            geometryGroup.__webglMorphTargetsBuffers = [];
            for (var m = 0, ml = numMorphTargets; m < ml; m++) {
                geometryGroup.__webglMorphTargetsBuffers.push(_gl.createBuffer());
            }
        }
        var numMorphNormals = geometryGroup.numMorphNormals;
        if (numMorphNormals) {
            geometryGroup.__webglMorphNormalsBuffers = [];
            for (var m = 0, ml = numMorphNormals; m < ml; m++) {
                geometryGroup.__webglMorphNormalsBuffers.push(_gl.createBuffer());
            }
        }
        _this.info.memory.geometries++;
    }
    var onObjectRemoved = function(event) {
        var object = event.target;
        object.traverse(function(child) {
            child.removeEventListener("remove", onObjectRemoved);
            removeObject(child);
        });
    };
    var onGeometryDispose = function(event) {
        var geometry = event.target;
        geometry.removeEventListener("dispose", onGeometryDispose);
        deallocateGeometry(geometry);
    };
    var onTextureDispose = function(event) {
        var texture = event.target;
        texture.removeEventListener("dispose", onTextureDispose);
        deallocateTexture(texture);
        _this.info.memory.textures--;
    };
    var onRenderTargetDispose = function(event) {
        var renderTarget = event.target;
        renderTarget.removeEventListener("dispose", onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        _this.info.memory.textures--;
    };
    var onMaterialDispose = function(event) {
        var material = event.target;
        material.removeEventListener("dispose", onMaterialDispose);
        deallocateMaterial(material);
    };
    var deleteBuffers = function(geometry) {
        var buffers = [ "__webglVertexBuffer", "__webglNormalBuffer", "__webglTangentBuffer", "__webglColorBuffer", "__webglUVBuffer", "__webglUV2Buffer", "__webglSkinIndicesBuffer", "__webglSkinWeightsBuffer", "__webglFaceBuffer", "__webglLineBuffer", "__webglLineDistanceBuffer" ];
        for (var i = 0, l = buffers.length; i < l; i++) {
            var name = buffers[i];
            if (geometry[name] !== undefined) {
                _gl.deleteBuffer(geometry[name]);
                delete geometry[name];
            }
        }
        if (geometry.__webglCustomAttributesList !== undefined) {
            for (var name in geometry.__webglCustomAttributesList) {
                _gl.deleteBuffer(geometry.__webglCustomAttributesList[name].buffer);
            }
            delete geometry.__webglCustomAttributesList;
        }
        _this.info.memory.geometries--;
    };
    var deallocateGeometry = function(geometry) {
        delete geometry.__webglInit;
        if (geometry instanceof THREE.BufferGeometry) {
            for (var name in geometry.attributes) {
                var attribute = geometry.attributes[name];
                if (attribute.buffer !== undefined) {
                    _gl.deleteBuffer(attribute.buffer);
                    delete attribute.buffer;
                }
            }
            _this.info.memory.geometries--;
        } else {
            var geometryGroupsList = geometryGroups[geometry.id];
            if (geometryGroupsList !== undefined) {
                for (var i = 0, l = geometryGroupsList.length; i < l; i++) {
                    var geometryGroup = geometryGroupsList[i];
                    if (geometryGroup.numMorphTargets !== undefined) {
                        for (var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++) {
                            _gl.deleteBuffer(geometryGroup.__webglMorphTargetsBuffers[m]);
                        }
                        delete geometryGroup.__webglMorphTargetsBuffers;
                    }
                    if (geometryGroup.numMorphNormals !== undefined) {
                        for (var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++) {
                            _gl.deleteBuffer(geometryGroup.__webglMorphNormalsBuffers[m]);
                        }
                        delete geometryGroup.__webglMorphNormalsBuffers;
                    }
                    deleteBuffers(geometryGroup);
                }
                delete geometryGroups[geometry.id];
            } else {
                deleteBuffers(geometry);
            }
        }
        _currentGeometryProgram = "";
    };
    var deallocateTexture = function(texture) {
        if (texture.image && texture.image.__webglTextureCube) {
            _gl.deleteTexture(texture.image.__webglTextureCube);
            delete texture.image.__webglTextureCube;
        } else {
            if (texture.__webglInit === undefined) return;
            _gl.deleteTexture(texture.__webglTexture);
            delete texture.__webglTexture;
            delete texture.__webglInit;
        }
    };
    var deallocateRenderTarget = function(renderTarget) {
        if (!renderTarget || renderTarget.__webglTexture === undefined) return;
        _gl.deleteTexture(renderTarget.__webglTexture);
        delete renderTarget.__webglTexture;
        if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
            for (var i = 0; i < 6; i++) {
                _gl.deleteFramebuffer(renderTarget.__webglFramebuffer[i]);
                _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer[i]);
            }
        } else {
            _gl.deleteFramebuffer(renderTarget.__webglFramebuffer);
            _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer);
        }
        delete renderTarget.__webglFramebuffer;
        delete renderTarget.__webglRenderbuffer;
    };
    var deallocateMaterial = function(material) {
        var program = material.program.program;
        if (program === undefined) return;
        material.program = undefined;
        var i, il, programInfo;
        var deleteProgram = false;
        for (i = 0, il = _programs.length; i < il; i++) {
            programInfo = _programs[i];
            if (programInfo.program === program) {
                programInfo.usedTimes--;
                if (programInfo.usedTimes === 0) {
                    deleteProgram = true;
                }
                break;
            }
        }
        if (deleteProgram === true) {
            var newPrograms = [];
            for (i = 0, il = _programs.length; i < il; i++) {
                programInfo = _programs[i];
                if (programInfo.program !== program) {
                    newPrograms.push(programInfo);
                }
            }
            _programs = newPrograms;
            _gl.deleteProgram(program);
            _this.info.memory.programs--;
        }
    };
    function initCustomAttributes(object) {
        var geometry = object.geometry;
        var material = object.material;
        var nvertices = geometry.vertices.length;
        if (material.attributes) {
            if (geometry.__webglCustomAttributesList === undefined) {
                geometry.__webglCustomAttributesList = [];
            }
            for (var name in material.attributes) {
                var attribute = material.attributes[name];
                if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
                    attribute.__webglInitialized = true;
                    var size = 1;
                    if (attribute.type === "v2") size = 2; else if (attribute.type === "v3") size = 3; else if (attribute.type === "v4") size = 4; else if (attribute.type === "c") size = 3;
                    attribute.size = size;
                    attribute.array = new Float32Array(nvertices * size);
                    attribute.buffer = _gl.createBuffer();
                    attribute.buffer.belongsToAttribute = name;
                    attribute.needsUpdate = true;
                }
                geometry.__webglCustomAttributesList.push(attribute);
            }
        }
    }
    function initParticleBuffers(geometry, object) {
        var nvertices = geometry.vertices.length;
        geometry.__vertexArray = new Float32Array(nvertices * 3);
        geometry.__colorArray = new Float32Array(nvertices * 3);
        geometry.__webglParticleCount = nvertices;
        initCustomAttributes(object);
    }
    function initLineBuffers(geometry, object) {
        var nvertices = geometry.vertices.length;
        geometry.__vertexArray = new Float32Array(nvertices * 3);
        geometry.__colorArray = new Float32Array(nvertices * 3);
        geometry.__lineDistanceArray = new Float32Array(nvertices * 1);
        geometry.__webglLineCount = nvertices;
        initCustomAttributes(object);
    }
    function initMeshBuffers(geometryGroup, object) {
        var geometry = object.geometry, faces3 = geometryGroup.faces3, nvertices = faces3.length * 3, ntris = faces3.length * 1, nlines = faces3.length * 3, material = getBufferMaterial(object, geometryGroup);
        geometryGroup.__vertexArray = new Float32Array(nvertices * 3);
        geometryGroup.__normalArray = new Float32Array(nvertices * 3);
        geometryGroup.__colorArray = new Float32Array(nvertices * 3);
        geometryGroup.__uvArray = new Float32Array(nvertices * 2);
        if (geometry.faceVertexUvs.length > 1) {
            geometryGroup.__uv2Array = new Float32Array(nvertices * 2);
        }
        if (geometry.hasTangents) {
            geometryGroup.__tangentArray = new Float32Array(nvertices * 4);
        }
        if (object.geometry.skinWeights.length && object.geometry.skinIndices.length) {
            geometryGroup.__skinIndexArray = new Float32Array(nvertices * 4);
            geometryGroup.__skinWeightArray = new Float32Array(nvertices * 4);
        }
        var UintArray = extensions.get("OES_element_index_uint") !== null && ntris > 21845 ? Uint32Array : Uint16Array;
        geometryGroup.__typeArray = UintArray;
        geometryGroup.__faceArray = new UintArray(ntris * 3);
        geometryGroup.__lineArray = new UintArray(nlines * 2);
        var numMorphTargets = geometryGroup.numMorphTargets;
        if (numMorphTargets) {
            geometryGroup.__morphTargetsArrays = [];
            for (var m = 0, ml = numMorphTargets; m < ml; m++) {
                geometryGroup.__morphTargetsArrays.push(new Float32Array(nvertices * 3));
            }
        }
        var numMorphNormals = geometryGroup.numMorphNormals;
        if (numMorphNormals) {
            geometryGroup.__morphNormalsArrays = [];
            for (var m = 0, ml = numMorphNormals; m < ml; m++) {
                geometryGroup.__morphNormalsArrays.push(new Float32Array(nvertices * 3));
            }
        }
        geometryGroup.__webglFaceCount = ntris * 3;
        geometryGroup.__webglLineCount = nlines * 2;
        if (material.attributes) {
            if (geometryGroup.__webglCustomAttributesList === undefined) {
                geometryGroup.__webglCustomAttributesList = [];
            }
            for (var name in material.attributes) {
                var originalAttribute = material.attributes[name];
                var attribute = {};
                for (var property in originalAttribute) {
                    attribute[property] = originalAttribute[property];
                }
                if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
                    attribute.__webglInitialized = true;
                    var size = 1;
                    if (attribute.type === "v2") size = 2; else if (attribute.type === "v3") size = 3; else if (attribute.type === "v4") size = 4; else if (attribute.type === "c") size = 3;
                    attribute.size = size;
                    attribute.array = new Float32Array(nvertices * size);
                    attribute.buffer = _gl.createBuffer();
                    attribute.buffer.belongsToAttribute = name;
                    originalAttribute.needsUpdate = true;
                    attribute.__original = originalAttribute;
                }
                geometryGroup.__webglCustomAttributesList.push(attribute);
            }
        }
        geometryGroup.__inittedArrays = true;
    }
    function getBufferMaterial(object, geometryGroup) {
        return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[geometryGroup.materialIndex] : object.material;
    }
    function materialNeedsFaceNormals(material) {
        return material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading;
    }
    function setParticleBuffers(geometry, hint, object) {
        var v, c, vertex, offset, color, vertices = geometry.vertices, vl = vertices.length, colors = geometry.colors, cl = colors.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, customAttributes = geometry.__webglCustomAttributesList, i, il, ca, cal, value, customAttribute;
        if (dirtyVertices) {
            for (v = 0; v < vl; v++) {
                vertex = vertices[v];
                offset = v * 3;
                vertexArray[offset] = vertex.x;
                vertexArray[offset + 1] = vertex.y;
                vertexArray[offset + 2] = vertex.z;
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
        }
        if (dirtyColors) {
            for (c = 0; c < cl; c++) {
                color = colors[c];
                offset = c * 3;
                colorArray[offset] = color.r;
                colorArray[offset + 1] = color.g;
                colorArray[offset + 2] = color.b;
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
        }
        if (customAttributes) {
            for (i = 0, il = customAttributes.length; i < il; i++) {
                customAttribute = customAttributes[i];
                if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices")) {
                    cal = customAttribute.value.length;
                    offset = 0;
                    if (customAttribute.size === 1) {
                        for (ca = 0; ca < cal; ca++) {
                            customAttribute.array[ca] = customAttribute.value[ca];
                        }
                    } else if (customAttribute.size === 2) {
                        for (ca = 0; ca < cal; ca++) {
                            value = customAttribute.value[ca];
                            customAttribute.array[offset] = value.x;
                            customAttribute.array[offset + 1] = value.y;
                            offset += 2;
                        }
                    } else if (customAttribute.size === 3) {
                        if (customAttribute.type === "c") {
                            for (ca = 0; ca < cal; ca++) {
                                value = customAttribute.value[ca];
                                customAttribute.array[offset] = value.r;
                                customAttribute.array[offset + 1] = value.g;
                                customAttribute.array[offset + 2] = value.b;
                                offset += 3;
                            }
                        } else {
                            for (ca = 0; ca < cal; ca++) {
                                value = customAttribute.value[ca];
                                customAttribute.array[offset] = value.x;
                                customAttribute.array[offset + 1] = value.y;
                                customAttribute.array[offset + 2] = value.z;
                                offset += 3;
                            }
                        }
                    } else if (customAttribute.size === 4) {
                        for (ca = 0; ca < cal; ca++) {
                            value = customAttribute.value[ca];
                            customAttribute.array[offset] = value.x;
                            customAttribute.array[offset + 1] = value.y;
                            customAttribute.array[offset + 2] = value.z;
                            customAttribute.array[offset + 3] = value.w;
                            offset += 4;
                        }
                    }
                }
                _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
                _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
                customAttribute.needsUpdate = false;
            }
        }
    }
    function setLineBuffers(geometry, hint) {
        var v, c, d, vertex, offset, color, vertices = geometry.vertices, colors = geometry.colors, lineDistances = geometry.lineDistances, vl = vertices.length, cl = colors.length, dl = lineDistances.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, lineDistanceArray = geometry.__lineDistanceArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyLineDistances = geometry.lineDistancesNeedUpdate, customAttributes = geometry.__webglCustomAttributesList, i, il, ca, cal, value, customAttribute;
        if (dirtyVertices) {
            for (v = 0; v < vl; v++) {
                vertex = vertices[v];
                offset = v * 3;
                vertexArray[offset] = vertex.x;
                vertexArray[offset + 1] = vertex.y;
                vertexArray[offset + 2] = vertex.z;
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
        }
        if (dirtyColors) {
            for (c = 0; c < cl; c++) {
                color = colors[c];
                offset = c * 3;
                colorArray[offset] = color.r;
                colorArray[offset + 1] = color.g;
                colorArray[offset + 2] = color.b;
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
        }
        if (dirtyLineDistances) {
            for (d = 0; d < dl; d++) {
                lineDistanceArray[d] = lineDistances[d];
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, lineDistanceArray, hint);
        }
        if (customAttributes) {
            for (i = 0, il = customAttributes.length; i < il; i++) {
                customAttribute = customAttributes[i];
                if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices")) {
                    offset = 0;
                    cal = customAttribute.value.length;
                    if (customAttribute.size === 1) {
                        for (ca = 0; ca < cal; ca++) {
                            customAttribute.array[ca] = customAttribute.value[ca];
                        }
                    } else if (customAttribute.size === 2) {
                        for (ca = 0; ca < cal; ca++) {
                            value = customAttribute.value[ca];
                            customAttribute.array[offset] = value.x;
                            customAttribute.array[offset + 1] = value.y;
                            offset += 2;
                        }
                    } else if (customAttribute.size === 3) {
                        if (customAttribute.type === "c") {
                            for (ca = 0; ca < cal; ca++) {
                                value = customAttribute.value[ca];
                                customAttribute.array[offset] = value.r;
                                customAttribute.array[offset + 1] = value.g;
                                customAttribute.array[offset + 2] = value.b;
                                offset += 3;
                            }
                        } else {
                            for (ca = 0; ca < cal; ca++) {
                                value = customAttribute.value[ca];
                                customAttribute.array[offset] = value.x;
                                customAttribute.array[offset + 1] = value.y;
                                customAttribute.array[offset + 2] = value.z;
                                offset += 3;
                            }
                        }
                    } else if (customAttribute.size === 4) {
                        for (ca = 0; ca < cal; ca++) {
                            value = customAttribute.value[ca];
                            customAttribute.array[offset] = value.x;
                            customAttribute.array[offset + 1] = value.y;
                            customAttribute.array[offset + 2] = value.z;
                            customAttribute.array[offset + 3] = value.w;
                            offset += 4;
                        }
                    }
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
                    _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
                    customAttribute.needsUpdate = false;
                }
            }
        }
    }
    function setMeshBuffers(geometryGroup, object, hint, dispose, material) {
        if (!geometryGroup.__inittedArrays) {
            return;
        }
        var needsFaceNormals = materialNeedsFaceNormals(material);
        var f, fl, fi, face, vertexNormals, faceNormal, vertexColors, faceColor, vertexTangents, uv, uv2, v1, v2, v3, t1, t2, t3, n1, n2, n3, c1, c2, c3, sw1, sw2, sw3, si1, si2, si3, i, il, vn, uvi, uv2i, vk, vkl, vka, nka, chf, faceVertexNormals, vertexIndex = 0, offset = 0, offset_uv = 0, offset_uv2 = 0, offset_face = 0, offset_normal = 0, offset_tangent = 0, offset_line = 0, offset_color = 0, offset_skin = 0, offset_morphTarget = 0, offset_custom = 0, value, vertexArray = geometryGroup.__vertexArray, uvArray = geometryGroup.__uvArray, uv2Array = geometryGroup.__uv2Array, normalArray = geometryGroup.__normalArray, tangentArray = geometryGroup.__tangentArray, colorArray = geometryGroup.__colorArray, skinIndexArray = geometryGroup.__skinIndexArray, skinWeightArray = geometryGroup.__skinWeightArray, morphTargetsArrays = geometryGroup.__morphTargetsArrays, morphNormalsArrays = geometryGroup.__morphNormalsArrays, customAttributes = geometryGroup.__webglCustomAttributesList, customAttribute, faceArray = geometryGroup.__faceArray, lineArray = geometryGroup.__lineArray, geometry = object.geometry, dirtyVertices = geometry.verticesNeedUpdate, dirtyElements = geometry.elementsNeedUpdate, dirtyUvs = geometry.uvsNeedUpdate, dirtyNormals = geometry.normalsNeedUpdate, dirtyTangents = geometry.tangentsNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyMorphTargets = geometry.morphTargetsNeedUpdate, vertices = geometry.vertices, chunk_faces3 = geometryGroup.faces3, obj_faces = geometry.faces, obj_uvs = geometry.faceVertexUvs[0], obj_uvs2 = geometry.faceVertexUvs[1], obj_skinIndices = geometry.skinIndices, obj_skinWeights = geometry.skinWeights, morphTargets = geometry.morphTargets, morphNormals = geometry.morphNormals;
        if (dirtyVertices) {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                face = obj_faces[chunk_faces3[f]];
                v1 = vertices[face.a];
                v2 = vertices[face.b];
                v3 = vertices[face.c];
                vertexArray[offset] = v1.x;
                vertexArray[offset + 1] = v1.y;
                vertexArray[offset + 2] = v1.z;
                vertexArray[offset + 3] = v2.x;
                vertexArray[offset + 4] = v2.y;
                vertexArray[offset + 5] = v2.z;
                vertexArray[offset + 6] = v3.x;
                vertexArray[offset + 7] = v3.y;
                vertexArray[offset + 8] = v3.z;
                offset += 9;
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
        }
        if (dirtyMorphTargets) {
            for (vk = 0, vkl = morphTargets.length; vk < vkl; vk++) {
                offset_morphTarget = 0;
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                    chf = chunk_faces3[f];
                    face = obj_faces[chf];
                    v1 = morphTargets[vk].vertices[face.a];
                    v2 = morphTargets[vk].vertices[face.b];
                    v3 = morphTargets[vk].vertices[face.c];
                    vka = morphTargetsArrays[vk];
                    vka[offset_morphTarget] = v1.x;
                    vka[offset_morphTarget + 1] = v1.y;
                    vka[offset_morphTarget + 2] = v1.z;
                    vka[offset_morphTarget + 3] = v2.x;
                    vka[offset_morphTarget + 4] = v2.y;
                    vka[offset_morphTarget + 5] = v2.z;
                    vka[offset_morphTarget + 6] = v3.x;
                    vka[offset_morphTarget + 7] = v3.y;
                    vka[offset_morphTarget + 8] = v3.z;
                    if (material.morphNormals) {
                        if (needsFaceNormals) {
                            n1 = morphNormals[vk].faceNormals[chf];
                            n2 = n1;
                            n3 = n1;
                        } else {
                            faceVertexNormals = morphNormals[vk].vertexNormals[chf];
                            n1 = faceVertexNormals.a;
                            n2 = faceVertexNormals.b;
                            n3 = faceVertexNormals.c;
                        }
                        nka = morphNormalsArrays[vk];
                        nka[offset_morphTarget] = n1.x;
                        nka[offset_morphTarget + 1] = n1.y;
                        nka[offset_morphTarget + 2] = n1.z;
                        nka[offset_morphTarget + 3] = n2.x;
                        nka[offset_morphTarget + 4] = n2.y;
                        nka[offset_morphTarget + 5] = n2.z;
                        nka[offset_morphTarget + 6] = n3.x;
                        nka[offset_morphTarget + 7] = n3.y;
                        nka[offset_morphTarget + 8] = n3.z;
                    }
                    offset_morphTarget += 9;
                }
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[vk]);
                _gl.bufferData(_gl.ARRAY_BUFFER, morphTargetsArrays[vk], hint);
                if (material.morphNormals) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[vk]);
                    _gl.bufferData(_gl.ARRAY_BUFFER, morphNormalsArrays[vk], hint);
                }
            }
        }
        if (obj_skinWeights.length) {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                face = obj_faces[chunk_faces3[f]];
                sw1 = obj_skinWeights[face.a];
                sw2 = obj_skinWeights[face.b];
                sw3 = obj_skinWeights[face.c];
                skinWeightArray[offset_skin] = sw1.x;
                skinWeightArray[offset_skin + 1] = sw1.y;
                skinWeightArray[offset_skin + 2] = sw1.z;
                skinWeightArray[offset_skin + 3] = sw1.w;
                skinWeightArray[offset_skin + 4] = sw2.x;
                skinWeightArray[offset_skin + 5] = sw2.y;
                skinWeightArray[offset_skin + 6] = sw2.z;
                skinWeightArray[offset_skin + 7] = sw2.w;
                skinWeightArray[offset_skin + 8] = sw3.x;
                skinWeightArray[offset_skin + 9] = sw3.y;
                skinWeightArray[offset_skin + 10] = sw3.z;
                skinWeightArray[offset_skin + 11] = sw3.w;
                si1 = obj_skinIndices[face.a];
                si2 = obj_skinIndices[face.b];
                si3 = obj_skinIndices[face.c];
                skinIndexArray[offset_skin] = si1.x;
                skinIndexArray[offset_skin + 1] = si1.y;
                skinIndexArray[offset_skin + 2] = si1.z;
                skinIndexArray[offset_skin + 3] = si1.w;
                skinIndexArray[offset_skin + 4] = si2.x;
                skinIndexArray[offset_skin + 5] = si2.y;
                skinIndexArray[offset_skin + 6] = si2.z;
                skinIndexArray[offset_skin + 7] = si2.w;
                skinIndexArray[offset_skin + 8] = si3.x;
                skinIndexArray[offset_skin + 9] = si3.y;
                skinIndexArray[offset_skin + 10] = si3.z;
                skinIndexArray[offset_skin + 11] = si3.w;
                offset_skin += 12;
            }
            if (offset_skin > 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);
                _gl.bufferData(_gl.ARRAY_BUFFER, skinIndexArray, hint);
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);
                _gl.bufferData(_gl.ARRAY_BUFFER, skinWeightArray, hint);
            }
        }
        if (dirtyColors) {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                face = obj_faces[chunk_faces3[f]];
                vertexColors = face.vertexColors;
                faceColor = face.color;
                if (vertexColors.length === 3 && material.vertexColors === THREE.VertexColors) {
                    c1 = vertexColors[0];
                    c2 = vertexColors[1];
                    c3 = vertexColors[2];
                } else {
                    c1 = faceColor;
                    c2 = faceColor;
                    c3 = faceColor;
                }
                colorArray[offset_color] = c1.r;
                colorArray[offset_color + 1] = c1.g;
                colorArray[offset_color + 2] = c1.b;
                colorArray[offset_color + 3] = c2.r;
                colorArray[offset_color + 4] = c2.g;
                colorArray[offset_color + 5] = c2.b;
                colorArray[offset_color + 6] = c3.r;
                colorArray[offset_color + 7] = c3.g;
                colorArray[offset_color + 8] = c3.b;
                offset_color += 9;
            }
            if (offset_color > 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
                _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
            }
        }
        if (dirtyTangents && geometry.hasTangents) {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                face = obj_faces[chunk_faces3[f]];
                vertexTangents = face.vertexTangents;
                t1 = vertexTangents[0];
                t2 = vertexTangents[1];
                t3 = vertexTangents[2];
                tangentArray[offset_tangent] = t1.x;
                tangentArray[offset_tangent + 1] = t1.y;
                tangentArray[offset_tangent + 2] = t1.z;
                tangentArray[offset_tangent + 3] = t1.w;
                tangentArray[offset_tangent + 4] = t2.x;
                tangentArray[offset_tangent + 5] = t2.y;
                tangentArray[offset_tangent + 6] = t2.z;
                tangentArray[offset_tangent + 7] = t2.w;
                tangentArray[offset_tangent + 8] = t3.x;
                tangentArray[offset_tangent + 9] = t3.y;
                tangentArray[offset_tangent + 10] = t3.z;
                tangentArray[offset_tangent + 11] = t3.w;
                offset_tangent += 12;
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, tangentArray, hint);
        }
        if (dirtyNormals) {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                face = obj_faces[chunk_faces3[f]];
                vertexNormals = face.vertexNormals;
                faceNormal = face.normal;
                if (vertexNormals.length === 3 && needsFaceNormals === false) {
                    for (i = 0; i < 3; i++) {
                        vn = vertexNormals[i];
                        normalArray[offset_normal] = vn.x;
                        normalArray[offset_normal + 1] = vn.y;
                        normalArray[offset_normal + 2] = vn.z;
                        offset_normal += 3;
                    }
                } else {
                    for (i = 0; i < 3; i++) {
                        normalArray[offset_normal] = faceNormal.x;
                        normalArray[offset_normal + 1] = faceNormal.y;
                        normalArray[offset_normal + 2] = faceNormal.z;
                        offset_normal += 3;
                    }
                }
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, normalArray, hint);
        }
        if (dirtyUvs && obj_uvs) {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                fi = chunk_faces3[f];
                uv = obj_uvs[fi];
                if (uv === undefined) continue;
                for (i = 0; i < 3; i++) {
                    uvi = uv[i];
                    uvArray[offset_uv] = uvi.x;
                    uvArray[offset_uv + 1] = uvi.y;
                    offset_uv += 2;
                }
            }
            if (offset_uv > 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
                _gl.bufferData(_gl.ARRAY_BUFFER, uvArray, hint);
            }
        }
        if (dirtyUvs && obj_uvs2) {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                fi = chunk_faces3[f];
                uv2 = obj_uvs2[fi];
                if (uv2 === undefined) continue;
                for (i = 0; i < 3; i++) {
                    uv2i = uv2[i];
                    uv2Array[offset_uv2] = uv2i.x;
                    uv2Array[offset_uv2 + 1] = uv2i.y;
                    offset_uv2 += 2;
                }
            }
            if (offset_uv2 > 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
                _gl.bufferData(_gl.ARRAY_BUFFER, uv2Array, hint);
            }
        }
        if (dirtyElements) {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                faceArray[offset_face] = vertexIndex;
                faceArray[offset_face + 1] = vertexIndex + 1;
                faceArray[offset_face + 2] = vertexIndex + 2;
                offset_face += 3;
                lineArray[offset_line] = vertexIndex;
                lineArray[offset_line + 1] = vertexIndex + 1;
                lineArray[offset_line + 2] = vertexIndex;
                lineArray[offset_line + 3] = vertexIndex + 2;
                lineArray[offset_line + 4] = vertexIndex + 1;
                lineArray[offset_line + 5] = vertexIndex + 2;
                offset_line += 6;
                vertexIndex += 3;
            }
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);
        }
        if (customAttributes) {
            for (i = 0, il = customAttributes.length; i < il; i++) {
                customAttribute = customAttributes[i];
                if (!customAttribute.__original.needsUpdate) continue;
                offset_custom = 0;
                if (customAttribute.size === 1) {
                    if (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices") {
                        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                            face = obj_faces[chunk_faces3[f]];
                            customAttribute.array[offset_custom] = customAttribute.value[face.a];
                            customAttribute.array[offset_custom + 1] = customAttribute.value[face.b];
                            customAttribute.array[offset_custom + 2] = customAttribute.value[face.c];
                            offset_custom += 3;
                        }
                    } else if (customAttribute.boundTo === "faces") {
                        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                            value = customAttribute.value[chunk_faces3[f]];
                            customAttribute.array[offset_custom] = value;
                            customAttribute.array[offset_custom + 1] = value;
                            customAttribute.array[offset_custom + 2] = value;
                            offset_custom += 3;
                        }
                    }
                } else if (customAttribute.size === 2) {
                    if (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices") {
                        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                            face = obj_faces[chunk_faces3[f]];
                            v1 = customAttribute.value[face.a];
                            v2 = customAttribute.value[face.b];
                            v3 = customAttribute.value[face.c];
                            customAttribute.array[offset_custom] = v1.x;
                            customAttribute.array[offset_custom + 1] = v1.y;
                            customAttribute.array[offset_custom + 2] = v2.x;
                            customAttribute.array[offset_custom + 3] = v2.y;
                            customAttribute.array[offset_custom + 4] = v3.x;
                            customAttribute.array[offset_custom + 5] = v3.y;
                            offset_custom += 6;
                        }
                    } else if (customAttribute.boundTo === "faces") {
                        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                            value = customAttribute.value[chunk_faces3[f]];
                            v1 = value;
                            v2 = value;
                            v3 = value;
                            customAttribute.array[offset_custom] = v1.x;
                            customAttribute.array[offset_custom + 1] = v1.y;
                            customAttribute.array[offset_custom + 2] = v2.x;
                            customAttribute.array[offset_custom + 3] = v2.y;
                            customAttribute.array[offset_custom + 4] = v3.x;
                            customAttribute.array[offset_custom + 5] = v3.y;
                            offset_custom += 6;
                        }
                    }
                } else if (customAttribute.size === 3) {
                    var pp;
                    if (customAttribute.type === "c") {
                        pp = [ "r", "g", "b" ];
                    } else {
                        pp = [ "x", "y", "z" ];
                    }
                    if (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices") {
                        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                            face = obj_faces[chunk_faces3[f]];
                            v1 = customAttribute.value[face.a];
                            v2 = customAttribute.value[face.b];
                            v3 = customAttribute.value[face.c];
                            customAttribute.array[offset_custom] = v1[pp[0]];
                            customAttribute.array[offset_custom + 1] = v1[pp[1]];
                            customAttribute.array[offset_custom + 2] = v1[pp[2]];
                            customAttribute.array[offset_custom + 3] = v2[pp[0]];
                            customAttribute.array[offset_custom + 4] = v2[pp[1]];
                            customAttribute.array[offset_custom + 5] = v2[pp[2]];
                            customAttribute.array[offset_custom + 6] = v3[pp[0]];
                            customAttribute.array[offset_custom + 7] = v3[pp[1]];
                            customAttribute.array[offset_custom + 8] = v3[pp[2]];
                            offset_custom += 9;
                        }
                    } else if (customAttribute.boundTo === "faces") {
                        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                            value = customAttribute.value[chunk_faces3[f]];
                            v1 = value;
                            v2 = value;
                            v3 = value;
                            customAttribute.array[offset_custom] = v1[pp[0]];
                            customAttribute.array[offset_custom + 1] = v1[pp[1]];
                            customAttribute.array[offset_custom + 2] = v1[pp[2]];
                            customAttribute.array[offset_custom + 3] = v2[pp[0]];
                            customAttribute.array[offset_custom + 4] = v2[pp[1]];
                            customAttribute.array[offset_custom + 5] = v2[pp[2]];
                            customAttribute.array[offset_custom + 6] = v3[pp[0]];
                            customAttribute.array[offset_custom + 7] = v3[pp[1]];
                            customAttribute.array[offset_custom + 8] = v3[pp[2]];
                            offset_custom += 9;
                        }
                    } else if (customAttribute.boundTo === "faceVertices") {
                        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                            value = customAttribute.value[chunk_faces3[f]];
                            v1 = value[0];
                            v2 = value[1];
                            v3 = value[2];
                            customAttribute.array[offset_custom] = v1[pp[0]];
                            customAttribute.array[offset_custom + 1] = v1[pp[1]];
                            customAttribute.array[offset_custom + 2] = v1[pp[2]];
                            customAttribute.array[offset_custom + 3] = v2[pp[0]];
                            customAttribute.array[offset_custom + 4] = v2[pp[1]];
                            customAttribute.array[offset_custom + 5] = v2[pp[2]];
                            customAttribute.array[offset_custom + 6] = v3[pp[0]];
                            customAttribute.array[offset_custom + 7] = v3[pp[1]];
                            customAttribute.array[offset_custom + 8] = v3[pp[2]];
                            offset_custom += 9;
                        }
                    }
                } else if (customAttribute.size === 4) {
                    if (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices") {
                        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                            face = obj_faces[chunk_faces3[f]];
                            v1 = customAttribute.value[face.a];
                            v2 = customAttribute.value[face.b];
                            v3 = customAttribute.value[face.c];
                            customAttribute.array[offset_custom] = v1.x;
                            customAttribute.array[offset_custom + 1] = v1.y;
                            customAttribute.array[offset_custom + 2] = v1.z;
                            customAttribute.array[offset_custom + 3] = v1.w;
                            customAttribute.array[offset_custom + 4] = v2.x;
                            customAttribute.array[offset_custom + 5] = v2.y;
                            customAttribute.array[offset_custom + 6] = v2.z;
                            customAttribute.array[offset_custom + 7] = v2.w;
                            customAttribute.array[offset_custom + 8] = v3.x;
                            customAttribute.array[offset_custom + 9] = v3.y;
                            customAttribute.array[offset_custom + 10] = v3.z;
                            customAttribute.array[offset_custom + 11] = v3.w;
                            offset_custom += 12;
                        }
                    } else if (customAttribute.boundTo === "faces") {
                        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                            value = customAttribute.value[chunk_faces3[f]];
                            v1 = value;
                            v2 = value;
                            v3 = value;
                            customAttribute.array[offset_custom] = v1.x;
                            customAttribute.array[offset_custom + 1] = v1.y;
                            customAttribute.array[offset_custom + 2] = v1.z;
                            customAttribute.array[offset_custom + 3] = v1.w;
                            customAttribute.array[offset_custom + 4] = v2.x;
                            customAttribute.array[offset_custom + 5] = v2.y;
                            customAttribute.array[offset_custom + 6] = v2.z;
                            customAttribute.array[offset_custom + 7] = v2.w;
                            customAttribute.array[offset_custom + 8] = v3.x;
                            customAttribute.array[offset_custom + 9] = v3.y;
                            customAttribute.array[offset_custom + 10] = v3.z;
                            customAttribute.array[offset_custom + 11] = v3.w;
                            offset_custom += 12;
                        }
                    } else if (customAttribute.boundTo === "faceVertices") {
                        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                            value = customAttribute.value[chunk_faces3[f]];
                            v1 = value[0];
                            v2 = value[1];
                            v3 = value[2];
                            customAttribute.array[offset_custom] = v1.x;
                            customAttribute.array[offset_custom + 1] = v1.y;
                            customAttribute.array[offset_custom + 2] = v1.z;
                            customAttribute.array[offset_custom + 3] = v1.w;
                            customAttribute.array[offset_custom + 4] = v2.x;
                            customAttribute.array[offset_custom + 5] = v2.y;
                            customAttribute.array[offset_custom + 6] = v2.z;
                            customAttribute.array[offset_custom + 7] = v2.w;
                            customAttribute.array[offset_custom + 8] = v3.x;
                            customAttribute.array[offset_custom + 9] = v3.y;
                            customAttribute.array[offset_custom + 10] = v3.z;
                            customAttribute.array[offset_custom + 11] = v3.w;
                            offset_custom += 12;
                        }
                    }
                }
                _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
                _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
            }
        }
        if (dispose) {
            delete geometryGroup.__inittedArrays;
            delete geometryGroup.__colorArray;
            delete geometryGroup.__normalArray;
            delete geometryGroup.__tangentArray;
            delete geometryGroup.__uvArray;
            delete geometryGroup.__uv2Array;
            delete geometryGroup.__faceArray;
            delete geometryGroup.__vertexArray;
            delete geometryGroup.__lineArray;
            delete geometryGroup.__skinIndexArray;
            delete geometryGroup.__skinWeightArray;
        }
    }
    this.renderBufferImmediate = function(object, program, material) {
        state.initAttributes();
        if (object.hasPositions && !object.__webglVertexBuffer) object.__webglVertexBuffer = _gl.createBuffer();
        if (object.hasNormals && !object.__webglNormalBuffer) object.__webglNormalBuffer = _gl.createBuffer();
        if (object.hasUvs && !object.__webglUvBuffer) object.__webglUvBuffer = _gl.createBuffer();
        if (object.hasColors && !object.__webglColorBuffer) object.__webglColorBuffer = _gl.createBuffer();
        if (object.hasPositions) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglVertexBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
            state.enableAttribute(program.attributes.position);
            _gl.vertexAttribPointer(program.attributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasNormals) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglNormalBuffer);
            if (material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading) {
                var nx, ny, nz, nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz, normalArray, i, il = object.count * 3;
                for (i = 0; i < il; i += 9) {
                    normalArray = object.normalArray;
                    nax = normalArray[i];
                    nay = normalArray[i + 1];
                    naz = normalArray[i + 2];
                    nbx = normalArray[i + 3];
                    nby = normalArray[i + 4];
                    nbz = normalArray[i + 5];
                    ncx = normalArray[i + 6];
                    ncy = normalArray[i + 7];
                    ncz = normalArray[i + 8];
                    nx = (nax + nbx + ncx) / 3;
                    ny = (nay + nby + ncy) / 3;
                    nz = (naz + nbz + ncz) / 3;
                    normalArray[i] = nx;
                    normalArray[i + 1] = ny;
                    normalArray[i + 2] = nz;
                    normalArray[i + 3] = nx;
                    normalArray[i + 4] = ny;
                    normalArray[i + 5] = nz;
                    normalArray[i + 6] = nx;
                    normalArray[i + 7] = ny;
                    normalArray[i + 8] = nz;
                }
            }
            _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
            state.enableAttribute(program.attributes.normal);
            _gl.vertexAttribPointer(program.attributes.normal, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasUvs && material.map) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglUvBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
            state.enableAttribute(program.attributes.uv);
            _gl.vertexAttribPointer(program.attributes.uv, 2, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasColors && material.vertexColors !== THREE.NoColors) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglColorBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
            state.enableAttribute(program.attributes.color);
            _gl.vertexAttribPointer(program.attributes.color, 3, _gl.FLOAT, false, 0, 0);
        }
        state.disableUnusedAttributes();
        _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
        object.count = 0;
    };
    function setupVertexAttributes(material, program, geometry, startIndex) {
        var geometryAttributes = geometry.attributes;
        var programAttributes = program.attributes;
        var programAttributesKeys = program.attributesKeys;
        for (var i = 0, l = programAttributesKeys.length; i < l; i++) {
            var key = programAttributesKeys[i];
            var programAttribute = programAttributes[key];
            if (programAttribute >= 0) {
                var geometryAttribute = geometryAttributes[key];
                if (geometryAttribute !== undefined) {
                    var size = geometryAttribute.itemSize;
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryAttribute.buffer);
                    state.enableAttribute(programAttribute);
                    _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4);
                } else if (material.defaultAttributeValues !== undefined) {
                    if (material.defaultAttributeValues[key].length === 2) {
                        _gl.vertexAttrib2fv(programAttribute, material.defaultAttributeValues[key]);
                    } else if (material.defaultAttributeValues[key].length === 3) {
                        _gl.vertexAttrib3fv(programAttribute, material.defaultAttributeValues[key]);
                    }
                }
            }
        }
        state.disableUnusedAttributes();
    }
    this.renderBufferDirect = function(camera, lights, fog, material, geometry, object) {
        if (material.visible === false) return;
        updateObject(object);
        var program = setProgram(camera, lights, fog, material, object);
        var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryProgram = "direct_" + geometry.id + "_" + program.id + "_" + wireframeBit;
        if (geometryProgram !== _currentGeometryProgram) {
            _currentGeometryProgram = geometryProgram;
            updateBuffers = true;
        }
        if (updateBuffers) {
            state.initAttributes();
        }
        if (object instanceof THREE.Mesh) {
            var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;
            var index = geometry.attributes.index;
            if (index) {
                var type, size;
                if (index.array instanceof Uint32Array && extensions.get("OES_element_index_uint")) {
                    type = _gl.UNSIGNED_INT;
                    size = 4;
                } else {
                    type = _gl.UNSIGNED_SHORT;
                    size = 2;
                }
                var offsets = geometry.offsets;
                if (offsets.length === 0) {
                    if (updateBuffers) {
                        setupVertexAttributes(material, program, geometry, 0);
                        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                    }
                    _gl.drawElements(mode, index.array.length, type, 0);
                    _this.info.render.calls++;
                    _this.info.render.vertices += index.array.length;
                    _this.info.render.faces += index.array.length / 3;
                } else {
                    updateBuffers = true;
                    for (var i = 0, il = offsets.length; i < il; i++) {
                        var startIndex = offsets[i].index;
                        if (updateBuffers) {
                            setupVertexAttributes(material, program, geometry, startIndex);
                            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                        }
                        _gl.drawElements(mode, offsets[i].count, type, offsets[i].start * size);
                        _this.info.render.calls++;
                        _this.info.render.vertices += offsets[i].count;
                        _this.info.render.faces += offsets[i].count / 3;
                    }
                }
            } else {
                if (updateBuffers) {
                    setupVertexAttributes(material, program, geometry, 0);
                }
                var position = geometry.attributes["position"];
                _gl.drawArrays(mode, 0, position.array.length / position.itemSize);
                _this.info.render.calls++;
                _this.info.render.vertices += position.array.length / position.itemSize;
                _this.info.render.faces += position.array.length / (3 * position.itemSize);
            }
        } else if (object instanceof THREE.PointCloud) {
            var mode = _gl.POINTS;
            var index = geometry.attributes.index;
            if (index) {
                var type, size;
                if (index.array instanceof Uint32Array && extensions.get("OES_element_index_uint")) {
                    type = _gl.UNSIGNED_INT;
                    size = 4;
                } else {
                    type = _gl.UNSIGNED_SHORT;
                    size = 2;
                }
                var offsets = geometry.offsets;
                if (offsets.length === 0) {
                    if (updateBuffers) {
                        setupVertexAttributes(material, program, geometry, 0);
                        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                    }
                    _gl.drawElements(mode, index.array.length, type, 0);
                    _this.info.render.calls++;
                    _this.info.render.points += index.array.length;
                } else {
                    if (offsets.length > 1) updateBuffers = true;
                    for (var i = 0, il = offsets.length; i < il; i++) {
                        var startIndex = offsets[i].index;
                        if (updateBuffers) {
                            setupVertexAttributes(material, program, geometry, startIndex);
                            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                        }
                        _gl.drawElements(mode, offsets[i].count, type, offsets[i].start * size);
                        _this.info.render.calls++;
                        _this.info.render.points += offsets[i].count;
                    }
                }
            } else {
                if (updateBuffers) {
                    setupVertexAttributes(material, program, geometry, 0);
                }
                var position = geometry.attributes.position;
                var offsets = geometry.offsets;
                if (offsets.length === 0) {
                    _gl.drawArrays(mode, 0, position.array.length / 3);
                    _this.info.render.calls++;
                    _this.info.render.points += position.array.length / 3;
                } else {
                    for (var i = 0, il = offsets.length; i < il; i++) {
                        _gl.drawArrays(mode, offsets[i].index, offsets[i].count);
                        _this.info.render.calls++;
                        _this.info.render.points += offsets[i].count;
                    }
                }
            }
        } else if (object instanceof THREE.Line) {
            var mode = object.mode === THREE.LineStrip ? _gl.LINE_STRIP : _gl.LINES;
            state.setLineWidth(material.linewidth * pixelRatio);
            var index = geometry.attributes.index;
            if (index) {
                var type, size;
                if (index.array instanceof Uint32Array) {
                    type = _gl.UNSIGNED_INT;
                    size = 4;
                } else {
                    type = _gl.UNSIGNED_SHORT;
                    size = 2;
                }
                var offsets = geometry.offsets;
                if (offsets.length === 0) {
                    if (updateBuffers) {
                        setupVertexAttributes(material, program, geometry, 0);
                        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                    }
                    _gl.drawElements(mode, index.array.length, type, 0);
                    _this.info.render.calls++;
                    _this.info.render.vertices += index.array.length;
                } else {
                    if (offsets.length > 1) updateBuffers = true;
                    for (var i = 0, il = offsets.length; i < il; i++) {
                        var startIndex = offsets[i].index;
                        if (updateBuffers) {
                            setupVertexAttributes(material, program, geometry, startIndex);
                            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                        }
                        _gl.drawElements(mode, offsets[i].count, type, offsets[i].start * size);
                        _this.info.render.calls++;
                        _this.info.render.vertices += offsets[i].count;
                    }
                }
            } else {
                if (updateBuffers) {
                    setupVertexAttributes(material, program, geometry, 0);
                }
                var position = geometry.attributes.position;
                var offsets = geometry.offsets;
                if (offsets.length === 0) {
                    _gl.drawArrays(mode, 0, position.array.length / 3);
                    _this.info.render.calls++;
                    _this.info.render.vertices += position.array.length / 3;
                } else {
                    for (var i = 0, il = offsets.length; i < il; i++) {
                        _gl.drawArrays(mode, offsets[i].index, offsets[i].count);
                        _this.info.render.calls++;
                        _this.info.render.vertices += offsets[i].count;
                    }
                }
            }
        }
    };
    this.renderBuffer = function(camera, lights, fog, material, geometryGroup, object) {
        if (material.visible === false) return;
        updateObject(object);
        var program = setProgram(camera, lights, fog, material, object);
        var attributes = program.attributes;
        var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryProgram = geometryGroup.id + "_" + program.id + "_" + wireframeBit;
        if (geometryProgram !== _currentGeometryProgram) {
            _currentGeometryProgram = geometryProgram;
            updateBuffers = true;
        }
        if (updateBuffers) {
            state.initAttributes();
        }
        if (!material.morphTargets && attributes.position >= 0) {
            if (updateBuffers) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
                state.enableAttribute(attributes.position);
                _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
            }
        } else {
            if (object.morphTargetBase) {
                setupMorphTargets(material, geometryGroup, object);
            }
        }
        if (updateBuffers) {
            if (geometryGroup.__webglCustomAttributesList) {
                for (var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i++) {
                    var attribute = geometryGroup.__webglCustomAttributesList[i];
                    if (attributes[attribute.buffer.belongsToAttribute] >= 0) {
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, attribute.buffer);
                        state.enableAttribute(attributes[attribute.buffer.belongsToAttribute]);
                        _gl.vertexAttribPointer(attributes[attribute.buffer.belongsToAttribute], attribute.size, _gl.FLOAT, false, 0, 0);
                    }
                }
            }
            if (attributes.color >= 0) {
                if (object.geometry.colors.length > 0 || object.geometry.faces.length > 0) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
                    state.enableAttribute(attributes.color);
                    _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
                } else if (material.defaultAttributeValues !== undefined) {
                    _gl.vertexAttrib3fv(attributes.color, material.defaultAttributeValues.color);
                }
            }
            if (attributes.normal >= 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
                state.enableAttribute(attributes.normal);
                _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
            }
            if (attributes.tangent >= 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
                state.enableAttribute(attributes.tangent);
                _gl.vertexAttribPointer(attributes.tangent, 4, _gl.FLOAT, false, 0, 0);
            }
            if (attributes.uv >= 0) {
                if (object.geometry.faceVertexUvs[0]) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
                    state.enableAttribute(attributes.uv);
                    _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
                } else if (material.defaultAttributeValues !== undefined) {
                    _gl.vertexAttrib2fv(attributes.uv, material.defaultAttributeValues.uv);
                }
            }
            if (attributes.uv2 >= 0) {
                if (object.geometry.faceVertexUvs[1]) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
                    state.enableAttribute(attributes.uv2);
                    _gl.vertexAttribPointer(attributes.uv2, 2, _gl.FLOAT, false, 0, 0);
                } else if (material.defaultAttributeValues !== undefined) {
                    _gl.vertexAttrib2fv(attributes.uv2, material.defaultAttributeValues.uv2);
                }
            }
            if (material.skinning && attributes.skinIndex >= 0 && attributes.skinWeight >= 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);
                state.enableAttribute(attributes.skinIndex);
                _gl.vertexAttribPointer(attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0);
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);
                state.enableAttribute(attributes.skinWeight);
                _gl.vertexAttribPointer(attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0);
            }
            if (attributes.lineDistance >= 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer);
                state.enableAttribute(attributes.lineDistance);
                _gl.vertexAttribPointer(attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0);
            }
        }
        state.disableUnusedAttributes();
        if (object instanceof THREE.Mesh) {
            var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;
            if (material.wireframe) {
                state.setLineWidth(material.wireframeLinewidth * pixelRatio);
                if (updateBuffers) _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
                _gl.drawElements(_gl.LINES, geometryGroup.__webglLineCount, type, 0);
            } else {
                if (updateBuffers) _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
                _gl.drawElements(_gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0);
            }
            _this.info.render.calls++;
            _this.info.render.vertices += geometryGroup.__webglFaceCount;
            _this.info.render.faces += geometryGroup.__webglFaceCount / 3;
        } else if (object instanceof THREE.Line) {
            var mode = object.mode === THREE.LineStrip ? _gl.LINE_STRIP : _gl.LINES;
            state.setLineWidth(material.linewidth * pixelRatio);
            _gl.drawArrays(mode, 0, geometryGroup.__webglLineCount);
            _this.info.render.calls++;
        } else if (object instanceof THREE.PointCloud) {
            _gl.drawArrays(_gl.POINTS, 0, geometryGroup.__webglParticleCount);
            _this.info.render.calls++;
            _this.info.render.points += geometryGroup.__webglParticleCount;
        }
    };
    function setupMorphTargets(material, geometryGroup, object) {
        var attributes = material.program.attributes;
        if (object.morphTargetBase !== -1 && attributes.position >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[object.morphTargetBase]);
            state.enableAttribute(attributes.position);
            _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
        } else if (attributes.position >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
            state.enableAttribute(attributes.position);
            _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.morphTargetForcedOrder.length) {
            var m = 0;
            var order = object.morphTargetForcedOrder;
            var influences = object.morphTargetInfluences;
            var attribute;
            while (m < material.numSupportedMorphTargets && m < order.length) {
                attribute = attributes["morphTarget" + m];
                if (attribute >= 0) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[order[m]]);
                    state.enableAttribute(attribute);
                    _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
                }
                attribute = attributes["morphNormal" + m];
                if (attribute >= 0 && material.morphNormals) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[order[m]]);
                    state.enableAttribute(attribute);
                    _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
                }
                object.__webglMorphTargetInfluences[m] = influences[order[m]];
                m++;
            }
        } else {
            var activeInfluenceIndices = [];
            var influences = object.morphTargetInfluences;
            var morphTargets = object.geometry.morphTargets;
            if (influences.length > morphTargets.length) {
                console.warn("THREE.WebGLRenderer: Influences array is bigger than morphTargets array.");
                influences.length = morphTargets.length;
            }
            for (var i = 0, il = influences.length; i < il; i++) {
                var influence = influences[i];
                activeInfluenceIndices.push([ influence, i ]);
            }
            if (activeInfluenceIndices.length > material.numSupportedMorphTargets) {
                activeInfluenceIndices.sort(numericalSort);
                activeInfluenceIndices.length = material.numSupportedMorphTargets;
            } else if (activeInfluenceIndices.length > material.numSupportedMorphNormals) {
                activeInfluenceIndices.sort(numericalSort);
            } else if (activeInfluenceIndices.length === 0) {
                activeInfluenceIndices.push([ 0, 0 ]);
            }
            var attribute;
            for (var m = 0, ml = material.numSupportedMorphTargets; m < ml; m++) {
                if (activeInfluenceIndices[m]) {
                    var influenceIndex = activeInfluenceIndices[m][1];
                    attribute = attributes["morphTarget" + m];
                    if (attribute >= 0) {
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[influenceIndex]);
                        state.enableAttribute(attribute);
                        _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
                    }
                    attribute = attributes["morphNormal" + m];
                    if (attribute >= 0 && material.morphNormals) {
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[influenceIndex]);
                        state.enableAttribute(attribute);
                        _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
                    }
                    object.__webglMorphTargetInfluences[m] = influences[influenceIndex];
                } else {
                    object.__webglMorphTargetInfluences[m] = 0;
                }
            }
        }
        if (material.program.uniforms.morphTargetInfluences !== null) {
            _gl.uniform1fv(material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences);
        }
    }
    function painterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
            return a.object.renderOrder - b.object.renderOrder;
        } else if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
            return a.z - b.z;
        } else {
            return a.id - b.id;
        }
    }
    function reversePainterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
            return a.object.renderOrder - b.object.renderOrder;
        }
        if (a.z !== b.z) {
            return b.z - a.z;
        } else {
            return a.id - b.id;
        }
    }
    function numericalSort(a, b) {
        return b[0] - a[0];
    }
    this.render = function(scene, camera, renderTarget, forceClear) {
        if (camera instanceof THREE.Camera === false) {
            THREE.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
        }
        var fog = scene.fog;
        _currentGeometryProgram = "";
        _currentMaterialId = -1;
        _currentCamera = null;
        _lightsNeedUpdate = true;
        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        if (camera.parent === undefined) camera.updateMatrixWorld();
        scene.traverse(function(object) {
            if (object instanceof THREE.SkinnedMesh) {
                object.skeleton.update();
            }
        });
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        lights.length = 0;
        opaqueObjects.length = 0;
        transparentObjects.length = 0;
        sprites.length = 0;
        lensFlares.length = 0;
        projectObject(scene);
        if (_this.sortObjects === true) {
            opaqueObjects.sort(painterSortStable);
            transparentObjects.sort(reversePainterSortStable);
        }
        shadowMapPlugin.render(scene, camera);
        _this.info.render.calls = 0;
        _this.info.render.vertices = 0;
        _this.info.render.faces = 0;
        _this.info.render.points = 0;
        this.setRenderTarget(renderTarget);
        if (this.autoClear || forceClear) {
            this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }
        for (var i = 0, il = _webglObjectsImmediate.length; i < il; i++) {
            var webglObject = _webglObjectsImmediate[i];
            var object = webglObject.object;
            if (object.visible) {
                setupMatrices(object, camera);
                unrollImmediateBufferMaterial(webglObject);
            }
        }
        if (scene.overrideMaterial) {
            var overrideMaterial = scene.overrideMaterial;
            setMaterial(overrideMaterial);
            renderObjects(opaqueObjects, camera, lights, fog, overrideMaterial);
            renderObjects(transparentObjects, camera, lights, fog, overrideMaterial);
            renderObjectsImmediate(_webglObjectsImmediate, "", camera, lights, fog, overrideMaterial);
        } else {
            state.setBlending(THREE.NoBlending);
            renderObjects(opaqueObjects, camera, lights, fog, null);
            renderObjectsImmediate(_webglObjectsImmediate, "opaque", camera, lights, fog, null);
            renderObjects(transparentObjects, camera, lights, fog, null);
            renderObjectsImmediate(_webglObjectsImmediate, "transparent", camera, lights, fog, null);
        }
        spritePlugin.render(scene, camera);
        lensFlarePlugin.render(scene, camera, _currentWidth, _currentHeight);
        if (renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter) {
            updateRenderTargetMipmap(renderTarget);
        }
        state.setDepthTest(true);
        state.setDepthWrite(true);
        state.setColorWrite(true);
    };
    function projectObject(object) {
        if (object.visible === false) return;
        if (object instanceof THREE.Scene || object instanceof THREE.Group) {} else {
            initObject(object);
            if (object instanceof THREE.Light) {
                lights.push(object);
            } else if (object instanceof THREE.Sprite) {
                sprites.push(object);
            } else if (object instanceof THREE.LensFlare) {
                lensFlares.push(object);
            } else {
                var webglObjects = _webglObjects[object.id];
                if (webglObjects && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
                    for (var i = 0, l = webglObjects.length; i < l; i++) {
                        var webglObject = webglObjects[i];
                        unrollBufferMaterial(webglObject);
                        webglObject.render = true;
                        if (_this.sortObjects === true) {
                            _vector3.setFromMatrixPosition(object.matrixWorld);
                            _vector3.applyProjection(_projScreenMatrix);
                            webglObject.z = _vector3.z;
                        }
                    }
                }
            }
        }
        for (var i = 0, l = object.children.length; i < l; i++) {
            projectObject(object.children[i]);
        }
    }
    function renderObjects(renderList, camera, lights, fog, overrideMaterial) {
        var material;
        for (var i = 0, l = renderList.length; i < l; i++) {
            var webglObject = renderList[i];
            var object = webglObject.object;
            var buffer = webglObject.buffer;
            setupMatrices(object, camera);
            if (overrideMaterial) {
                material = overrideMaterial;
            } else {
                material = webglObject.material;
                if (!material) continue;
                setMaterial(material);
            }
            _this.setMaterialFaces(material);
            if (buffer instanceof THREE.BufferGeometry) {
                _this.renderBufferDirect(camera, lights, fog, material, buffer, object);
            } else {
                _this.renderBuffer(camera, lights, fog, material, buffer, object);
            }
        }
    }
    function renderObjectsImmediate(renderList, materialType, camera, lights, fog, overrideMaterial) {
        var material;
        for (var i = 0, l = renderList.length; i < l; i++) {
            var webglObject = renderList[i];
            var object = webglObject.object;
            if (object.visible) {
                if (overrideMaterial) {
                    material = overrideMaterial;
                } else {
                    material = webglObject[materialType];
                    if (!material) continue;
                    setMaterial(material);
                }
                _this.renderImmediateObject(camera, lights, fog, material, object);
            }
        }
    }
    this.renderImmediateObject = function(camera, lights, fog, material, object) {
        var program = setProgram(camera, lights, fog, material, object);
        _currentGeometryProgram = "";
        _this.setMaterialFaces(material);
        if (object.immediateRenderCallback) {
            object.immediateRenderCallback(program, _gl, _frustum);
        } else {
            object.render(function(object) {
                _this.renderBufferImmediate(object, program, material);
            });
        }
    };
    function unrollImmediateBufferMaterial(globject) {
        var object = globject.object, material = object.material;
        if (material.transparent) {
            globject.transparent = material;
            globject.opaque = null;
        } else {
            globject.opaque = material;
            globject.transparent = null;
        }
    }
    function unrollBufferMaterial(globject) {
        var object = globject.object;
        var buffer = globject.buffer;
        var geometry = object.geometry;
        var material = object.material;
        if (material instanceof THREE.MeshFaceMaterial) {
            var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;
            material = material.materials[materialIndex];
            globject.material = material;
            if (material.transparent) {
                transparentObjects.push(globject);
            } else {
                opaqueObjects.push(globject);
            }
        } else if (material) {
            globject.material = material;
            if (material.transparent) {
                transparentObjects.push(globject);
            } else {
                opaqueObjects.push(globject);
            }
        }
    }
    function initObject(object) {
        if (object.__webglInit === undefined) {
            object.__webglInit = true;
            object._modelViewMatrix = new THREE.Matrix4();
            object._normalMatrix = new THREE.Matrix3();
            object.addEventListener("removed", onObjectRemoved);
        }
        var geometry = object.geometry;
        if (geometry === undefined) {} else if (geometry.__webglInit === undefined) {
            geometry.__webglInit = true;
            geometry.addEventListener("dispose", onGeometryDispose);
            if (geometry instanceof THREE.BufferGeometry) {
                _this.info.memory.geometries++;
            } else if (object instanceof THREE.Mesh) {
                initGeometryGroups(object, geometry);
            } else if (object instanceof THREE.Line) {
                if (geometry.__webglVertexBuffer === undefined) {
                    createLineBuffers(geometry);
                    initLineBuffers(geometry, object);
                    geometry.verticesNeedUpdate = true;
                    geometry.colorsNeedUpdate = true;
                    geometry.lineDistancesNeedUpdate = true;
                }
            } else if (object instanceof THREE.PointCloud) {
                if (geometry.__webglVertexBuffer === undefined) {
                    createParticleBuffers(geometry);
                    initParticleBuffers(geometry, object);
                    geometry.verticesNeedUpdate = true;
                    geometry.colorsNeedUpdate = true;
                }
            }
        }
        if (object.__webglActive === undefined) {
            object.__webglActive = true;
            if (object instanceof THREE.Mesh) {
                if (geometry instanceof THREE.BufferGeometry) {
                    addBuffer(_webglObjects, geometry, object);
                } else if (geometry instanceof THREE.Geometry) {
                    var geometryGroupsList = geometryGroups[geometry.id];
                    for (var i = 0, l = geometryGroupsList.length; i < l; i++) {
                        addBuffer(_webglObjects, geometryGroupsList[i], object);
                    }
                }
            } else if (object instanceof THREE.Line || object instanceof THREE.PointCloud) {
                addBuffer(_webglObjects, geometry, object);
            } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) {
                addBufferImmediate(_webglObjectsImmediate, object);
            }
        }
    }
    var geometryGroups = {};
    var geometryGroupCounter = 0;
    function makeGroups(geometry, usesFaceMaterial) {
        var maxVerticesInGroup = extensions.get("OES_element_index_uint") ? 4294967296 : 65535;
        var groupHash, hash_map = {};
        var numMorphTargets = geometry.morphTargets.length;
        var numMorphNormals = geometry.morphNormals.length;
        var group;
        var groups = {};
        var groupsList = [];
        for (var f = 0, fl = geometry.faces.length; f < fl; f++) {
            var face = geometry.faces[f];
            var materialIndex = usesFaceMaterial ? face.materialIndex : 0;
            if (!(materialIndex in hash_map)) {
                hash_map[materialIndex] = {
                    hash: materialIndex,
                    counter: 0
                };
            }
            groupHash = hash_map[materialIndex].hash + "_" + hash_map[materialIndex].counter;
            if (!(groupHash in groups)) {
                group = {
                    id: geometryGroupCounter++,
                    faces3: [],
                    materialIndex: materialIndex,
                    vertices: 0,
                    numMorphTargets: numMorphTargets,
                    numMorphNormals: numMorphNormals
                };
                groups[groupHash] = group;
                groupsList.push(group);
            }
            if (groups[groupHash].vertices + 3 > maxVerticesInGroup) {
                hash_map[materialIndex].counter += 1;
                groupHash = hash_map[materialIndex].hash + "_" + hash_map[materialIndex].counter;
                if (!(groupHash in groups)) {
                    group = {
                        id: geometryGroupCounter++,
                        faces3: [],
                        materialIndex: materialIndex,
                        vertices: 0,
                        numMorphTargets: numMorphTargets,
                        numMorphNormals: numMorphNormals
                    };
                    groups[groupHash] = group;
                    groupsList.push(group);
                }
            }
            groups[groupHash].faces3.push(f);
            groups[groupHash].vertices += 3;
        }
        return groupsList;
    }
    function initGeometryGroups(object, geometry) {
        var material = object.material, addBuffers = false;
        if (geometryGroups[geometry.id] === undefined || geometry.groupsNeedUpdate === true) {
            delete _webglObjects[object.id];
            geometryGroups[geometry.id] = makeGroups(geometry, material instanceof THREE.MeshFaceMaterial);
            geometry.groupsNeedUpdate = false;
        }
        var geometryGroupsList = geometryGroups[geometry.id];
        for (var i = 0, il = geometryGroupsList.length; i < il; i++) {
            var geometryGroup = geometryGroupsList[i];
            if (geometryGroup.__webglVertexBuffer === undefined) {
                createMeshBuffers(geometryGroup);
                initMeshBuffers(geometryGroup, object);
                geometry.verticesNeedUpdate = true;
                geometry.morphTargetsNeedUpdate = true;
                geometry.elementsNeedUpdate = true;
                geometry.uvsNeedUpdate = true;
                geometry.normalsNeedUpdate = true;
                geometry.tangentsNeedUpdate = true;
                geometry.colorsNeedUpdate = true;
                addBuffers = true;
            } else {
                addBuffers = false;
            }
            if (addBuffers || object.__webglActive === undefined) {
                addBuffer(_webglObjects, geometryGroup, object);
            }
        }
        object.__webglActive = true;
    }
    function addBuffer(objlist, buffer, object) {
        var id = object.id;
        objlist[id] = objlist[id] || [];
        objlist[id].push({
            id: id,
            buffer: buffer,
            object: object,
            material: null,
            z: 0
        });
    }
    function addBufferImmediate(objlist, object) {
        objlist.push({
            id: null,
            object: object,
            opaque: null,
            transparent: null,
            z: 0
        });
    }
    function updateObject(object) {
        var geometry = object.geometry;
        if (geometry instanceof THREE.BufferGeometry) {
            var attributes = geometry.attributes;
            var attributesKeys = geometry.attributesKeys;
            for (var i = 0, l = attributesKeys.length; i < l; i++) {
                var key = attributesKeys[i];
                var attribute = attributes[key];
                var bufferType = key === "index" ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;
                if (attribute.buffer === undefined) {
                    attribute.buffer = _gl.createBuffer();
                    _gl.bindBuffer(bufferType, attribute.buffer);
                    _gl.bufferData(bufferType, attribute.array, attribute instanceof THREE.DynamicBufferAttribute ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);
                    attribute.needsUpdate = false;
                } else if (attribute.needsUpdate === true) {
                    _gl.bindBuffer(bufferType, attribute.buffer);
                    if (attribute.updateRange === undefined || attribute.updateRange.count === -1) {
                        _gl.bufferSubData(bufferType, 0, attribute.array);
                    } else if (attribute.updateRange.count === 0) {
                        console.error("THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.");
                    } else {
                        _gl.bufferSubData(bufferType, attribute.updateRange.offset * attribute.array.BYTES_PER_ELEMENT, attribute.array.subarray(attribute.updateRange.offset, attribute.updateRange.offset + attribute.updateRange.count));
                        attribute.updateRange.count = 0;
                    }
                    attribute.needsUpdate = false;
                }
            }
        } else if (object instanceof THREE.Mesh) {
            if (geometry.groupsNeedUpdate === true) {
                initGeometryGroups(object, geometry);
            }
            var geometryGroupsList = geometryGroups[geometry.id];
            for (var i = 0, il = geometryGroupsList.length; i < il; i++) {
                var geometryGroup = geometryGroupsList[i];
                var material = getBufferMaterial(object, geometryGroup);
                var customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
                if (geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate || geometry.uvsNeedUpdate || geometry.normalsNeedUpdate || geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty) {
                    setMeshBuffers(geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material);
                }
            }
            geometry.verticesNeedUpdate = false;
            geometry.morphTargetsNeedUpdate = false;
            geometry.elementsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.tangentsNeedUpdate = false;
            material.attributes && clearCustomAttributes(material);
        } else if (object instanceof THREE.Line) {
            var material = getBufferMaterial(object, geometry);
            var customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
            if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty) {
                setLineBuffers(geometry, _gl.DYNAMIC_DRAW);
            }
            geometry.verticesNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.lineDistancesNeedUpdate = false;
            material.attributes && clearCustomAttributes(material);
        } else if (object instanceof THREE.PointCloud) {
            var material = getBufferMaterial(object, geometry);
            var customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
            if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty) {
                setParticleBuffers(geometry, _gl.DYNAMIC_DRAW, object);
            }
            geometry.verticesNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            material.attributes && clearCustomAttributes(material);
        }
    }
    function areCustomAttributesDirty(material) {
        for (var name in material.attributes) {
            if (material.attributes[name].needsUpdate) return true;
        }
        return false;
    }
    function clearCustomAttributes(material) {
        for (var name in material.attributes) {
            material.attributes[name].needsUpdate = false;
        }
    }
    function removeObject(object) {
        if (object instanceof THREE.Mesh || object instanceof THREE.PointCloud || object instanceof THREE.Line) {
            delete _webglObjects[object.id];
        } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) {
            removeInstances(_webglObjectsImmediate, object);
        }
        delete object.__webglInit;
        delete object._modelViewMatrix;
        delete object._normalMatrix;
        delete object.__webglActive;
    }
    function removeInstances(objlist, object) {
        for (var o = objlist.length - 1; o >= 0; o--) {
            if (objlist[o].object === object) {
                objlist.splice(o, 1);
            }
        }
    }
    var shaderIDs = {
        MeshDepthMaterial: "depth",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointCloudMaterial: "particle_basic"
    };
    function initMaterial(material, lights, fog, object) {
        material.addEventListener("dispose", onMaterialDispose);
        var shaderID = shaderIDs[material.type];
        if (shaderID) {
            var shader = THREE.ShaderLib[shaderID];
            material.__webglShader = {
                uniforms: THREE.UniformsUtils.clone(shader.uniforms),
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            };
        } else {
            material.__webglShader = {
                uniforms: material.uniforms,
                vertexShader: material.vertexShader,
                fragmentShader: material.fragmentShader
            };
        }
        var maxLightCount = allocateLights(lights);
        var maxShadows = allocateShadows(lights);
        var maxBones = allocateBones(object);
        var parameters = {
            precision: _precision,
            supportsVertexTextures: _supportsVertexTextures,
            map: !!material.map,
            envMap: !!material.envMap,
            envMapMode: material.envMap && material.envMap.mapping,
            lightMap: !!material.lightMap,
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,
            combine: material.combine,
            vertexColors: material.vertexColors,
            fog: fog,
            useFog: material.fog,
            fogExp: fog instanceof THREE.FogExp2,
            flatShading: material.shading === THREE.FlatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: _logarithmicDepthBuffer,
            skinning: material.skinning,
            maxBones: maxBones,
            useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,
            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: _this.maxMorphTargets,
            maxMorphNormals: _this.maxMorphNormals,
            maxDirLights: maxLightCount.directional,
            maxPointLights: maxLightCount.point,
            maxSpotLights: maxLightCount.spot,
            maxHemiLights: maxLightCount.hemi,
            maxShadows: maxShadows,
            shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
            shadowMapType: _this.shadowMapType,
            shadowMapDebug: _this.shadowMapDebug,
            shadowMapCascade: _this.shadowMapCascade,
            alphaTest: material.alphaTest,
            metal: material.metal,
            wrapAround: material.wrapAround,
            doubleSided: material.side === THREE.DoubleSide,
            flipSided: material.side === THREE.BackSide
        };
        var chunks = [];
        if (shaderID) {
            chunks.push(shaderID);
        } else {
            chunks.push(material.fragmentShader);
            chunks.push(material.vertexShader);
        }
        if (material.defines !== undefined) {
            for (var name in material.defines) {
                chunks.push(name);
                chunks.push(material.defines[name]);
            }
        }
        for (var name in parameters) {
            chunks.push(name);
            chunks.push(parameters[name]);
        }
        var code = chunks.join();
        var program;
        for (var p = 0, pl = _programs.length; p < pl; p++) {
            var programInfo = _programs[p];
            if (programInfo.code === code) {
                program = programInfo;
                program.usedTimes++;
                break;
            }
        }
        if (program === undefined) {
            program = new THREE.WebGLProgram(_this, code, material, parameters);
            _programs.push(program);
            _this.info.memory.programs = _programs.length;
        }
        material.program = program;
        var attributes = program.attributes;
        if (material.morphTargets) {
            material.numSupportedMorphTargets = 0;
            var id, base = "morphTarget";
            for (var i = 0; i < _this.maxMorphTargets; i++) {
                id = base + i;
                if (attributes[id] >= 0) {
                    material.numSupportedMorphTargets++;
                }
            }
        }
        if (material.morphNormals) {
            material.numSupportedMorphNormals = 0;
            var id, base = "morphNormal";
            for (i = 0; i < _this.maxMorphNormals; i++) {
                id = base + i;
                if (attributes[id] >= 0) {
                    material.numSupportedMorphNormals++;
                }
            }
        }
        material.uniformsList = [];
        for (var u in material.__webglShader.uniforms) {
            var location = material.program.uniforms[u];
            if (location) {
                material.uniformsList.push([ material.__webglShader.uniforms[u], location ]);
            }
        }
    }
    function setMaterial(material) {
        if (material.transparent === true) {
            state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha);
        } else {
            state.setBlending(THREE.NoBlending);
        }
        state.setDepthTest(material.depthTest);
        state.setDepthWrite(material.depthWrite);
        state.setColorWrite(material.colorWrite);
        state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    function setProgram(camera, lights, fog, material, object) {
        _usedTextureUnits = 0;
        if (material.needsUpdate) {
            if (material.program) deallocateMaterial(material);
            initMaterial(material, lights, fog, object);
            material.needsUpdate = false;
        }
        if (material.morphTargets) {
            if (!object.__webglMorphTargetInfluences) {
                object.__webglMorphTargetInfluences = new Float32Array(_this.maxMorphTargets);
            }
        }
        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;
        var program = material.program, p_uniforms = program.uniforms, m_uniforms = material.__webglShader.uniforms;
        if (program.id !== _currentProgram) {
            _gl.useProgram(program.program);
            _currentProgram = program.id;
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
            if (_currentMaterialId === -1) refreshLights = true;
            _currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || camera !== _currentCamera) {
            _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
            if (_logarithmicDepthBuffer) {
                _gl.uniform1f(p_uniforms.logDepthBufFC, 2 / (Math.log(camera.far + 1) / Math.LN2));
            }
            if (camera !== _currentCamera) _currentCamera = camera;
            if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material.envMap) {
                if (p_uniforms.cameraPosition !== null) {
                    _vector3.setFromMatrixPosition(camera.matrixWorld);
                    _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);
                }
            }
            if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshBasicMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {
                if (p_uniforms.viewMatrix !== null) {
                    _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
                }
            }
        }
        if (material.skinning) {
            if (object.bindMatrix && p_uniforms.bindMatrix !== null) {
                _gl.uniformMatrix4fv(p_uniforms.bindMatrix, false, object.bindMatrix.elements);
            }
            if (object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null) {
                _gl.uniformMatrix4fv(p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements);
            }
            if (_supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture) {
                if (p_uniforms.boneTexture !== null) {
                    var textureUnit = getTextureUnit();
                    _gl.uniform1i(p_uniforms.boneTexture, textureUnit);
                    _this.setTexture(object.skeleton.boneTexture, textureUnit);
                }
                if (p_uniforms.boneTextureWidth !== null) {
                    _gl.uniform1i(p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth);
                }
                if (p_uniforms.boneTextureHeight !== null) {
                    _gl.uniform1i(p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight);
                }
            } else if (object.skeleton && object.skeleton.boneMatrices) {
                if (p_uniforms.boneGlobalMatrices !== null) {
                    _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices);
                }
            }
        }
        if (refreshMaterial) {
            if (fog && material.fog) {
                refreshUniformsFog(m_uniforms, fog);
            }
            if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material.lights) {
                if (_lightsNeedUpdate) {
                    refreshLights = true;
                    setupLights(lights);
                    _lightsNeedUpdate = false;
                }
                if (refreshLights) {
                    refreshUniformsLights(m_uniforms, _lights);
                    markUniformsLightsNeedsUpdate(m_uniforms, true);
                } else {
                    markUniformsLightsNeedsUpdate(m_uniforms, false);
                }
            }
            if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {
                refreshUniformsCommon(m_uniforms, material);
            }
            if (material instanceof THREE.LineBasicMaterial) {
                refreshUniformsLine(m_uniforms, material);
            } else if (material instanceof THREE.LineDashedMaterial) {
                refreshUniformsLine(m_uniforms, material);
                refreshUniformsDash(m_uniforms, material);
            } else if (material instanceof THREE.PointCloudMaterial) {
                refreshUniformsParticle(m_uniforms, material);
            } else if (material instanceof THREE.MeshPhongMaterial) {
                refreshUniformsPhong(m_uniforms, material);
            } else if (material instanceof THREE.MeshLambertMaterial) {
                refreshUniformsLambert(m_uniforms, material);
            } else if (material instanceof THREE.MeshDepthMaterial) {
                m_uniforms.mNear.value = camera.near;
                m_uniforms.mFar.value = camera.far;
                m_uniforms.opacity.value = material.opacity;
            } else if (material instanceof THREE.MeshNormalMaterial) {
                m_uniforms.opacity.value = material.opacity;
            }
            if (object.receiveShadow && !material._shadowPass) {
                refreshUniformsShadow(m_uniforms, lights);
            }
            loadUniformsGeneric(material.uniformsList);
        }
        loadUniformsMatrices(p_uniforms, object);
        if (p_uniforms.modelMatrix !== null) {
            _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);
        }
        return program;
    }
    function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        uniforms.diffuse.value = material.color;
        uniforms.map.value = material.map;
        uniforms.lightMap.value = material.lightMap;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
        }
        var uvScaleMap;
        if (material.map) {
            uvScaleMap = material.map;
        } else if (material.specularMap) {
            uvScaleMap = material.specularMap;
        } else if (material.normalMap) {
            uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
            uvScaleMap = material.bumpMap;
        } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
        }
        if (uvScaleMap !== undefined) {
            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;
            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = material.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
    }
    function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    }
    function refreshUniformsParticle(uniforms, material) {
        uniforms.psColor.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size;
        uniforms.scale.value = _canvas.height / 2;
        uniforms.map.value = material.map;
        if (material.map !== null) {
            var offset = material.map.offset;
            var repeat = material.map.repeat;
            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
    }
    function refreshUniformsFog(uniforms, fog) {
        uniforms.fogColor.value = fog.color;
        if (fog instanceof THREE.Fog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog instanceof THREE.FogExp2) {
            uniforms.fogDensity.value = fog.density;
        }
    }
    function refreshUniformsPhong(uniforms, material) {
        uniforms.shininess.value = material.shininess;
        uniforms.emissive.value = material.emissive;
        uniforms.specular.value = material.specular;
        if (material.wrapAround) {
            uniforms.wrapRGB.value.copy(material.wrapRGB);
        }
    }
    function refreshUniformsLambert(uniforms, material) {
        uniforms.emissive.value = material.emissive;
        if (material.wrapAround) {
            uniforms.wrapRGB.value.copy(material.wrapRGB);
        }
    }
    function refreshUniformsLights(uniforms, lights) {
        uniforms.ambientLightColor.value = lights.ambient;
        uniforms.directionalLightColor.value = lights.directional.colors;
        uniforms.directionalLightDirection.value = lights.directional.positions;
        uniforms.pointLightColor.value = lights.point.colors;
        uniforms.pointLightPosition.value = lights.point.positions;
        uniforms.pointLightDistance.value = lights.point.distances;
        uniforms.pointLightDecay.value = lights.point.decays;
        uniforms.spotLightColor.value = lights.spot.colors;
        uniforms.spotLightPosition.value = lights.spot.positions;
        uniforms.spotLightDistance.value = lights.spot.distances;
        uniforms.spotLightDirection.value = lights.spot.directions;
        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
        uniforms.spotLightExponent.value = lights.spot.exponents;
        uniforms.spotLightDecay.value = lights.spot.decays;
        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
        uniforms.hemisphereLightDirection.value = lights.hemi.positions;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.directionalLightColor.needsUpdate = value;
        uniforms.directionalLightDirection.needsUpdate = value;
        uniforms.pointLightColor.needsUpdate = value;
        uniforms.pointLightPosition.needsUpdate = value;
        uniforms.pointLightDistance.needsUpdate = value;
        uniforms.pointLightDecay.needsUpdate = value;
        uniforms.spotLightColor.needsUpdate = value;
        uniforms.spotLightPosition.needsUpdate = value;
        uniforms.spotLightDistance.needsUpdate = value;
        uniforms.spotLightDirection.needsUpdate = value;
        uniforms.spotLightAngleCos.needsUpdate = value;
        uniforms.spotLightExponent.needsUpdate = value;
        uniforms.spotLightDecay.needsUpdate = value;
        uniforms.hemisphereLightSkyColor.needsUpdate = value;
        uniforms.hemisphereLightGroundColor.needsUpdate = value;
        uniforms.hemisphereLightDirection.needsUpdate = value;
    }
    function refreshUniformsShadow(uniforms, lights) {
        if (uniforms.shadowMatrix) {
            var j = 0;
            for (var i = 0, il = lights.length; i < il; i++) {
                var light = lights[i];
                if (!light.castShadow) continue;
                if (light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight && !light.shadowCascade) {
                    uniforms.shadowMap.value[j] = light.shadowMap;
                    uniforms.shadowMapSize.value[j] = light.shadowMapSize;
                    uniforms.shadowMatrix.value[j] = light.shadowMatrix;
                    uniforms.shadowDarkness.value[j] = light.shadowDarkness;
                    uniforms.shadowBias.value[j] = light.shadowBias;
                    j++;
                }
            }
        }
    }
    function loadUniformsMatrices(uniforms, object) {
        _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object._modelViewMatrix.elements);
        if (uniforms.normalMatrix) {
            _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object._normalMatrix.elements);
        }
    }
    function getTextureUnit() {
        var textureUnit = _usedTextureUnits;
        if (textureUnit >= _maxTextures) {
            THREE.warn("WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures);
        }
        _usedTextureUnits += 1;
        return textureUnit;
    }
    function loadUniformsGeneric(uniforms) {
        var texture, textureUnit, offset;
        for (var j = 0, jl = uniforms.length; j < jl; j++) {
            var uniform = uniforms[j][0];
            if (uniform.needsUpdate === false) continue;
            var type = uniform.type;
            var value = uniform.value;
            var location = uniforms[j][1];
            switch (type) {
              case "1i":
                _gl.uniform1i(location, value);
                break;

              case "1f":
                _gl.uniform1f(location, value);
                break;

              case "2f":
                _gl.uniform2f(location, value[0], value[1]);
                break;

              case "3f":
                _gl.uniform3f(location, value[0], value[1], value[2]);
                break;

              case "4f":
                _gl.uniform4f(location, value[0], value[1], value[2], value[3]);
                break;

              case "1iv":
                _gl.uniform1iv(location, value);
                break;

              case "3iv":
                _gl.uniform3iv(location, value);
                break;

              case "1fv":
                _gl.uniform1fv(location, value);
                break;

              case "2fv":
                _gl.uniform2fv(location, value);
                break;

              case "3fv":
                _gl.uniform3fv(location, value);
                break;

              case "4fv":
                _gl.uniform4fv(location, value);
                break;

              case "Matrix3fv":
                _gl.uniformMatrix3fv(location, false, value);
                break;

              case "Matrix4fv":
                _gl.uniformMatrix4fv(location, false, value);
                break;

              case "i":
                _gl.uniform1i(location, value);
                break;

              case "f":
                _gl.uniform1f(location, value);
                break;

              case "v2":
                _gl.uniform2f(location, value.x, value.y);
                break;

              case "v3":
                _gl.uniform3f(location, value.x, value.y, value.z);
                break;

              case "v4":
                _gl.uniform4f(location, value.x, value.y, value.z, value.w);
                break;

              case "c":
                _gl.uniform3f(location, value.r, value.g, value.b);
                break;

              case "iv1":
                _gl.uniform1iv(location, value);
                break;

              case "iv":
                _gl.uniform3iv(location, value);
                break;

              case "fv1":
                _gl.uniform1fv(location, value);
                break;

              case "fv":
                _gl.uniform3fv(location, value);
                break;

              case "v2v":
                if (uniform._array === undefined) {
                    uniform._array = new Float32Array(2 * value.length);
                }
                for (var i = 0, il = value.length; i < il; i++) {
                    offset = i * 2;
                    uniform._array[offset] = value[i].x;
                    uniform._array[offset + 1] = value[i].y;
                }
                _gl.uniform2fv(location, uniform._array);
                break;

              case "v3v":
                if (uniform._array === undefined) {
                    uniform._array = new Float32Array(3 * value.length);
                }
                for (var i = 0, il = value.length; i < il; i++) {
                    offset = i * 3;
                    uniform._array[offset] = value[i].x;
                    uniform._array[offset + 1] = value[i].y;
                    uniform._array[offset + 2] = value[i].z;
                }
                _gl.uniform3fv(location, uniform._array);
                break;

              case "v4v":
                if (uniform._array === undefined) {
                    uniform._array = new Float32Array(4 * value.length);
                }
                for (var i = 0, il = value.length; i < il; i++) {
                    offset = i * 4;
                    uniform._array[offset] = value[i].x;
                    uniform._array[offset + 1] = value[i].y;
                    uniform._array[offset + 2] = value[i].z;
                    uniform._array[offset + 3] = value[i].w;
                }
                _gl.uniform4fv(location, uniform._array);
                break;

              case "m3":
                _gl.uniformMatrix3fv(location, false, value.elements);
                break;

              case "m3v":
                if (uniform._array === undefined) {
                    uniform._array = new Float32Array(9 * value.length);
                }
                for (var i = 0, il = value.length; i < il; i++) {
                    value[i].flattenToArrayOffset(uniform._array, i * 9);
                }
                _gl.uniformMatrix3fv(location, false, uniform._array);
                break;

              case "m4":
                _gl.uniformMatrix4fv(location, false, value.elements);
                break;

              case "m4v":
                if (uniform._array === undefined) {
                    uniform._array = new Float32Array(16 * value.length);
                }
                for (var i = 0, il = value.length; i < il; i++) {
                    value[i].flattenToArrayOffset(uniform._array, i * 16);
                }
                _gl.uniformMatrix4fv(location, false, uniform._array);
                break;

              case "t":
                texture = value;
                textureUnit = getTextureUnit();
                _gl.uniform1i(location, textureUnit);
                if (!texture) continue;
                if (texture instanceof THREE.CubeTexture || texture.image instanceof Array && texture.image.length === 6) {
                    setCubeTexture(texture, textureUnit);
                } else if (texture instanceof THREE.WebGLRenderTargetCube) {
                    setCubeTextureDynamic(texture, textureUnit);
                } else {
                    _this.setTexture(texture, textureUnit);
                }
                break;

              case "tv":
                if (uniform._array === undefined) {
                    uniform._array = [];
                }
                for (var i = 0, il = uniform.value.length; i < il; i++) {
                    uniform._array[i] = getTextureUnit();
                }
                _gl.uniform1iv(location, uniform._array);
                for (var i = 0, il = uniform.value.length; i < il; i++) {
                    texture = uniform.value[i];
                    textureUnit = uniform._array[i];
                    if (!texture) continue;
                    _this.setTexture(texture, textureUnit);
                }
                break;

              default:
                THREE.warn("THREE.WebGLRenderer: Unknown uniform type: " + type);
            }
        }
    }
    function setupMatrices(object, camera) {
        object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object._normalMatrix.getNormalMatrix(object._modelViewMatrix);
    }
    function setColorLinear(array, offset, color, intensity) {
        array[offset] = color.r * intensity;
        array[offset + 1] = color.g * intensity;
        array[offset + 2] = color.b * intensity;
    }
    function setupLights(lights) {
        var l, ll, light, r = 0, g = 0, b = 0, color, skyColor, groundColor, intensity, distance, zlights = _lights, dirColors = zlights.directional.colors, dirPositions = zlights.directional.positions, pointColors = zlights.point.colors, pointPositions = zlights.point.positions, pointDistances = zlights.point.distances, pointDecays = zlights.point.decays, spotColors = zlights.spot.colors, spotPositions = zlights.spot.positions, spotDistances = zlights.spot.distances, spotDirections = zlights.spot.directions, spotAnglesCos = zlights.spot.anglesCos, spotExponents = zlights.spot.exponents, spotDecays = zlights.spot.decays, hemiSkyColors = zlights.hemi.skyColors, hemiGroundColors = zlights.hemi.groundColors, hemiPositions = zlights.hemi.positions, dirLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0, dirCount = 0, pointCount = 0, spotCount = 0, hemiCount = 0, dirOffset = 0, pointOffset = 0, spotOffset = 0, hemiOffset = 0;
        for (l = 0, ll = lights.length; l < ll; l++) {
            light = lights[l];
            if (light.onlyShadow) continue;
            color = light.color;
            intensity = light.intensity;
            distance = light.distance;
            if (light instanceof THREE.AmbientLight) {
                if (!light.visible) continue;
                r += color.r;
                g += color.g;
                b += color.b;
            } else if (light instanceof THREE.DirectionalLight) {
                dirCount += 1;
                if (!light.visible) continue;
                _direction.setFromMatrixPosition(light.matrixWorld);
                _vector3.setFromMatrixPosition(light.target.matrixWorld);
                _direction.sub(_vector3);
                _direction.normalize();
                dirOffset = dirLength * 3;
                dirPositions[dirOffset] = _direction.x;
                dirPositions[dirOffset + 1] = _direction.y;
                dirPositions[dirOffset + 2] = _direction.z;
                setColorLinear(dirColors, dirOffset, color, intensity);
                dirLength += 1;
            } else if (light instanceof THREE.PointLight) {
                pointCount += 1;
                if (!light.visible) continue;
                pointOffset = pointLength * 3;
                setColorLinear(pointColors, pointOffset, color, intensity);
                _vector3.setFromMatrixPosition(light.matrixWorld);
                pointPositions[pointOffset] = _vector3.x;
                pointPositions[pointOffset + 1] = _vector3.y;
                pointPositions[pointOffset + 2] = _vector3.z;
                pointDistances[pointLength] = distance;
                pointDecays[pointLength] = light.distance === 0 ? 0 : light.decay;
                pointLength += 1;
            } else if (light instanceof THREE.SpotLight) {
                spotCount += 1;
                if (!light.visible) continue;
                spotOffset = spotLength * 3;
                setColorLinear(spotColors, spotOffset, color, intensity);
                _direction.setFromMatrixPosition(light.matrixWorld);
                spotPositions[spotOffset] = _direction.x;
                spotPositions[spotOffset + 1] = _direction.y;
                spotPositions[spotOffset + 2] = _direction.z;
                spotDistances[spotLength] = distance;
                _vector3.setFromMatrixPosition(light.target.matrixWorld);
                _direction.sub(_vector3);
                _direction.normalize();
                spotDirections[spotOffset] = _direction.x;
                spotDirections[spotOffset + 1] = _direction.y;
                spotDirections[spotOffset + 2] = _direction.z;
                spotAnglesCos[spotLength] = Math.cos(light.angle);
                spotExponents[spotLength] = light.exponent;
                spotDecays[spotLength] = light.distance === 0 ? 0 : light.decay;
                spotLength += 1;
            } else if (light instanceof THREE.HemisphereLight) {
                hemiCount += 1;
                if (!light.visible) continue;
                _direction.setFromMatrixPosition(light.matrixWorld);
                _direction.normalize();
                hemiOffset = hemiLength * 3;
                hemiPositions[hemiOffset] = _direction.x;
                hemiPositions[hemiOffset + 1] = _direction.y;
                hemiPositions[hemiOffset + 2] = _direction.z;
                skyColor = light.color;
                groundColor = light.groundColor;
                setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);
                setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);
                hemiLength += 1;
            }
        }
        for (l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3); l < ll; l++) dirColors[l] = 0;
        for (l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3); l < ll; l++) pointColors[l] = 0;
        for (l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3); l < ll; l++) spotColors[l] = 0;
        for (l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3); l < ll; l++) hemiSkyColors[l] = 0;
        for (l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3); l < ll; l++) hemiGroundColors[l] = 0;
        zlights.directional.length = dirLength;
        zlights.point.length = pointLength;
        zlights.spot.length = spotLength;
        zlights.hemi.length = hemiLength;
        zlights.ambient[0] = r;
        zlights.ambient[1] = g;
        zlights.ambient[2] = b;
    }
    this.setFaceCulling = function(cullFace, frontFaceDirection) {
        if (cullFace === THREE.CullFaceNone) {
            _gl.disable(_gl.CULL_FACE);
        } else {
            if (frontFaceDirection === THREE.FrontFaceDirectionCW) {
                _gl.frontFace(_gl.CW);
            } else {
                _gl.frontFace(_gl.CCW);
            }
            if (cullFace === THREE.CullFaceBack) {
                _gl.cullFace(_gl.BACK);
            } else if (cullFace === THREE.CullFaceFront) {
                _gl.cullFace(_gl.FRONT);
            } else {
                _gl.cullFace(_gl.FRONT_AND_BACK);
            }
            _gl.enable(_gl.CULL_FACE);
        }
    };
    this.setMaterialFaces = function(material) {
        state.setDoubleSided(material.side === THREE.DoubleSide);
        state.setFlipSided(material.side === THREE.BackSide);
    };
    function setTextureParameters(textureType, texture, isImagePowerOfTwo) {
        var extension;
        if (isImagePowerOfTwo) {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
        } else {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
            if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {
                THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( " + texture.sourceFile + " )");
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
            if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
                THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( " + texture.sourceFile + " )");
            }
        }
        extension = extensions.get("EXT_texture_filter_anisotropic");
        if (extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType) {
            if (texture.anisotropy > 1 || texture.__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _this.getMaxAnisotropy()));
                texture.__currentAnisotropy = texture.anisotropy;
            }
        }
    }
    this.uploadTexture = function(texture) {
        if (texture.__webglInit === undefined) {
            texture.__webglInit = true;
            texture.addEventListener("dispose", onTextureDispose);
            texture.__webglTexture = _gl.createTexture();
            _this.info.memory.textures++;
        }
        _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        texture.image = clampToMaxSize(texture.image, _maxTextureSize);
        var image = texture.image, isImagePowerOfTwo = THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);
        var mipmap, mipmaps = texture.mipmaps;
        if (texture instanceof THREE.DataTexture) {
            if (mipmaps.length > 0 && isImagePowerOfTwo) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture.generateMipmaps = false;
            } else {
                _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
            }
        } else if (texture instanceof THREE.CompressedTexture) {
            for (var i = 0, il = mipmaps.length; i < il; i++) {
                mipmap = mipmaps[i];
                if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                    if (getCompressedTextureFormats().indexOf(glFormat) > -1) {
                        _gl.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    } else {
                        THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    }
                } else {
                    _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
            }
        } else {
            if (mipmaps.length > 0 && isImagePowerOfTwo) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                }
                texture.generateMipmaps = false;
            } else {
                _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);
            }
        }
        if (texture.generateMipmaps && isImagePowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_2D);
        texture.needsUpdate = false;
        if (texture.onUpdate) texture.onUpdate();
    };
    this.setTexture = function(texture, slot) {
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        if (texture.needsUpdate) {
            _this.uploadTexture(texture);
        } else {
            _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
        }
    };
    function clampToMaxSize(image, maxSize) {
        if (image.width > maxSize || image.height > maxSize) {
            var scale = maxSize / Math.max(image.width, image.height);
            var canvas = document.createElement("canvas");
            canvas.width = Math.floor(image.width * scale);
            canvas.height = Math.floor(image.height * scale);
            var context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
            THREE.warn("THREE.WebGLRenderer: image is too big (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image);
            return canvas;
        }
        return image;
    }
    function setCubeTexture(texture, slot) {
        if (texture.image.length === 6) {
            if (texture.needsUpdate) {
                if (!texture.image.__webglTextureCube) {
                    texture.addEventListener("dispose", onTextureDispose);
                    texture.image.__webglTextureCube = _gl.createTexture();
                    _this.info.memory.textures++;
                }
                _gl.activeTexture(_gl.TEXTURE0 + slot);
                _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                var isCompressed = texture instanceof THREE.CompressedTexture;
                var isDataTexture = texture.image[0] instanceof THREE.DataTexture;
                var cubeImage = [];
                for (var i = 0; i < 6; i++) {
                    if (_this.autoScaleCubemaps && !isCompressed && !isDataTexture) {
                        cubeImage[i] = clampToMaxSize(texture.image[i], _maxCubemapSize);
                    } else {
                        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                    }
                }
                var image = cubeImage[0], isImagePowerOfTwo = THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo);
                for (var i = 0; i < 6; i++) {
                    if (!isCompressed) {
                        if (isDataTexture) {
                            _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                        } else {
                            _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                        }
                    } else {
                        var mipmap, mipmaps = cubeImage[i].mipmaps;
                        for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                            mipmap = mipmaps[j];
                            if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                                if (getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                    _gl.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                } else {
                                    THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()");
                                }
                            } else {
                                _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                            }
                        }
                    }
                }
                if (texture.generateMipmaps && isImagePowerOfTwo) {
                    _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                }
                texture.needsUpdate = false;
                if (texture.onUpdate) texture.onUpdate();
            } else {
                _gl.activeTexture(_gl.TEXTURE0 + slot);
                _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
            }
        }
    }
    function setCubeTextureDynamic(texture, slot) {
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.__webglTexture);
    }
    function setupFrameBuffer(framebuffer, renderTarget, textureTarget) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0);
    }
    function setupRenderBuffer(renderbuffer, renderTarget) {
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
        }
    }
    this.setRenderTarget = function(renderTarget) {
        var isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;
        if (renderTarget && renderTarget.__webglFramebuffer === undefined) {
            if (renderTarget.depthBuffer === undefined) renderTarget.depthBuffer = true;
            if (renderTarget.stencilBuffer === undefined) renderTarget.stencilBuffer = true;
            renderTarget.addEventListener("dispose", onRenderTargetDispose);
            renderTarget.__webglTexture = _gl.createTexture();
            _this.info.memory.textures++;
            var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo(renderTarget.width) && THREE.Math.isPowerOfTwo(renderTarget.height), glFormat = paramThreeToGL(renderTarget.format), glType = paramThreeToGL(renderTarget.type);
            if (isCube) {
                renderTarget.__webglFramebuffer = [];
                renderTarget.__webglRenderbuffer = [];
                _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo);
                for (var i = 0; i < 6; i++) {
                    renderTarget.__webglFramebuffer[i] = _gl.createFramebuffer();
                    renderTarget.__webglRenderbuffer[i] = _gl.createRenderbuffer();
                    _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
                    setupFrameBuffer(renderTarget.__webglFramebuffer[i], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                    setupRenderBuffer(renderTarget.__webglRenderbuffer[i], renderTarget);
                }
                if (isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            } else {
                renderTarget.__webglFramebuffer = _gl.createFramebuffer();
                if (renderTarget.shareDepthFrom) {
                    renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
                } else {
                    renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();
                }
                _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
                setTextureParameters(_gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo);
                _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
                setupFrameBuffer(renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D);
                if (renderTarget.shareDepthFrom) {
                    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);
                    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);
                    }
                } else {
                    setupRenderBuffer(renderTarget.__webglRenderbuffer, renderTarget);
                }
                if (isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_2D);
            }
            if (isCube) {
                _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
            } else {
                _gl.bindTexture(_gl.TEXTURE_2D, null);
            }
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        var framebuffer, width, height, vx, vy;
        if (renderTarget) {
            if (isCube) {
                framebuffer = renderTarget.__webglFramebuffer[renderTarget.activeCubeFace];
            } else {
                framebuffer = renderTarget.__webglFramebuffer;
            }
            width = renderTarget.width;
            height = renderTarget.height;
            vx = 0;
            vy = 0;
        } else {
            framebuffer = null;
            width = _viewportWidth;
            height = _viewportHeight;
            vx = _viewportX;
            vy = _viewportY;
        }
        if (framebuffer !== _currentFramebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            _gl.viewport(vx, vy, width, height);
            _currentFramebuffer = framebuffer;
        }
        _currentWidth = width;
        _currentHeight = height;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
        if (!(renderTarget instanceof THREE.WebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
        }
        if (renderTarget.__webglFramebuffer) {
            if (renderTarget.format !== THREE.RGBAFormat) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.");
                return;
            }
            var restore = false;
            if (renderTarget.__webglFramebuffer !== _currentFramebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTarget.__webglFramebuffer);
                restore = true;
            }
            if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                _gl.readPixels(x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer);
            } else {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
            }
            if (restore) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
            }
        }
    };
    function updateRenderTargetMipmap(renderTarget) {
        if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);
            _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        } else {
            _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
            _gl.generateMipmap(_gl.TEXTURE_2D);
            _gl.bindTexture(_gl.TEXTURE_2D, null);
        }
    }
    function filterFallback(f) {
        if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
            return _gl.NEAREST;
        }
        return _gl.LINEAR;
    }
    function paramThreeToGL(p) {
        var extension;
        if (p === THREE.RepeatWrapping) return _gl.REPEAT;
        if (p === THREE.ClampToEdgeWrapping) return _gl.CLAMP_TO_EDGE;
        if (p === THREE.MirroredRepeatWrapping) return _gl.MIRRORED_REPEAT;
        if (p === THREE.NearestFilter) return _gl.NEAREST;
        if (p === THREE.NearestMipMapNearestFilter) return _gl.NEAREST_MIPMAP_NEAREST;
        if (p === THREE.NearestMipMapLinearFilter) return _gl.NEAREST_MIPMAP_LINEAR;
        if (p === THREE.LinearFilter) return _gl.LINEAR;
        if (p === THREE.LinearMipMapNearestFilter) return _gl.LINEAR_MIPMAP_NEAREST;
        if (p === THREE.LinearMipMapLinearFilter) return _gl.LINEAR_MIPMAP_LINEAR;
        if (p === THREE.UnsignedByteType) return _gl.UNSIGNED_BYTE;
        if (p === THREE.UnsignedShort4444Type) return _gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === THREE.UnsignedShort5551Type) return _gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === THREE.UnsignedShort565Type) return _gl.UNSIGNED_SHORT_5_6_5;
        if (p === THREE.ByteType) return _gl.BYTE;
        if (p === THREE.ShortType) return _gl.SHORT;
        if (p === THREE.UnsignedShortType) return _gl.UNSIGNED_SHORT;
        if (p === THREE.IntType) return _gl.INT;
        if (p === THREE.UnsignedIntType) return _gl.UNSIGNED_INT;
        if (p === THREE.FloatType) return _gl.FLOAT;
        extension = extensions.get("OES_texture_half_float");
        if (extension !== null) {
            if (p === THREE.HalfFloatType) return extension.HALF_FLOAT_OES;
        }
        if (p === THREE.AlphaFormat) return _gl.ALPHA;
        if (p === THREE.RGBFormat) return _gl.RGB;
        if (p === THREE.RGBAFormat) return _gl.RGBA;
        if (p === THREE.LuminanceFormat) return _gl.LUMINANCE;
        if (p === THREE.LuminanceAlphaFormat) return _gl.LUMINANCE_ALPHA;
        if (p === THREE.AddEquation) return _gl.FUNC_ADD;
        if (p === THREE.SubtractEquation) return _gl.FUNC_SUBTRACT;
        if (p === THREE.ReverseSubtractEquation) return _gl.FUNC_REVERSE_SUBTRACT;
        if (p === THREE.ZeroFactor) return _gl.ZERO;
        if (p === THREE.OneFactor) return _gl.ONE;
        if (p === THREE.SrcColorFactor) return _gl.SRC_COLOR;
        if (p === THREE.OneMinusSrcColorFactor) return _gl.ONE_MINUS_SRC_COLOR;
        if (p === THREE.SrcAlphaFactor) return _gl.SRC_ALPHA;
        if (p === THREE.OneMinusSrcAlphaFactor) return _gl.ONE_MINUS_SRC_ALPHA;
        if (p === THREE.DstAlphaFactor) return _gl.DST_ALPHA;
        if (p === THREE.OneMinusDstAlphaFactor) return _gl.ONE_MINUS_DST_ALPHA;
        if (p === THREE.DstColorFactor) return _gl.DST_COLOR;
        if (p === THREE.OneMinusDstColorFactor) return _gl.ONE_MINUS_DST_COLOR;
        if (p === THREE.SrcAlphaSaturateFactor) return _gl.SRC_ALPHA_SATURATE;
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
            if (p === THREE.RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p === THREE.RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p === THREE.RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p === THREE.RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
            if (p === THREE.RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (p === THREE.RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (p === THREE.RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (p === THREE.RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        extension = extensions.get("EXT_blend_minmax");
        if (extension !== null) {
            if (p === THREE.MinEquation) return extension.MIN_EXT;
            if (p === THREE.MaxEquation) return extension.MAX_EXT;
        }
        return 0;
    }
    function allocateBones(object) {
        if (_supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
            return 1024;
        } else {
            var nVertexUniforms = _gl.getParameter(_gl.MAX_VERTEX_UNIFORM_VECTORS);
            var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            var maxBones = nVertexMatrices;
            if (object !== undefined && object instanceof THREE.SkinnedMesh) {
                maxBones = Math.min(object.skeleton.bones.length, maxBones);
                if (maxBones < object.skeleton.bones.length) {
                    THREE.warn("WebGLRenderer: too many bones - " + object.skeleton.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)");
                }
            }
            return maxBones;
        }
    }
    function allocateLights(lights) {
        var dirLights = 0;
        var pointLights = 0;
        var spotLights = 0;
        var hemiLights = 0;
        for (var l = 0, ll = lights.length; l < ll; l++) {
            var light = lights[l];
            if (light.onlyShadow || light.visible === false) continue;
            if (light instanceof THREE.DirectionalLight) dirLights++;
            if (light instanceof THREE.PointLight) pointLights++;
            if (light instanceof THREE.SpotLight) spotLights++;
            if (light instanceof THREE.HemisphereLight) hemiLights++;
        }
        return {
            directional: dirLights,
            point: pointLights,
            spot: spotLights,
            hemi: hemiLights
        };
    }
    function allocateShadows(lights) {
        var maxShadows = 0;
        for (var l = 0, ll = lights.length; l < ll; l++) {
            var light = lights[l];
            if (!light.castShadow) continue;
            if (light instanceof THREE.SpotLight) maxShadows++;
            if (light instanceof THREE.DirectionalLight && !light.shadowCascade) maxShadows++;
        }
        return maxShadows;
    }
    this.initMaterial = function() {
        THREE.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    };
    this.addPrePlugin = function() {
        THREE.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    };
    this.addPostPlugin = function() {
        THREE.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    };
    this.updateShadowMap = function() {
        THREE.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    };
};

THREE.WebGLRenderTarget = function(width, height, options) {
    this.width = width;
    this.height = height;
    options = options || {};
    this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;
    this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
    this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;
    this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;
    this.offset = new THREE.Vector2(0, 0);
    this.repeat = new THREE.Vector2(1, 1);
    this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
    this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    this.generateMipmaps = true;
    this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;
};

THREE.WebGLRenderTarget.prototype = {
    constructor: THREE.WebGLRenderTarget,
    setSize: function(width, height) {
        this.width = width;
        this.height = height;
    },
    clone: function() {
        var tmp = new THREE.WebGLRenderTarget(this.width, this.height);
        tmp.wrapS = this.wrapS;
        tmp.wrapT = this.wrapT;
        tmp.magFilter = this.magFilter;
        tmp.minFilter = this.minFilter;
        tmp.anisotropy = this.anisotropy;
        tmp.offset.copy(this.offset);
        tmp.repeat.copy(this.repeat);
        tmp.format = this.format;
        tmp.type = this.type;
        tmp.depthBuffer = this.depthBuffer;
        tmp.stencilBuffer = this.stencilBuffer;
        tmp.generateMipmaps = this.generateMipmaps;
        tmp.shareDepthFrom = this.shareDepthFrom;
        return tmp;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
};

THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);

THREE.WebGLRenderTargetCube = function(width, height, options) {
    THREE.WebGLRenderTarget.call(this, width, height, options);
    this.activeCubeFace = 0;
};

THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);

THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

THREE.WebGLExtensions = function(gl) {
    var extensions = {};
    this.get = function(name) {
        if (extensions[name] !== undefined) {
            return extensions[name];
        }
        var extension;
        switch (name) {
          case "EXT_texture_filter_anisotropic":
            extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;

          case "WEBGL_compressed_texture_s3tc":
            extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;

          case "WEBGL_compressed_texture_pvrtc":
            extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;

          default:
            extension = gl.getExtension(name);
        }
        if (extension === null) {
            THREE.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        extensions[name] = extension;
        return extension;
    };
};

THREE.WebGLProgram = function() {
    var programIdCount = 0;
    var generateDefines = function(defines) {
        var value, chunk, chunks = [];
        for (var d in defines) {
            value = defines[d];
            if (value === false) continue;
            chunk = "#define " + d + " " + value;
            chunks.push(chunk);
        }
        return chunks.join("\n");
    };
    var cacheUniformLocations = function(gl, program, identifiers) {
        var uniforms = {};
        for (var i = 0, l = identifiers.length; i < l; i++) {
            var id = identifiers[i];
            uniforms[id] = gl.getUniformLocation(program, id);
        }
        return uniforms;
    };
    var cacheAttributeLocations = function(gl, program, identifiers) {
        var attributes = {};
        for (var i = 0, l = identifiers.length; i < l; i++) {
            var id = identifiers[i];
            attributes[id] = gl.getAttribLocation(program, id);
        }
        return attributes;
    };
    return function(renderer, code, material, parameters) {
        var _this = renderer;
        var _gl = _this.context;
        var defines = material.defines;
        var uniforms = material.__webglShader.uniforms;
        var attributes = material.attributes;
        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;
        var index0AttributeName = material.index0AttributeName;
        if (index0AttributeName === undefined && parameters.morphTargets === true) {
            index0AttributeName = "position";
        }
        var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
        if (parameters.shadowMapType === THREE.PCFShadowMap) {
            shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
        } else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
            shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
        }
        var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
        var envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        if (parameters.envMap) {
            switch (material.envMap.mapping) {
              case THREE.CubeReflectionMapping:
              case THREE.CubeRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                break;

              case THREE.EquirectangularReflectionMapping:
              case THREE.EquirectangularRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
                break;

              case THREE.SphericalReflectionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
                break;
            }
            switch (material.envMap.mapping) {
              case THREE.CubeRefractionMapping:
              case THREE.EquirectangularRefractionMapping:
                envMapModeDefine = "ENVMAP_MODE_REFRACTION";
                break;
            }
            switch (material.combine) {
              case THREE.MultiplyOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                break;

              case THREE.MixOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                break;

              case THREE.AddOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
                break;
            }
        }
        var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
        var customDefines = generateDefines(defines);
        var program = _gl.createProgram();
        var prefix_vertex, prefix_fragment;
        if (material instanceof THREE.RawShaderMaterial) {
            prefix_vertex = "";
            prefix_fragment = "";
        } else {
            prefix_vertex = [ "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", customDefines, parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", _this.gammaInput ? "#define GAMMA_INPUT" : "", _this.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_DIR_LIGHTS " + parameters.maxDirLights, "#define MAX_POINT_LIGHTS " + parameters.maxPointLights, "#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights, "#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights, "#define MAX_SHADOWS " + parameters.maxShadows, "#define MAX_BONES " + parameters.maxBones, parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals ? "#define USE_MORPHNORMALS" : "", parameters.wrapAround ? "#define WRAP_AROUND" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "attribute vec2 uv2;", "#ifdef USE_COLOR", "   attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "   attribute vec3 morphTarget0;", "   attribute vec3 morphTarget1;", "   attribute vec3 morphTarget2;", "   attribute vec3 morphTarget3;", "   #ifdef USE_MORPHNORMALS", "       attribute vec3 morphNormal0;", "       attribute vec3 morphNormal1;", "       attribute vec3 morphNormal2;", "       attribute vec3 morphNormal3;", "   #else", "       attribute vec3 morphTarget4;", "       attribute vec3 morphTarget5;", "       attribute vec3 morphTarget6;", "       attribute vec3 morphTarget7;", "   #endif", "#endif", "#ifdef USE_SKINNING", "   attribute vec4 skinIndex;", "   attribute vec4 skinWeight;", "#endif", "" ].join("\n");
            prefix_fragment = [ "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", parameters.bumpMap || parameters.normalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", customDefines, "#define MAX_DIR_LIGHTS " + parameters.maxDirLights, "#define MAX_POINT_LIGHTS " + parameters.maxPointLights, "#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights, "#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights, "#define MAX_SHADOWS " + parameters.maxShadows, parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest : "", _this.gammaInput ? "#define GAMMA_INPUT" : "", _this.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapTypeDefine : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.envMap ? "#define " + envMapBlendingDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.metal ? "#define METAL" : "", parameters.wrapAround ? "#define WRAP_AROUND" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "" ].join("\n");
        }
        var glVertexShader = new THREE.WebGLShader(_gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader);
        var glFragmentShader = new THREE.WebGLShader(_gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader);
        _gl.attachShader(program, glVertexShader);
        _gl.attachShader(program, glFragmentShader);
        if (index0AttributeName !== undefined) {
            _gl.bindAttribLocation(program, 0, index0AttributeName);
        }
        _gl.linkProgram(program);
        var programLogInfo = _gl.getProgramInfoLog(program);
        if (_gl.getProgramParameter(program, _gl.LINK_STATUS) === false) {
            THREE.error("THREE.WebGLProgram: shader error: " + _gl.getError(), "gl.VALIDATE_STATUS", _gl.getProgramParameter(program, _gl.VALIDATE_STATUS), "gl.getPRogramInfoLog", programLogInfo);
        }
        if (programLogInfo !== "") {
            THREE.warn("THREE.WebGLProgram: gl.getProgramInfoLog()" + programLogInfo);
        }
        _gl.deleteShader(glVertexShader);
        _gl.deleteShader(glFragmentShader);
        var identifiers = [ "viewMatrix", "modelViewMatrix", "projectionMatrix", "normalMatrix", "modelMatrix", "cameraPosition", "morphTargetInfluences", "bindMatrix", "bindMatrixInverse" ];
        if (parameters.useVertexTexture) {
            identifiers.push("boneTexture");
            identifiers.push("boneTextureWidth");
            identifiers.push("boneTextureHeight");
        } else {
            identifiers.push("boneGlobalMatrices");
        }
        if (parameters.logarithmicDepthBuffer) {
            identifiers.push("logDepthBufFC");
        }
        for (var u in uniforms) {
            identifiers.push(u);
        }
        this.uniforms = cacheUniformLocations(_gl, program, identifiers);
        identifiers = [ "position", "normal", "uv", "uv2", "tangent", "color", "skinIndex", "skinWeight", "lineDistance" ];
        for (var i = 0; i < parameters.maxMorphTargets; i++) {
            identifiers.push("morphTarget" + i);
        }
        for (var i = 0; i < parameters.maxMorphNormals; i++) {
            identifiers.push("morphNormal" + i);
        }
        for (var a in attributes) {
            identifiers.push(a);
        }
        this.attributes = cacheAttributeLocations(_gl, program, identifiers);
        this.attributesKeys = Object.keys(this.attributes);
        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
    };
}();

THREE.WebGLShader = function() {
    var addLineNumbers = function(string) {
        var lines = string.split("\n");
        for (var i = 0; i < lines.length; i++) {
            lines[i] = i + 1 + ": " + lines[i];
        }
        return lines.join("\n");
    };
    return function(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
            THREE.error("THREE.WebGLShader: Shader couldn't compile.");
        }
        if (gl.getShaderInfoLog(shader) !== "") {
            THREE.warn("THREE.WebGLShader: gl.getShaderInfoLog()", gl.getShaderInfoLog(shader), addLineNumbers(string));
        }
        return shader;
    };
}();

THREE.WebGLState = function(gl, paramThreeToGL) {
    var newAttributes = new Uint8Array(16);
    var enabledAttributes = new Uint8Array(16);
    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;
    var currentDepthTest = null;
    var currentDepthWrite = null;
    var currentColorWrite = null;
    var currentDoubleSided = null;
    var currentFlipSided = null;
    var currentLineWidth = null;
    var currentPolygonOffset = null;
    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;
    this.initAttributes = function() {
        for (var i = 0, l = newAttributes.length; i < l; i++) {
            newAttributes[i] = 0;
        }
    };
    this.enableAttribute = function(attribute) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
    };
    this.disableUnusedAttributes = function() {
        for (var i = 0, l = enabledAttributes.length; i < l; i++) {
            if (enabledAttributes[i] !== newAttributes[i]) {
                gl.disableVertexAttribArray(i);
                enabledAttributes[i] = 0;
            }
        }
    };
    this.setBlending = function(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha) {
        if (blending !== currentBlending) {
            if (blending === THREE.NoBlending) {
                gl.disable(gl.BLEND);
            } else if (blending === THREE.AdditiveBlending) {
                gl.enable(gl.BLEND);
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            } else if (blending === THREE.SubtractiveBlending) {
                gl.enable(gl.BLEND);
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
            } else if (blending === THREE.MultiplyBlending) {
                gl.enable(gl.BLEND);
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
            } else if (blending === THREE.CustomBlending) {
                gl.enable(gl.BLEND);
            } else {
                gl.enable(gl.BLEND);
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }
            currentBlending = blending;
        }
        if (blending === THREE.CustomBlending) {
            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;
            if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;
            }
            if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;
            }
        } else {
            currentBlendEquation = null;
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendEquationAlpha = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;
        }
    };
    this.setDepthTest = function(depthTest) {
        if (currentDepthTest !== depthTest) {
            if (depthTest) {
                gl.enable(gl.DEPTH_TEST);
            } else {
                gl.disable(gl.DEPTH_TEST);
            }
            currentDepthTest = depthTest;
        }
    };
    this.setDepthWrite = function(depthWrite) {
        if (currentDepthWrite !== depthWrite) {
            gl.depthMask(depthWrite);
            currentDepthWrite = depthWrite;
        }
    };
    this.setColorWrite = function(colorWrite) {
        if (currentColorWrite !== colorWrite) {
            gl.colorMask(colorWrite, colorWrite, colorWrite, colorWrite);
            currentColorWrite = colorWrite;
        }
    };
    this.setDoubleSided = function(doubleSided) {
        if (currentDoubleSided !== doubleSided) {
            if (doubleSided) {
                gl.disable(gl.CULL_FACE);
            } else {
                gl.enable(gl.CULL_FACE);
            }
            currentDoubleSided = doubleSided;
        }
    };
    this.setFlipSided = function(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) {
                gl.frontFace(gl.CW);
            } else {
                gl.frontFace(gl.CCW);
            }
            currentFlipSided = flipSided;
        }
    };
    this.setLineWidth = function(width) {
        if (width !== currentLineWidth) {
            gl.lineWidth(width);
            currentLineWidth = width;
        }
    };
    this.setPolygonOffset = function(polygonoffset, factor, units) {
        if (currentPolygonOffset !== polygonoffset) {
            if (polygonoffset) {
                gl.enable(gl.POLYGON_OFFSET_FILL);
            } else {
                gl.disable(gl.POLYGON_OFFSET_FILL);
            }
            currentPolygonOffset = polygonoffset;
        }
        if (polygonoffset && (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units)) {
            gl.polygonOffset(factor, units);
            currentPolygonOffsetFactor = factor;
            currentPolygonOffsetUnits = units;
        }
    };
    this.reset = function() {
        for (var i = 0; i < enabledAttributes.length; i++) {
            enabledAttributes[i] = 0;
        }
        currentBlending = null;
        currentDepthTest = null;
        currentDepthWrite = null;
        currentColorWrite = null;
        currentDoubleSided = null;
        currentFlipSided = null;
    };
};

THREE.LensFlarePlugin = function(renderer, flares) {
    var gl = renderer.context;
    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;
    var hasVertexTexture;
    var tempTexture, occlusionTexture;
    var init = function() {
        var vertices = new Float32Array([ -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1 ]);
        var faces = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        tempTexture = gl.createTexture();
        occlusionTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, occlusionTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        hasVertexTexture = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
        var shader;
        if (hasVertexTexture) {
            shader = {
                vertexShader: [ "uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}" ].join("\n"),
                fragmentShader: [ "uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}" ].join("\n")
            };
        } else {
            shader = {
                vertexShader: [ "uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}" ].join("\n"),
                fragmentShader: [ "precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}" ].join("\n")
            };
        }
        program = createProgram(shader);
        attributes = {
            vertex: gl.getAttribLocation(program, "position"),
            uv: gl.getAttribLocation(program, "uv")
        };
        uniforms = {
            renderType: gl.getUniformLocation(program, "renderType"),
            map: gl.getUniformLocation(program, "map"),
            occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
            opacity: gl.getUniformLocation(program, "opacity"),
            color: gl.getUniformLocation(program, "color"),
            scale: gl.getUniformLocation(program, "scale"),
            rotation: gl.getUniformLocation(program, "rotation"),
            screenPosition: gl.getUniformLocation(program, "screenPosition")
        };
    };
    this.render = function(scene, camera, viewportWidth, viewportHeight) {
        if (flares.length === 0) return;
        var tempPosition = new THREE.Vector3();
        var invAspect = viewportHeight / viewportWidth, halfViewportWidth = viewportWidth * .5, halfViewportHeight = viewportHeight * .5;
        var size = 16 / viewportHeight, scale = new THREE.Vector2(size * invAspect, size);
        var screenPosition = new THREE.Vector3(1, 1, 0), screenPositionPixels = new THREE.Vector2(1, 1);
        if (program === undefined) {
            init();
        }
        gl.useProgram(program);
        gl.enableVertexAttribArray(attributes.vertex);
        gl.enableVertexAttribArray(attributes.uv);
        gl.uniform1i(uniforms.occlusionMap, 0);
        gl.uniform1i(uniforms.map, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.disable(gl.CULL_FACE);
        gl.depthMask(false);
        for (var i = 0, l = flares.length; i < l; i++) {
            size = 16 / viewportHeight;
            scale.set(size * invAspect, size);
            var flare = flares[i];
            tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
            tempPosition.applyMatrix4(camera.matrixWorldInverse);
            tempPosition.applyProjection(camera.projectionMatrix);
            screenPosition.copy(tempPosition);
            screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
            screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
            if (hasVertexTexture || screenPositionPixels.x > 0 && screenPositionPixels.x < viewportWidth && screenPositionPixels.y > 0 && screenPositionPixels.y < viewportHeight) {
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, tempTexture);
                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
                gl.uniform1i(uniforms.renderType, 0);
                gl.uniform2f(uniforms.scale, scale.x, scale.y);
                gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                gl.disable(gl.BLEND);
                gl.enable(gl.DEPTH_TEST);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, occlusionTexture);
                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
                gl.uniform1i(uniforms.renderType, 1);
                gl.disable(gl.DEPTH_TEST);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, tempTexture);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                flare.positionScreen.copy(screenPosition);
                if (flare.customUpdateCallback) {
                    flare.customUpdateCallback(flare);
                } else {
                    flare.updateLensFlares();
                }
                gl.uniform1i(uniforms.renderType, 2);
                gl.enable(gl.BLEND);
                for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                    var sprite = flare.lensFlares[j];
                    if (sprite.opacity > .001 && sprite.scale > .001) {
                        screenPosition.x = sprite.x;
                        screenPosition.y = sprite.y;
                        screenPosition.z = sprite.z;
                        size = sprite.size * sprite.scale / viewportHeight;
                        scale.x = size * invAspect;
                        scale.y = size;
                        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                        gl.uniform2f(uniforms.scale, scale.x, scale.y);
                        gl.uniform1f(uniforms.rotation, sprite.rotation);
                        gl.uniform1f(uniforms.opacity, sprite.opacity);
                        gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                        renderer.state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                        renderer.setTexture(sprite.texture, 1);
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    }
                }
            }
        }
        gl.enable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        renderer.resetGLState();
    };
    function createProgram(shader) {
        var program = gl.createProgram();
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var prefix = "precision " + renderer.getPrecision() + " float;\n";
        gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
        gl.shaderSource(vertexShader, prefix + shader.vertexShader);
        gl.compileShader(fragmentShader);
        gl.compileShader(vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.linkProgram(program);
        return program;
    }
};

THREE.ShadowMapPlugin = function(_renderer, _lights, _webglObjects, _webglObjectsImmediate) {
    var _gl = _renderer.context;
    var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4(), _min = new THREE.Vector3(), _max = new THREE.Vector3(), _matrixPosition = new THREE.Vector3(), _renderList = [];
    var depthShader = THREE.ShaderLib["depthRGBA"];
    var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
    _depthMaterial = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader
    });
    _depthMaterialMorph = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true
    });
    _depthMaterialSkin = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        skinning: true
    });
    _depthMaterialMorphSkin = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true,
        skinning: true
    });
    _depthMaterial._shadowPass = true;
    _depthMaterialMorph._shadowPass = true;
    _depthMaterialSkin._shadowPass = true;
    _depthMaterialMorphSkin._shadowPass = true;
    this.render = function(scene, camera) {
        if (_renderer.shadowMapEnabled === false) return;
        var i, il, j, jl, n, shadowMap, shadowMatrix, shadowCamera, buffer, material, webglObject, object, light, lights = [], k = 0, fog = null;
        _gl.clearColor(1, 1, 1, 1);
        _gl.disable(_gl.BLEND);
        _gl.enable(_gl.CULL_FACE);
        _gl.frontFace(_gl.CCW);
        if (_renderer.shadowMapCullFace === THREE.CullFaceFront) {
            _gl.cullFace(_gl.FRONT);
        } else {
            _gl.cullFace(_gl.BACK);
        }
        _renderer.state.setDepthTest(true);
        for (i = 0, il = _lights.length; i < il; i++) {
            light = _lights[i];
            if (!light.castShadow) continue;
            if (light instanceof THREE.DirectionalLight && light.shadowCascade) {
                for (n = 0; n < light.shadowCascadeCount; n++) {
                    var virtualLight;
                    if (!light.shadowCascadeArray[n]) {
                        virtualLight = createVirtualLight(light, n);
                        virtualLight.originalCamera = camera;
                        var gyro = new THREE.Gyroscope();
                        gyro.position.copy(light.shadowCascadeOffset);
                        gyro.add(virtualLight);
                        gyro.add(virtualLight.target);
                        camera.add(gyro);
                        light.shadowCascadeArray[n] = virtualLight;
                    } else {
                        virtualLight = light.shadowCascadeArray[n];
                    }
                    updateVirtualLight(light, n);
                    lights[k] = virtualLight;
                    k++;
                }
            } else {
                lights[k] = light;
                k++;
            }
        }
        for (i = 0, il = lights.length; i < il; i++) {
            light = lights[i];
            if (!light.shadowMap) {
                var shadowFilter = THREE.LinearFilter;
                if (_renderer.shadowMapType === THREE.PCFSoftShadowMap) {
                    shadowFilter = THREE.NearestFilter;
                }
                var pars = {
                    minFilter: shadowFilter,
                    magFilter: shadowFilter,
                    format: THREE.RGBAFormat
                };
                light.shadowMap = new THREE.WebGLRenderTarget(light.shadowMapWidth, light.shadowMapHeight, pars);
                light.shadowMapSize = new THREE.Vector2(light.shadowMapWidth, light.shadowMapHeight);
                light.shadowMatrix = new THREE.Matrix4();
            }
            if (!light.shadowCamera) {
                if (light instanceof THREE.SpotLight) {
                    light.shadowCamera = new THREE.PerspectiveCamera(light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar);
                } else if (light instanceof THREE.DirectionalLight) {
                    light.shadowCamera = new THREE.OrthographicCamera(light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar);
                } else {
                    THREE.error("THREE.ShadowMapPlugin: Unsupported light type for shadow", light);
                    continue;
                }
                scene.add(light.shadowCamera);
                if (scene.autoUpdate === true) scene.updateMatrixWorld();
            }
            if (light.shadowCameraVisible && !light.cameraHelper) {
                light.cameraHelper = new THREE.CameraHelper(light.shadowCamera);
                scene.add(light.cameraHelper);
            }
            if (light.isVirtual && virtualLight.originalCamera == camera) {
                updateShadowCamera(camera, light);
            }
            shadowMap = light.shadowMap;
            shadowMatrix = light.shadowMatrix;
            shadowCamera = light.shadowCamera;
            shadowCamera.position.setFromMatrixPosition(light.matrixWorld);
            _matrixPosition.setFromMatrixPosition(light.target.matrixWorld);
            shadowCamera.lookAt(_matrixPosition);
            shadowCamera.updateMatrixWorld();
            shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
            if (light.cameraHelper) light.cameraHelper.visible = light.shadowCameraVisible;
            if (light.shadowCameraVisible) light.cameraHelper.update();
            shadowMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
            shadowMatrix.multiply(shadowCamera.projectionMatrix);
            shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
            _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
            _frustum.setFromMatrix(_projScreenMatrix);
            _renderer.setRenderTarget(shadowMap);
            _renderer.clear();
            _renderList.length = 0;
            projectObject(scene, scene, shadowCamera);
            var objectMaterial, useMorphing, useSkinning;
            for (j = 0, jl = _renderList.length; j < jl; j++) {
                webglObject = _renderList[j];
                object = webglObject.object;
                buffer = webglObject.buffer;
                objectMaterial = getObjectMaterial(object);
                useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
                useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
                if (object.customDepthMaterial) {
                    material = object.customDepthMaterial;
                } else if (useSkinning) {
                    material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
                } else if (useMorphing) {
                    material = _depthMaterialMorph;
                } else {
                    material = _depthMaterial;
                }
                _renderer.setMaterialFaces(objectMaterial);
                if (buffer instanceof THREE.BufferGeometry) {
                    _renderer.renderBufferDirect(shadowCamera, _lights, fog, material, buffer, object);
                } else {
                    _renderer.renderBuffer(shadowCamera, _lights, fog, material, buffer, object);
                }
            }
            for (j = 0, jl = _webglObjectsImmediate.length; j < jl; j++) {
                webglObject = _webglObjectsImmediate[j];
                object = webglObject.object;
                if (object.visible && object.castShadow) {
                    object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    _renderer.renderImmediateObject(shadowCamera, _lights, fog, _depthMaterial, object);
                }
            }
        }
        var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
        _gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearAlpha);
        _gl.enable(_gl.BLEND);
        if (_renderer.shadowMapCullFace === THREE.CullFaceFront) {
            _gl.cullFace(_gl.BACK);
        }
        _renderer.resetGLState();
    };
    function projectObject(scene, object, shadowCamera) {
        if (object.visible) {
            var webglObjects = _webglObjects[object.id];
            if (webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
                for (var i = 0, l = webglObjects.length; i < l; i++) {
                    var webglObject = webglObjects[i];
                    object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    _renderList.push(webglObject);
                }
            }
            for (var i = 0, l = object.children.length; i < l; i++) {
                projectObject(scene, object.children[i], shadowCamera);
            }
        }
    }
    function createVirtualLight(light, cascade) {
        var virtualLight = new THREE.DirectionalLight();
        virtualLight.isVirtual = true;
        virtualLight.onlyShadow = true;
        virtualLight.castShadow = true;
        virtualLight.shadowCameraNear = light.shadowCameraNear;
        virtualLight.shadowCameraFar = light.shadowCameraFar;
        virtualLight.shadowCameraLeft = light.shadowCameraLeft;
        virtualLight.shadowCameraRight = light.shadowCameraRight;
        virtualLight.shadowCameraBottom = light.shadowCameraBottom;
        virtualLight.shadowCameraTop = light.shadowCameraTop;
        virtualLight.shadowCameraVisible = light.shadowCameraVisible;
        virtualLight.shadowDarkness = light.shadowDarkness;
        virtualLight.shadowBias = light.shadowCascadeBias[cascade];
        virtualLight.shadowMapWidth = light.shadowCascadeWidth[cascade];
        virtualLight.shadowMapHeight = light.shadowCascadeHeight[cascade];
        virtualLight.pointsWorld = [];
        virtualLight.pointsFrustum = [];
        var pointsWorld = virtualLight.pointsWorld, pointsFrustum = virtualLight.pointsFrustum;
        for (var i = 0; i < 8; i++) {
            pointsWorld[i] = new THREE.Vector3();
            pointsFrustum[i] = new THREE.Vector3();
        }
        var nearZ = light.shadowCascadeNearZ[cascade];
        var farZ = light.shadowCascadeFarZ[cascade];
        pointsFrustum[0].set(-1, -1, nearZ);
        pointsFrustum[1].set(1, -1, nearZ);
        pointsFrustum[2].set(-1, 1, nearZ);
        pointsFrustum[3].set(1, 1, nearZ);
        pointsFrustum[4].set(-1, -1, farZ);
        pointsFrustum[5].set(1, -1, farZ);
        pointsFrustum[6].set(-1, 1, farZ);
        pointsFrustum[7].set(1, 1, farZ);
        return virtualLight;
    }
    function updateVirtualLight(light, cascade) {
        var virtualLight = light.shadowCascadeArray[cascade];
        virtualLight.position.copy(light.position);
        virtualLight.target.position.copy(light.target.position);
        virtualLight.lookAt(virtualLight.target);
        virtualLight.shadowCameraVisible = light.shadowCameraVisible;
        virtualLight.shadowDarkness = light.shadowDarkness;
        virtualLight.shadowBias = light.shadowCascadeBias[cascade];
        var nearZ = light.shadowCascadeNearZ[cascade];
        var farZ = light.shadowCascadeFarZ[cascade];
        var pointsFrustum = virtualLight.pointsFrustum;
        pointsFrustum[0].z = nearZ;
        pointsFrustum[1].z = nearZ;
        pointsFrustum[2].z = nearZ;
        pointsFrustum[3].z = nearZ;
        pointsFrustum[4].z = farZ;
        pointsFrustum[5].z = farZ;
        pointsFrustum[6].z = farZ;
        pointsFrustum[7].z = farZ;
    }
    function updateShadowCamera(camera, light) {
        var shadowCamera = light.shadowCamera, pointsFrustum = light.pointsFrustum, pointsWorld = light.pointsWorld;
        _min.set(Infinity, Infinity, Infinity);
        _max.set(-Infinity, -Infinity, -Infinity);
        for (var i = 0; i < 8; i++) {
            var p = pointsWorld[i];
            p.copy(pointsFrustum[i]);
            p.unproject(camera);
            p.applyMatrix4(shadowCamera.matrixWorldInverse);
            if (p.x < _min.x) _min.x = p.x;
            if (p.x > _max.x) _max.x = p.x;
            if (p.y < _min.y) _min.y = p.y;
            if (p.y > _max.y) _max.y = p.y;
            if (p.z < _min.z) _min.z = p.z;
            if (p.z > _max.z) _max.z = p.z;
        }
        shadowCamera.left = _min.x;
        shadowCamera.right = _max.x;
        shadowCamera.top = _max.y;
        shadowCamera.bottom = _min.y;
        shadowCamera.updateProjectionMatrix();
    }
    function getObjectMaterial(object) {
        return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[0] : object.material;
    }
};

THREE.SpritePlugin = function(renderer, sprites) {
    var gl = renderer.context;
    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;
    var texture;
    var spritePosition = new THREE.Vector3();
    var spriteRotation = new THREE.Quaternion();
    var spriteScale = new THREE.Vector3();
    var init = function() {
        var vertices = new Float32Array([ -.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1 ]);
        var faces = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        program = createProgram();
        attributes = {
            position: gl.getAttribLocation(program, "position"),
            uv: gl.getAttribLocation(program, "uv")
        };
        uniforms = {
            uvOffset: gl.getUniformLocation(program, "uvOffset"),
            uvScale: gl.getUniformLocation(program, "uvScale"),
            rotation: gl.getUniformLocation(program, "rotation"),
            scale: gl.getUniformLocation(program, "scale"),
            color: gl.getUniformLocation(program, "color"),
            map: gl.getUniformLocation(program, "map"),
            opacity: gl.getUniformLocation(program, "opacity"),
            modelViewMatrix: gl.getUniformLocation(program, "modelViewMatrix"),
            projectionMatrix: gl.getUniformLocation(program, "projectionMatrix"),
            fogType: gl.getUniformLocation(program, "fogType"),
            fogDensity: gl.getUniformLocation(program, "fogDensity"),
            fogNear: gl.getUniformLocation(program, "fogNear"),
            fogFar: gl.getUniformLocation(program, "fogFar"),
            fogColor: gl.getUniformLocation(program, "fogColor"),
            alphaTest: gl.getUniformLocation(program, "alphaTest")
        };
        var canvas = document.createElement("canvas");
        canvas.width = 8;
        canvas.height = 8;
        var context = canvas.getContext("2d");
        context.fillStyle = "white";
        context.fillRect(0, 0, 8, 8);
        texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
    };
    this.render = function(scene, camera) {
        if (sprites.length === 0) return;
        if (program === undefined) {
            init();
        }
        gl.useProgram(program);
        gl.enableVertexAttribArray(attributes.position);
        gl.enableVertexAttribArray(attributes.uv);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uniforms.map, 0);
        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;
        if (fog) {
            gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
            if (fog instanceof THREE.Fog) {
                gl.uniform1f(uniforms.fogNear, fog.near);
                gl.uniform1f(uniforms.fogFar, fog.far);
                gl.uniform1i(uniforms.fogType, 1);
                oldFogType = 1;
                sceneFogType = 1;
            } else if (fog instanceof THREE.FogExp2) {
                gl.uniform1f(uniforms.fogDensity, fog.density);
                gl.uniform1i(uniforms.fogType, 2);
                oldFogType = 2;
                sceneFogType = 2;
            }
        } else {
            gl.uniform1i(uniforms.fogType, 0);
            oldFogType = 0;
            sceneFogType = 0;
        }
        for (var i = 0, l = sprites.length; i < l; i++) {
            var sprite = sprites[i];
            sprite._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
            sprite.z = -sprite._modelViewMatrix.elements[14];
        }
        sprites.sort(painterSortStable);
        var scale = [];
        for (var i = 0, l = sprites.length; i < l; i++) {
            var sprite = sprites[i];
            var material = sprite.material;
            gl.uniform1f(uniforms.alphaTest, material.alphaTest);
            gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements);
            sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
            scale[0] = spriteScale.x;
            scale[1] = spriteScale.y;
            var fogType = 0;
            if (scene.fog && material.fog) {
                fogType = sceneFogType;
            }
            if (oldFogType !== fogType) {
                gl.uniform1i(uniforms.fogType, fogType);
                oldFogType = fogType;
            }
            if (material.map !== null) {
                gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
            } else {
                gl.uniform2f(uniforms.uvOffset, 0, 0);
                gl.uniform2f(uniforms.uvScale, 1, 1);
            }
            gl.uniform1f(uniforms.opacity, material.opacity);
            gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
            gl.uniform1f(uniforms.rotation, material.rotation);
            gl.uniform2fv(uniforms.scale, scale);
            renderer.state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
            renderer.state.setDepthTest(material.depthTest);
            renderer.state.setDepthWrite(material.depthWrite);
            if (material.map && material.map.image && material.map.image.width) {
                renderer.setTexture(material.map, 0);
            } else {
                renderer.setTexture(texture, 0);
            }
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }
        gl.enable(gl.CULL_FACE);
        renderer.resetGLState();
    };
    function createProgram() {
        var program = gl.createProgram();
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, [ "precision " + renderer.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}" ].join("\n"));
        gl.shaderSource(fragmentShader, [ "precision " + renderer.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}" ].join("\n"));
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        return program;
    }
    function painterSortStable(a, b) {
        if (a.z !== b.z) {
            return b.z - a.z;
        } else {
            return b.id - a.id;
        }
    }
};

THREE.GeometryUtils = {
    merge: function(geometry1, geometry2, materialIndexOffset) {
        THREE.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
        var matrix;
        if (geometry2 instanceof THREE.Mesh) {
            geometry2.matrixAutoUpdate && geometry2.updateMatrix();
            matrix = geometry2.matrix;
            geometry2 = geometry2.geometry;
        }
        geometry1.merge(geometry2, matrix, materialIndexOffset);
    },
    center: function(geometry) {
        THREE.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
        return geometry.center();
    }
};

THREE.ImageUtils = {
    crossOrigin: undefined,
    loadTexture: function(url, mapping, onLoad, onError) {
        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;
        var texture = new THREE.Texture(undefined, mapping);
        loader.load(url, function(image) {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        }, undefined, function(event) {
            if (onError) onError(event);
        });
        texture.sourceFile = url;
        return texture;
    },
    loadTextureCube: function(array, mapping, onLoad, onError) {
        var images = [];
        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;
        var texture = new THREE.CubeTexture(images, mapping);
        texture.flipY = false;
        var loaded = 0;
        var loadTexture = function(i) {
            loader.load(array[i], function(image) {
                texture.images[i] = image;
                loaded += 1;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, undefined, onError);
        };
        for (var i = 0, il = array.length; i < il; ++i) {
            loadTexture(i);
        }
        return texture;
    },
    loadCompressedTexture: function() {
        THREE.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    },
    loadCompressedTextureCube: function() {
        THREE.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    },
    getNormalMap: function(image, depth) {
        var cross = function(a, b) {
            return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
        };
        var subtract = function(a, b) {
            return [ a[0] - b[0], a[1] - b[1], a[2] - b[2] ];
        };
        var normalize = function(a) {
            var l = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
            return [ a[0] / l, a[1] / l, a[2] / l ];
        };
        depth = depth | 1;
        var width = image.width;
        var height = image.height;
        var canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext("2d");
        context.drawImage(image, 0, 0);
        var data = context.getImageData(0, 0, width, height).data;
        var imageData = context.createImageData(width, height);
        var output = imageData.data;
        for (var x = 0; x < width; x++) {
            for (var y = 0; y < height; y++) {
                var ly = y - 1 < 0 ? 0 : y - 1;
                var uy = y + 1 > height - 1 ? height - 1 : y + 1;
                var lx = x - 1 < 0 ? 0 : x - 1;
                var ux = x + 1 > width - 1 ? width - 1 : x + 1;
                var points = [];
                var origin = [ 0, 0, data[(y * width + x) * 4] / 255 * depth ];
                points.push([ -1, 0, data[(y * width + lx) * 4] / 255 * depth ]);
                points.push([ -1, -1, data[(ly * width + lx) * 4] / 255 * depth ]);
                points.push([ 0, -1, data[(ly * width + x) * 4] / 255 * depth ]);
                points.push([ 1, -1, data[(ly * width + ux) * 4] / 255 * depth ]);
                points.push([ 1, 0, data[(y * width + ux) * 4] / 255 * depth ]);
                points.push([ 1, 1, data[(uy * width + ux) * 4] / 255 * depth ]);
                points.push([ 0, 1, data[(uy * width + x) * 4] / 255 * depth ]);
                points.push([ -1, 1, data[(uy * width + lx) * 4] / 255 * depth ]);
                var normals = [];
                var num_points = points.length;
                for (var i = 0; i < num_points; i++) {
                    var v1 = points[i];
                    var v2 = points[(i + 1) % num_points];
                    v1 = subtract(v1, origin);
                    v2 = subtract(v2, origin);
                    normals.push(normalize(cross(v1, v2)));
                }
                var normal = [ 0, 0, 0 ];
                for (var i = 0; i < normals.length; i++) {
                    normal[0] += normals[i][0];
                    normal[1] += normals[i][1];
                    normal[2] += normals[i][2];
                }
                normal[0] /= normals.length;
                normal[1] /= normals.length;
                normal[2] /= normals.length;
                var idx = (y * width + x) * 4;
                output[idx] = (normal[0] + 1) / 2 * 255 | 0;
                output[idx + 1] = (normal[1] + 1) / 2 * 255 | 0;
                output[idx + 2] = normal[2] * 255 | 0;
                output[idx + 3] = 255;
            }
        }
        context.putImageData(imageData, 0, 0);
        return canvas;
    },
    generateDataTexture: function(width, height, color) {
        var size = width * height;
        var data = new Uint8Array(3 * size);
        var r = Math.floor(color.r * 255);
        var g = Math.floor(color.g * 255);
        var b = Math.floor(color.b * 255);
        for (var i = 0; i < size; i++) {
            data[i * 3] = r;
            data[i * 3 + 1] = g;
            data[i * 3 + 2] = b;
        }
        var texture = new THREE.DataTexture(data, width, height, THREE.RGBFormat);
        texture.needsUpdate = true;
        return texture;
    }
};

THREE.SceneUtils = {
    createMultiMaterialObject: function(geometry, materials) {
        var group = new THREE.Object3D();
        for (var i = 0, l = materials.length; i < l; i++) {
            group.add(new THREE.Mesh(geometry, materials[i]));
        }
        return group;
    },
    detach: function(child, parent, scene) {
        child.applyMatrix(parent.matrixWorld);
        parent.remove(child);
        scene.add(child);
    },
    attach: function(child, scene, parent) {
        var matrixWorldInverse = new THREE.Matrix4();
        matrixWorldInverse.getInverse(parent.matrixWorld);
        child.applyMatrix(matrixWorldInverse);
        scene.remove(child);
        parent.add(child);
    }
};

THREE.FontUtils = {
    faces: {},
    face: "helvetiker",
    weight: "normal",
    style: "normal",
    size: 150,
    divisions: 10,
    getFace: function() {
        try {
            return this.faces[this.face][this.weight][this.style];
        } catch (e) {
            throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing.";
        }
    },
    loadFace: function(data) {
        var family = data.familyName.toLowerCase();
        var ThreeFont = this;
        ThreeFont.faces[family] = ThreeFont.faces[family] || {};
        ThreeFont.faces[family][data.cssFontWeight] = ThreeFont.faces[family][data.cssFontWeight] || {};
        ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;
        ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;
        return data;
    },
    drawText: function(text) {
        var i, face = this.getFace(), scale = this.size / face.resolution, offset = 0, chars = String(text).split(""), length = chars.length;
        var fontPaths = [];
        for (i = 0; i < length; i++) {
            var path = new THREE.Path();
            var ret = this.extractGlyphPoints(chars[i], face, scale, offset, path);
            offset += ret.offset;
            fontPaths.push(ret.path);
        }
        var width = offset / 2;
        return {
            paths: fontPaths,
            offset: width
        };
    },
    extractGlyphPoints: function(c, face, scale, offset, path) {
        var pts = [];
        var i, i2, divisions, outline, action, length, scaleX, scaleY, x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste, glyph = face.glyphs[c] || face.glyphs["?"];
        if (!glyph) return;
        if (glyph.o) {
            outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
            length = outline.length;
            scaleX = scale;
            scaleY = scale;
            for (i = 0; i < length; ) {
                action = outline[i++];
                switch (action) {
                  case "m":
                    x = outline[i++] * scaleX + offset;
                    y = outline[i++] * scaleY;
                    path.moveTo(x, y);
                    break;

                  case "l":
                    x = outline[i++] * scaleX + offset;
                    y = outline[i++] * scaleY;
                    path.lineTo(x, y);
                    break;

                  case "q":
                    cpx = outline[i++] * scaleX + offset;
                    cpy = outline[i++] * scaleY;
                    cpx1 = outline[i++] * scaleX + offset;
                    cpy1 = outline[i++] * scaleY;
                    path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    laste = pts[pts.length - 1];
                    if (laste) {
                        cpx0 = laste.x;
                        cpy0 = laste.y;
                        for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {
                            var t = i2 / divisions;
                            THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);
                            THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);
                        }
                    }
                    break;

                  case "b":
                    cpx = outline[i++] * scaleX + offset;
                    cpy = outline[i++] * scaleY;
                    cpx1 = outline[i++] * scaleX + offset;
                    cpy1 = outline[i++] * scaleY;
                    cpx2 = outline[i++] * scaleX + offset;
                    cpy2 = outline[i++] * scaleY;
                    path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    laste = pts[pts.length - 1];
                    if (laste) {
                        cpx0 = laste.x;
                        cpy0 = laste.y;
                        for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {
                            var t = i2 / divisions;
                            THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);
                            THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);
                        }
                    }
                    break;
                }
            }
        }
        return {
            offset: glyph.ha * scale,
            path: path
        };
    }
};

THREE.FontUtils.generateShapes = function(text, parameters) {
    parameters = parameters || {};
    var size = parameters.size !== undefined ? parameters.size : 100;
    var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;
    var font = parameters.font !== undefined ? parameters.font : "helvetiker";
    var weight = parameters.weight !== undefined ? parameters.weight : "normal";
    var style = parameters.style !== undefined ? parameters.style : "normal";
    THREE.FontUtils.size = size;
    THREE.FontUtils.divisions = curveSegments;
    THREE.FontUtils.face = font;
    THREE.FontUtils.weight = weight;
    THREE.FontUtils.style = style;
    var data = THREE.FontUtils.drawText(text);
    var paths = data.paths;
    var shapes = [];
    for (var p = 0, pl = paths.length; p < pl; p++) {
        Array.prototype.push.apply(shapes, paths[p].toShapes());
    }
    return shapes;
};

(function(namespace) {
    var EPSILON = 1e-10;
    var process = function(contour, indices) {
        var n = contour.length;
        if (n < 3) return null;
        var result = [], verts = [], vertIndices = [];
        var u, v, w;
        if (area(contour) > 0) {
            for (v = 0; v < n; v++) verts[v] = v;
        } else {
            for (v = 0; v < n; v++) verts[v] = n - 1 - v;
        }
        var nv = n;
        var count = 2 * nv;
        for (v = nv - 1; nv > 2; ) {
            if (count-- <= 0) {
                THREE.warn("THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()");
                if (indices) return vertIndices;
                return result;
            }
            u = v;
            if (nv <= u) u = 0;
            v = u + 1;
            if (nv <= v) v = 0;
            w = v + 1;
            if (nv <= w) w = 0;
            if (snip(contour, u, v, w, nv, verts)) {
                var a, b, c, s, t;
                a = verts[u];
                b = verts[v];
                c = verts[w];
                result.push([ contour[a], contour[b], contour[c] ]);
                vertIndices.push([ verts[u], verts[v], verts[w] ]);
                for (s = v, t = v + 1; t < nv; s++, t++) {
                    verts[s] = verts[t];
                }
                nv--;
                count = 2 * nv;
            }
        }
        if (indices) return vertIndices;
        return result;
    };
    var area = function(contour) {
        var n = contour.length;
        var a = 0;
        for (var p = n - 1, q = 0; q < n; p = q++) {
            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * .5;
    };
    var snip = function(contour, u, v, w, n, verts) {
        var p;
        var ax, ay, bx, by;
        var cx, cy, px, py;
        ax = contour[verts[u]].x;
        ay = contour[verts[u]].y;
        bx = contour[verts[v]].x;
        by = contour[verts[v]].y;
        cx = contour[verts[w]].x;
        cy = contour[verts[w]].y;
        if (EPSILON > (bx - ax) * (cy - ay) - (by - ay) * (cx - ax)) return false;
        var aX, aY, bX, bY, cX, cY;
        var apx, apy, bpx, bpy, cpx, cpy;
        var cCROSSap, bCROSScp, aCROSSbp;
        aX = cx - bx;
        aY = cy - by;
        bX = ax - cx;
        bY = ay - cy;
        cX = bx - ax;
        cY = by - ay;
        for (p = 0; p < n; p++) {
            px = contour[verts[p]].x;
            py = contour[verts[p]].y;
            if (px === ax && py === ay || px === bx && py === by || px === cx && py === cy) continue;
            apx = px - ax;
            apy = py - ay;
            bpx = px - bx;
            bpy = py - by;
            cpx = px - cx;
            cpy = py - cy;
            aCROSSbp = aX * bpy - aY * bpx;
            cCROSSap = cX * apy - cY * apx;
            bCROSScp = bX * cpy - bY * cpx;
            if (aCROSSbp >= -EPSILON && bCROSScp >= -EPSILON && cCROSSap >= -EPSILON) return false;
        }
        return true;
    };
    namespace.Triangulate = process;
    namespace.Triangulate.area = area;
    return namespace;
})(THREE.FontUtils);

self._typeface_js = {
    faces: THREE.FontUtils.faces,
    loadFace: THREE.FontUtils.loadFace
};

THREE.typeface_js = self._typeface_js;

THREE.Audio = function(listener) {
    THREE.Object3D.call(this);
    this.type = "Audio";
    this.context = listener.context;
    this.source = this.context.createBufferSource();
    this.source.onended = this.onEnded.bind(this);
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.panner = this.context.createPanner();
    this.panner.connect(this.gain);
    this.autoplay = false;
    this.startTime = 0;
    this.isPlaying = false;
};

THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);

THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function(file) {
    var scope = this;
    var request = new XMLHttpRequest();
    request.open("GET", file, true);
    request.responseType = "arraybuffer";
    request.onload = function(e) {
        scope.context.decodeAudioData(this.response, function(buffer) {
            scope.source.buffer = buffer;
            if (scope.autoplay) scope.play();
        });
    };
    request.send();
    return this;
};

THREE.Audio.prototype.play = function() {
    if (this.isPlaying === true) {
        THREE.warn("THREE.Audio: Audio is already playing.");
        return;
    }
    var source = this.context.createBufferSource();
    source.buffer = this.source.buffer;
    source.loop = this.source.loop;
    source.onended = this.source.onended;
    source.connect(this.panner);
    source.start(0, this.startTime);
    this.isPlaying = true;
    this.source = source;
};

THREE.Audio.prototype.pause = function() {
    this.source.stop();
    this.startTime = this.context.currentTime;
};

THREE.Audio.prototype.stop = function() {
    this.source.stop();
    this.startTime = 0;
};

THREE.Audio.prototype.onEnded = function() {
    this.isPlaying = false;
};

THREE.Audio.prototype.setLoop = function(value) {
    this.source.loop = value;
};

THREE.Audio.prototype.setRefDistance = function(value) {
    this.panner.refDistance = value;
};

THREE.Audio.prototype.setRolloffFactor = function(value) {
    this.panner.rolloffFactor = value;
};

THREE.Audio.prototype.setVolume = function(value) {
    this.gain.gain.value = value;
};

THREE.Audio.prototype.updateMatrixWorld = function() {
    var position = new THREE.Vector3();
    return function(force) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
        position.setFromMatrixPosition(this.matrixWorld);
        this.panner.setPosition(position.x, position.y, position.z);
    };
}();

THREE.AudioListener = function() {
    THREE.Object3D.call(this);
    this.type = "AudioListener";
    this.context = new (window.AudioContext || window.webkitAudioContext)();
};

THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);

THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = function() {
    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3();
    var orientation = new THREE.Vector3();
    var velocity = new THREE.Vector3();
    var positionPrev = new THREE.Vector3();
    return function(force) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
        var listener = this.context.listener;
        var up = this.up;
        this.matrixWorld.decompose(position, quaternion, scale);
        orientation.set(0, 0, -1).applyQuaternion(quaternion);
        velocity.subVectors(position, positionPrev);
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
        listener.setVelocity(velocity.x, velocity.y, velocity.z);
        positionPrev.copy(position);
    };
}();

THREE.Curve = function() {};

THREE.Curve.prototype.getPoint = function(t) {
    THREE.warn("THREE.Curve: Warning, getPoint() not implemented!");
    return null;
};

THREE.Curve.prototype.getPointAt = function(u) {
    var t = this.getUtoTmapping(u);
    return this.getPoint(t);
};

THREE.Curve.prototype.getPoints = function(divisions) {
    if (!divisions) divisions = 5;
    var d, pts = [];
    for (d = 0; d <= divisions; d++) {
        pts.push(this.getPoint(d / divisions));
    }
    return pts;
};

THREE.Curve.prototype.getSpacedPoints = function(divisions) {
    if (!divisions) divisions = 5;
    var d, pts = [];
    for (d = 0; d <= divisions; d++) {
        pts.push(this.getPointAt(d / divisions));
    }
    return pts;
};

THREE.Curve.prototype.getLength = function() {
    var lengths = this.getLengths();
    return lengths[lengths.length - 1];
};

THREE.Curve.prototype.getLengths = function(divisions) {
    if (!divisions) divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200;
    if (this.cacheArcLengths && this.cacheArcLengths.length == divisions + 1 && !this.needsUpdate) {
        return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    var cache = [];
    var current, last = this.getPoint(0);
    var p, sum = 0;
    cache.push(0);
    for (p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
};

THREE.Curve.prototype.updateArcLengths = function() {
    this.needsUpdate = true;
    this.getLengths();
};

THREE.Curve.prototype.getUtoTmapping = function(u, distance) {
    var arcLengths = this.getLengths();
    var i = 0, il = arcLengths.length;
    var targetArcLength;
    if (distance) {
        targetArcLength = distance;
    } else {
        targetArcLength = u * arcLengths[il - 1];
    }
    var low = 0, high = il - 1, comparison;
    while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
            low = i + 1;
        } else if (comparison > 0) {
            high = i - 1;
        } else {
            high = i;
            break;
        }
    }
    i = high;
    if (arcLengths[i] == targetArcLength) {
        var t = i / (il - 1);
        return t;
    }
    var lengthBefore = arcLengths[i];
    var lengthAfter = arcLengths[i + 1];
    var segmentLength = lengthAfter - lengthBefore;
    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    var t = (i + segmentFraction) / (il - 1);
    return t;
};

THREE.Curve.prototype.getTangent = function(t) {
    var delta = 1e-4;
    var t1 = t - delta;
    var t2 = t + delta;
    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    var pt1 = this.getPoint(t1);
    var pt2 = this.getPoint(t2);
    var vec = pt2.clone().sub(pt1);
    return vec.normalize();
};

THREE.Curve.prototype.getTangentAt = function(u) {
    var t = this.getUtoTmapping(u);
    return this.getTangent(t);
};

THREE.Curve.Utils = {
    tangentQuadraticBezier: function(t, p0, p1, p2) {
        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
    },
    tangentCubicBezier: function(t, p0, p1, p2, p3) {
        return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
    },
    tangentSpline: function(t, p0, p1, p2, p3) {
        var h00 = 6 * t * t - 6 * t;
        var h10 = 3 * t * t - 4 * t + 1;
        var h01 = -6 * t * t + 6 * t;
        var h11 = 3 * t * t - 2 * t;
        return h00 + h10 + h01 + h11;
    },
    interpolate: function(p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * .5;
        var v1 = (p3 - p1) * .5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
};

THREE.Curve.create = function(constructor, getPointFunc) {
    constructor.prototype = Object.create(THREE.Curve.prototype);
    constructor.prototype.constructor = constructor;
    constructor.prototype.getPoint = getPointFunc;
    return constructor;
};

THREE.CurvePath = function() {
    this.curves = [];
    this.bends = [];
    this.autoClose = false;
};

THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);

THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function(curve) {
    this.curves.push(curve);
};

THREE.CurvePath.prototype.checkConnection = function() {};

THREE.CurvePath.prototype.closePath = function() {
    var startPoint = this.curves[0].getPoint(0);
    var endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
        this.curves.push(new THREE.LineCurve(endPoint, startPoint));
    }
};

THREE.CurvePath.prototype.getPoint = function(t) {
    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0, diff, curve;
    while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
            diff = curveLengths[i] - d;
            curve = this.curves[i];
            var u = 1 - diff / curve.getLength();
            return curve.getPointAt(u);
        }
        i++;
    }
    return null;
};

THREE.CurvePath.prototype.getLength = function() {
    var lens = this.getCurveLengths();
    return lens[lens.length - 1];
};

THREE.CurvePath.prototype.getCurveLengths = function() {
    if (this.cacheLengths && this.cacheLengths.length == this.curves.length) {
        return this.cacheLengths;
    }
    var lengths = [], sums = 0;
    var i, il = this.curves.length;
    for (i = 0; i < il; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
};

THREE.CurvePath.prototype.getBoundingBox = function() {
    var points = this.getPoints();
    var maxX, maxY, maxZ;
    var minX, minY, minZ;
    maxX = maxY = Number.NEGATIVE_INFINITY;
    minX = minY = Number.POSITIVE_INFINITY;
    var p, i, il, sum;
    var v3 = points[0] instanceof THREE.Vector3;
    sum = v3 ? new THREE.Vector3() : new THREE.Vector2();
    for (i = 0, il = points.length; i < il; i++) {
        p = points[i];
        if (p.x > maxX) maxX = p.x; else if (p.x < minX) minX = p.x;
        if (p.y > maxY) maxY = p.y; else if (p.y < minY) minY = p.y;
        if (v3) {
            if (p.z > maxZ) maxZ = p.z; else if (p.z < minZ) minZ = p.z;
        }
        sum.add(p);
    }
    var ret = {
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY
    };
    if (v3) {
        ret.maxZ = maxZ;
        ret.minZ = minZ;
    }
    return ret;
};

THREE.CurvePath.prototype.createPointsGeometry = function(divisions) {
    var pts = this.getPoints(divisions, true);
    return this.createGeometry(pts);
};

THREE.CurvePath.prototype.createSpacedPointsGeometry = function(divisions) {
    var pts = this.getSpacedPoints(divisions, true);
    return this.createGeometry(pts);
};

THREE.CurvePath.prototype.createGeometry = function(points) {
    var geometry = new THREE.Geometry();
    for (var i = 0; i < points.length; i++) {
        geometry.vertices.push(new THREE.Vector3(points[i].x, points[i].y, points[i].z || 0));
    }
    return geometry;
};

THREE.CurvePath.prototype.addWrapPath = function(bendpath) {
    this.bends.push(bendpath);
};

THREE.CurvePath.prototype.getTransformedPoints = function(segments, bends) {
    var oldPts = this.getPoints(segments);
    var i, il;
    if (!bends) {
        bends = this.bends;
    }
    for (i = 0, il = bends.length; i < il; i++) {
        oldPts = this.getWrapPoints(oldPts, bends[i]);
    }
    return oldPts;
};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function(segments, bends) {
    var oldPts = this.getSpacedPoints(segments);
    var i, il;
    if (!bends) {
        bends = this.bends;
    }
    for (i = 0, il = bends.length; i < il; i++) {
        oldPts = this.getWrapPoints(oldPts, bends[i]);
    }
    return oldPts;
};

THREE.CurvePath.prototype.getWrapPoints = function(oldPts, path) {
    var bounds = this.getBoundingBox();
    var i, il, p, oldX, oldY, xNorm;
    for (i = 0, il = oldPts.length; i < il; i++) {
        p = oldPts[i];
        oldX = p.x;
        oldY = p.y;
        xNorm = oldX / bounds.maxX;
        xNorm = path.getUtoTmapping(xNorm, oldX);
        var pathPt = path.getPoint(xNorm);
        var normal = path.getTangent(xNorm);
        normal.set(-normal.y, normal.x).multiplyScalar(oldY);
        p.x = pathPt.x + normal.x;
        p.y = pathPt.y + normal.y;
    }
    return oldPts;
};

THREE.Gyroscope = function() {
    THREE.Object3D.call(this);
};

THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);

THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;

THREE.Gyroscope.prototype.updateMatrixWorld = function() {
    var translationObject = new THREE.Vector3();
    var quaternionObject = new THREE.Quaternion();
    var scaleObject = new THREE.Vector3();
    var translationWorld = new THREE.Vector3();
    var quaternionWorld = new THREE.Quaternion();
    var scaleWorld = new THREE.Vector3();
    return function(force) {
        this.matrixAutoUpdate && this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent) {
                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                this.matrixWorld.decompose(translationWorld, quaternionWorld, scaleWorld);
                this.matrix.decompose(translationObject, quaternionObject, scaleObject);
                this.matrixWorld.compose(translationWorld, quaternionObject, scaleWorld);
            } else {
                this.matrixWorld.copy(this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        for (var i = 0, l = this.children.length; i < l; i++) {
            this.children[i].updateMatrixWorld(force);
        }
    };
}();

THREE.Path = function(points) {
    THREE.CurvePath.call(this);
    this.actions = [];
    if (points) {
        this.fromPoints(points);
    }
};

THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);

THREE.Path.prototype.constructor = THREE.Path;

THREE.PathActions = {
    MOVE_TO: "moveTo",
    LINE_TO: "lineTo",
    QUADRATIC_CURVE_TO: "quadraticCurveTo",
    BEZIER_CURVE_TO: "bezierCurveTo",
    CSPLINE_THRU: "splineThru",
    ARC: "arc",
    ELLIPSE: "ellipse"
};

THREE.Path.prototype.fromPoints = function(vectors) {
    this.moveTo(vectors[0].x, vectors[0].y);
    for (var v = 1, vlen = vectors.length; v < vlen; v++) {
        this.lineTo(vectors[v].x, vectors[v].y);
    }
};

THREE.Path.prototype.moveTo = function(x, y) {
    var args = Array.prototype.slice.call(arguments);
    this.actions.push({
        action: THREE.PathActions.MOVE_TO,
        args: args
    });
};

THREE.Path.prototype.lineTo = function(x, y) {
    var args = Array.prototype.slice.call(arguments);
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));
    this.curves.push(curve);
    this.actions.push({
        action: THREE.PathActions.LINE_TO,
        args: args
    });
};

THREE.Path.prototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
    var args = Array.prototype.slice.call(arguments);
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    var curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));
    this.curves.push(curve);
    this.actions.push({
        action: THREE.PathActions.QUADRATIC_CURVE_TO,
        args: args
    });
};

THREE.Path.prototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    var args = Array.prototype.slice.call(arguments);
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));
    this.curves.push(curve);
    this.actions.push({
        action: THREE.PathActions.BEZIER_CURVE_TO,
        args: args
    });
};

THREE.Path.prototype.splineThru = function(pts) {
    var args = Array.prototype.slice.call(arguments);
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    var npts = [ new THREE.Vector2(x0, y0) ];
    Array.prototype.push.apply(npts, pts);
    var curve = new THREE.SplineCurve(npts);
    this.curves.push(curve);
    this.actions.push({
        action: THREE.PathActions.CSPLINE_THRU,
        args: args
    });
};

THREE.Path.prototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
};

THREE.Path.prototype.absarc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
};

THREE.Path.prototype.ellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);
};

THREE.Path.prototype.absellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
    var args = Array.prototype.slice.call(arguments);
    var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);
    this.curves.push(curve);
    var lastPoint = curve.getPoint(1);
    args.push(lastPoint.x);
    args.push(lastPoint.y);
    this.actions.push({
        action: THREE.PathActions.ELLIPSE,
        args: args
    });
};

THREE.Path.prototype.getSpacedPoints = function(divisions, closedPath) {
    if (!divisions) divisions = 40;
    var points = [];
    for (var i = 0; i < divisions; i++) {
        points.push(this.getPoint(i / divisions));
    }
    return points;
};

THREE.Path.prototype.getPoints = function(divisions, closedPath) {
    if (this.useSpacedPoints) {
        console.log("tata");
        return this.getSpacedPoints(divisions, closedPath);
    }
    divisions = divisions || 12;
    var points = [];
    var i, il, item, action, args;
    var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0, laste, j, t, tx, ty;
    for (i = 0, il = this.actions.length; i < il; i++) {
        item = this.actions[i];
        action = item.action;
        args = item.args;
        switch (action) {
          case THREE.PathActions.MOVE_TO:
            points.push(new THREE.Vector2(args[0], args[1]));
            break;

          case THREE.PathActions.LINE_TO:
            points.push(new THREE.Vector2(args[0], args[1]));
            break;

          case THREE.PathActions.QUADRATIC_CURVE_TO:
            cpx = args[2];
            cpy = args[3];
            cpx1 = args[0];
            cpy1 = args[1];
            if (points.length > 0) {
                laste = points[points.length - 1];
                cpx0 = laste.x;
                cpy0 = laste.y;
            } else {
                laste = this.actions[i - 1].args;
                cpx0 = laste[laste.length - 2];
                cpy0 = laste[laste.length - 1];
            }
            for (j = 1; j <= divisions; j++) {
                t = j / divisions;
                tx = THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);
                ty = THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);
                points.push(new THREE.Vector2(tx, ty));
            }
            break;

          case THREE.PathActions.BEZIER_CURVE_TO:
            cpx = args[4];
            cpy = args[5];
            cpx1 = args[0];
            cpy1 = args[1];
            cpx2 = args[2];
            cpy2 = args[3];
            if (points.length > 0) {
                laste = points[points.length - 1];
                cpx0 = laste.x;
                cpy0 = laste.y;
            } else {
                laste = this.actions[i - 1].args;
                cpx0 = laste[laste.length - 2];
                cpy0 = laste[laste.length - 1];
            }
            for (j = 1; j <= divisions; j++) {
                t = j / divisions;
                tx = THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);
                ty = THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);
                points.push(new THREE.Vector2(tx, ty));
            }
            break;

          case THREE.PathActions.CSPLINE_THRU:
            laste = this.actions[i - 1].args;
            var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);
            var spts = [ last ];
            var n = divisions * args[0].length;
            spts = spts.concat(args[0]);
            var spline = new THREE.SplineCurve(spts);
            for (j = 1; j <= n; j++) {
                points.push(spline.getPointAt(j / n));
            }
            break;

          case THREE.PathActions.ARC:
            var aX = args[0], aY = args[1], aRadius = args[2], aStartAngle = args[3], aEndAngle = args[4], aClockwise = !!args[5];
            var deltaAngle = aEndAngle - aStartAngle;
            var angle;
            var tdivisions = divisions * 2;
            for (j = 1; j <= tdivisions; j++) {
                t = j / tdivisions;
                if (!aClockwise) {
                    t = 1 - t;
                }
                angle = aStartAngle + t * deltaAngle;
                tx = aX + aRadius * Math.cos(angle);
                ty = aY + aRadius * Math.sin(angle);
                points.push(new THREE.Vector2(tx, ty));
            }
            break;

          case THREE.PathActions.ELLIPSE:
            var aX = args[0], aY = args[1], xRadius = args[2], yRadius = args[3], aStartAngle = args[4], aEndAngle = args[5], aClockwise = !!args[6];
            var deltaAngle = aEndAngle - aStartAngle;
            var angle;
            var tdivisions = divisions * 2;
            for (j = 1; j <= tdivisions; j++) {
                t = j / tdivisions;
                if (!aClockwise) {
                    t = 1 - t;
                }
                angle = aStartAngle + t * deltaAngle;
                tx = aX + xRadius * Math.cos(angle);
                ty = aY + yRadius * Math.sin(angle);
                points.push(new THREE.Vector2(tx, ty));
            }
            break;
        }
    }
    var lastPoint = points[points.length - 1];
    var EPSILON = 1e-10;
    if (Math.abs(lastPoint.x - points[0].x) < EPSILON && Math.abs(lastPoint.y - points[0].y) < EPSILON) points.splice(points.length - 1, 1);
    if (closedPath) {
        points.push(points[0]);
    }
    return points;
};

THREE.Path.prototype.toShapes = function(isCCW, noHoles) {
    function extractSubpaths(inActions) {
        var i, il, item, action, args;
        var subPaths = [], lastPath = new THREE.Path();
        for (i = 0, il = inActions.length; i < il; i++) {
            item = inActions[i];
            args = item.args;
            action = item.action;
            if (action == THREE.PathActions.MOVE_TO) {
                if (lastPath.actions.length != 0) {
                    subPaths.push(lastPath);
                    lastPath = new THREE.Path();
                }
            }
            lastPath[action].apply(lastPath, args);
        }
        if (lastPath.actions.length != 0) {
            subPaths.push(lastPath);
        }
        return subPaths;
    }
    function toShapesNoHoles(inSubpaths) {
        var shapes = [];
        for (var i = 0, il = inSubpaths.length; i < il; i++) {
            var tmpPath = inSubpaths[i];
            var tmpShape = new THREE.Shape();
            tmpShape.actions = tmpPath.actions;
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
        }
        return shapes;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
        var EPSILON = 1e-10;
        var polyLen = inPolygon.length;
        var inside = false;
        for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
            var edgeLowPt = inPolygon[p];
            var edgeHighPt = inPolygon[q];
            var edgeDx = edgeHighPt.x - edgeLowPt.x;
            var edgeDy = edgeHighPt.y - edgeLowPt.y;
            if (Math.abs(edgeDy) > EPSILON) {
                if (edgeDy < 0) {
                    edgeLowPt = inPolygon[q];
                    edgeDx = -edgeDx;
                    edgeHighPt = inPolygon[p];
                    edgeDy = -edgeDy;
                }
                if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                if (inPt.y == edgeLowPt.y) {
                    if (inPt.x == edgeLowPt.x) return true;
                } else {
                    var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                    if (perpEdge == 0) return true;
                    if (perpEdge < 0) continue;
                    inside = !inside;
                }
            } else {
                if (inPt.y != edgeLowPt.y) continue;
                if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
            }
        }
        return inside;
    }
    var subPaths = extractSubpaths(this.actions);
    if (subPaths.length == 0) return [];
    if (noHoles === true) return toShapesNoHoles(subPaths);
    var solid, tmpPath, tmpShape, shapes = [];
    if (subPaths.length == 1) {
        tmpPath = subPaths[0];
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
    }
    var holesFirst = !THREE.Shape.Utils.isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;
    newShapes[mainIdx] = undefined;
    newShapeHoles[mainIdx] = [];
    var i, il;
    for (i = 0, il = subPaths.length; i < il; i++) {
        tmpPath = subPaths[i];
        tmpPoints = tmpPath.getPoints();
        solid = THREE.Shape.Utils.isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;
        if (solid) {
            if (!holesFirst && newShapes[mainIdx]) mainIdx++;
            newShapes[mainIdx] = {
                s: new THREE.Shape(),
                p: tmpPoints
            };
            newShapes[mainIdx].s.actions = tmpPath.actions;
            newShapes[mainIdx].s.curves = tmpPath.curves;
            if (holesFirst) mainIdx++;
            newShapeHoles[mainIdx] = [];
        } else {
            newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
            });
        }
    }
    if (!newShapes[0]) return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
        var ambigious = false;
        var toChange = [];
        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            betterShapeHoles[sIdx] = [];
        }
        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            var sho = newShapeHoles[sIdx];
            for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                var ho = sho[hIdx];
                var hole_unassigned = true;
                for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                    if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx != s2Idx) toChange.push({
                            froms: sIdx,
                            tos: s2Idx,
                            hole: hIdx
                        });
                        if (hole_unassigned) {
                            hole_unassigned = false;
                            betterShapeHoles[s2Idx].push(ho);
                        } else {
                            ambigious = true;
                        }
                    }
                }
                if (hole_unassigned) {
                    betterShapeHoles[sIdx].push(ho);
                }
            }
        }
        if (toChange.length > 0) {
            if (!ambigious) newShapeHoles = betterShapeHoles;
        }
    }
    var tmpHoles, j, jl;
    for (i = 0, il = newShapes.length; i < il; i++) {
        tmpShape = newShapes[i].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[i];
        for (j = 0, jl = tmpHoles.length; j < jl; j++) {
            tmpShape.holes.push(tmpHoles[j].h);
        }
    }
    return shapes;
};

THREE.Shape = function() {
    THREE.Path.apply(this, arguments);
    this.holes = [];
};

THREE.Shape.prototype = Object.create(THREE.Path.prototype);

THREE.Shape.prototype.constructor = THREE.Shape;

THREE.Shape.prototype.extrude = function(options) {
    var extruded = new THREE.ExtrudeGeometry(this, options);
    return extruded;
};

THREE.Shape.prototype.makeGeometry = function(options) {
    var geometry = new THREE.ShapeGeometry(this, options);
    return geometry;
};

THREE.Shape.prototype.getPointsHoles = function(divisions) {
    var i, il = this.holes.length, holesPts = [];
    for (i = 0; i < il; i++) {
        holesPts[i] = this.holes[i].getTransformedPoints(divisions, this.bends);
    }
    return holesPts;
};

THREE.Shape.prototype.getSpacedPointsHoles = function(divisions) {
    var i, il = this.holes.length, holesPts = [];
    for (i = 0; i < il; i++) {
        holesPts[i] = this.holes[i].getTransformedSpacedPoints(divisions, this.bends);
    }
    return holesPts;
};

THREE.Shape.prototype.extractAllPoints = function(divisions) {
    return {
        shape: this.getTransformedPoints(divisions),
        holes: this.getPointsHoles(divisions)
    };
};

THREE.Shape.prototype.extractPoints = function(divisions) {
    if (this.useSpacedPoints) {
        return this.extractAllSpacedPoints(divisions);
    }
    return this.extractAllPoints(divisions);
};

THREE.Shape.prototype.extractAllSpacedPoints = function(divisions) {
    return {
        shape: this.getTransformedSpacedPoints(divisions),
        holes: this.getSpacedPointsHoles(divisions)
    };
};

THREE.Shape.Utils = {
    triangulateShape: function(contour, holes) {
        function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
            if (inSegPt1.x != inSegPt2.x) {
                if (inSegPt1.x < inSegPt2.x) {
                    return inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x;
                } else {
                    return inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x;
                }
            } else {
                if (inSegPt1.y < inSegPt2.y) {
                    return inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y;
                } else {
                    return inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;
                }
            }
        }
        function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
            var EPSILON = 1e-10;
            var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
            var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
            var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
            var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
            var limit = seg1dy * seg2dx - seg1dx * seg2dy;
            var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
            if (Math.abs(limit) > EPSILON) {
                var perpSeg2;
                if (limit > 0) {
                    if (perpSeg1 < 0 || perpSeg1 > limit) return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if (perpSeg2 < 0 || perpSeg2 > limit) return [];
                } else {
                    if (perpSeg1 > 0 || perpSeg1 < limit) return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if (perpSeg2 > 0 || perpSeg2 < limit) return [];
                }
                if (perpSeg2 == 0) {
                    if (inExcludeAdjacentSegs && (perpSeg1 == 0 || perpSeg1 == limit)) return [];
                    return [ inSeg1Pt1 ];
                }
                if (perpSeg2 == limit) {
                    if (inExcludeAdjacentSegs && (perpSeg1 == 0 || perpSeg1 == limit)) return [];
                    return [ inSeg1Pt2 ];
                }
                if (perpSeg1 == 0) return [ inSeg2Pt1 ];
                if (perpSeg1 == limit) return [ inSeg2Pt2 ];
                var factorSeg1 = perpSeg2 / limit;
                return [ {
                    x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                    y: inSeg1Pt1.y + factorSeg1 * seg1dy
                } ];
            } else {
                if (perpSeg1 != 0 || seg2dy * seg1seg2dx != seg2dx * seg1seg2dy) return [];
                var seg1Pt = seg1dx == 0 && seg1dy == 0;
                var seg2Pt = seg2dx == 0 && seg2dy == 0;
                if (seg1Pt && seg2Pt) {
                    if (inSeg1Pt1.x != inSeg2Pt1.x || inSeg1Pt1.y != inSeg2Pt1.y) return [];
                    return [ inSeg1Pt1 ];
                }
                if (seg1Pt) {
                    if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1)) return [];
                    return [ inSeg1Pt1 ];
                }
                if (seg2Pt) {
                    if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1)) return [];
                    return [ inSeg2Pt1 ];
                }
                var seg1min, seg1max, seg1minVal, seg1maxVal;
                var seg2min, seg2max, seg2minVal, seg2maxVal;
                if (seg1dx != 0) {
                    if (inSeg1Pt1.x < inSeg1Pt2.x) {
                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.x;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.x;
                    } else {
                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.x;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.x;
                    }
                    if (inSeg2Pt1.x < inSeg2Pt2.x) {
                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.x;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.x;
                    } else {
                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.x;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.x;
                    }
                } else {
                    if (inSeg1Pt1.y < inSeg1Pt2.y) {
                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.y;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.y;
                    } else {
                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.y;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.y;
                    }
                    if (inSeg2Pt1.y < inSeg2Pt2.y) {
                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.y;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.y;
                    } else {
                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.y;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.y;
                    }
                }
                if (seg1minVal <= seg2minVal) {
                    if (seg1maxVal < seg2minVal) return [];
                    if (seg1maxVal == seg2minVal) {
                        if (inExcludeAdjacentSegs) return [];
                        return [ seg2min ];
                    }
                    if (seg1maxVal <= seg2maxVal) return [ seg2min, seg1max ];
                    return [ seg2min, seg2max ];
                } else {
                    if (seg1minVal > seg2maxVal) return [];
                    if (seg1minVal == seg2maxVal) {
                        if (inExcludeAdjacentSegs) return [];
                        return [ seg1min ];
                    }
                    if (seg1maxVal <= seg2maxVal) return [ seg1min, seg1max ];
                    return [ seg1min, seg2max ];
                }
            }
        }
        function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
            var EPSILON = 1e-10;
            var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
            var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
            var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;
            var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
            var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
            if (Math.abs(from2toAngle) > EPSILON) {
                var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                if (from2toAngle > 0) {
                    return from2otherAngle >= 0 && other2toAngle >= 0;
                } else {
                    return from2otherAngle >= 0 || other2toAngle >= 0;
                }
            } else {
                return from2otherAngle > 0;
            }
        }
        function removeHoles(contour, holes) {
            var shape = contour.concat();
            var hole;
            function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
                var lastShapeIdx = shape.length - 1;
                var prevShapeIdx = inShapeIdx - 1;
                if (prevShapeIdx < 0) prevShapeIdx = lastShapeIdx;
                var nextShapeIdx = inShapeIdx + 1;
                if (nextShapeIdx > lastShapeIdx) nextShapeIdx = 0;
                var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                if (!insideAngle) {
                    return false;
                }
                var lastHoleIdx = hole.length - 1;
                var prevHoleIdx = inHoleIdx - 1;
                if (prevHoleIdx < 0) prevHoleIdx = lastHoleIdx;
                var nextHoleIdx = inHoleIdx + 1;
                if (nextHoleIdx > lastHoleIdx) nextHoleIdx = 0;
                insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
                if (!insideAngle) {
                    return false;
                }
                return true;
            }
            function intersectsShapeEdge(inShapePt, inHolePt) {
                var sIdx, nextIdx, intersection;
                for (sIdx = 0; sIdx < shape.length; sIdx++) {
                    nextIdx = sIdx + 1;
                    nextIdx %= shape.length;
                    intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
                    if (intersection.length > 0) return true;
                }
                return false;
            }
            var indepHoles = [];
            function intersectsHoleEdge(inShapePt, inHolePt) {
                var ihIdx, chkHole, hIdx, nextIdx, intersection;
                for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
                    chkHole = holes[indepHoles[ihIdx]];
                    for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                        nextIdx = hIdx + 1;
                        nextIdx %= chkHole.length;
                        intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                        if (intersection.length > 0) return true;
                    }
                }
                return false;
            }
            var holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, failedCuts = [], tmpShape1, tmpShape2, tmpHole1, tmpHole2;
            for (var h = 0, hl = holes.length; h < hl; h++) {
                indepHoles.push(h);
            }
            var minShapeIndex = 0;
            var counter = indepHoles.length * 2;
            while (indepHoles.length > 0) {
                counter--;
                if (counter < 0) {
                    console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
                    break;
                }
                for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
                    shapePt = shape[shapeIndex];
                    holeIndex = -1;
                    for (var h = 0; h < indepHoles.length; h++) {
                        holeIdx = indepHoles[h];
                        cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                        if (failedCuts[cutKey] !== undefined) continue;
                        hole = holes[holeIdx];
                        for (var h2 = 0; h2 < hole.length; h2++) {
                            holePt = hole[h2];
                            if (!isCutLineInsideAngles(shapeIndex, h2)) continue;
                            if (intersectsShapeEdge(shapePt, holePt)) continue;
                            if (intersectsHoleEdge(shapePt, holePt)) continue;
                            holeIndex = h2;
                            indepHoles.splice(h, 1);
                            tmpShape1 = shape.slice(0, shapeIndex + 1);
                            tmpShape2 = shape.slice(shapeIndex);
                            tmpHole1 = hole.slice(holeIndex);
                            tmpHole2 = hole.slice(0, holeIndex + 1);
                            shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                            minShapeIndex = shapeIndex;
                            break;
                        }
                        if (holeIndex >= 0) break;
                        failedCuts[cutKey] = true;
                    }
                    if (holeIndex >= 0) break;
                }
            }
            return shape;
        }
        var i, il, f, face, key, index, allPointsMap = {};
        var allpoints = contour.concat();
        for (var h = 0, hl = holes.length; h < hl; h++) {
            Array.prototype.push.apply(allpoints, holes[h]);
        }
        for (i = 0, il = allpoints.length; i < il; i++) {
            key = allpoints[i].x + ":" + allpoints[i].y;
            if (allPointsMap[key] !== undefined) {
                THREE.warn("THREE.Shape: Duplicate point", key);
            }
            allPointsMap[key] = i;
        }
        var shapeWithoutHoles = removeHoles(contour, holes);
        var triangles = THREE.FontUtils.Triangulate(shapeWithoutHoles, false);
        for (i = 0, il = triangles.length; i < il; i++) {
            face = triangles[i];
            for (f = 0; f < 3; f++) {
                key = face[f].x + ":" + face[f].y;
                index = allPointsMap[key];
                if (index !== undefined) {
                    face[f] = index;
                }
            }
        }
        return triangles.concat();
    },
    isClockWise: function(pts) {
        return THREE.FontUtils.Triangulate.area(pts) < 0;
    },
    b2p0: function(t, p) {
        var k = 1 - t;
        return k * k * p;
    },
    b2p1: function(t, p) {
        return 2 * (1 - t) * t * p;
    },
    b2p2: function(t, p) {
        return t * t * p;
    },
    b2: function(t, p0, p1, p2) {
        return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);
    },
    b3p0: function(t, p) {
        var k = 1 - t;
        return k * k * k * p;
    },
    b3p1: function(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    },
    b3p2: function(t, p) {
        var k = 1 - t;
        return 3 * k * t * t * p;
    },
    b3p3: function(t, p) {
        return t * t * t * p;
    },
    b3: function(t, p0, p1, p2, p3) {
        return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);
    }
};

THREE.LineCurve = function(v1, v2) {
    this.v1 = v1;
    this.v2 = v2;
};

THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);

THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function(t) {
    var point = this.v2.clone().sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
    return point;
};

THREE.LineCurve.prototype.getPointAt = function(u) {
    return this.getPoint(u);
};

THREE.LineCurve.prototype.getTangent = function(t) {
    var tangent = this.v2.clone().sub(this.v1);
    return tangent.normalize();
};

THREE.QuadraticBezierCurve = function(v0, v1, v2) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
};

THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);

THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;

THREE.QuadraticBezierCurve.prototype.getPoint = function(t) {
    var vector = new THREE.Vector2();
    vector.x = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);
    vector.y = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);
    return vector;
};

THREE.QuadraticBezierCurve.prototype.getTangent = function(t) {
    var vector = new THREE.Vector2();
    vector.x = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x);
    vector.y = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y);
    return vector.normalize();
};

THREE.CubicBezierCurve = function(v0, v1, v2, v3) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
};

THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);

THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function(t) {
    var tx, ty;
    tx = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
    ty = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
    return new THREE.Vector2(tx, ty);
};

THREE.CubicBezierCurve.prototype.getTangent = function(t) {
    var tx, ty;
    tx = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
    ty = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
    var tangent = new THREE.Vector2(tx, ty);
    tangent.normalize();
    return tangent;
};

THREE.SplineCurve = function(points) {
    this.points = points == undefined ? [] : points;
};

THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);

THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function(t) {
    var points = this.points;
    var point = (points.length - 1) * t;
    var intPoint = Math.floor(point);
    var weight = point - intPoint;
    var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
    var point1 = points[intPoint];
    var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    var vector = new THREE.Vector2();
    vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);
    vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);
    return vector;
};

THREE.EllipseCurve = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
};

THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);

THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function(t) {
    var deltaAngle = this.aEndAngle - this.aStartAngle;
    if (deltaAngle < 0) deltaAngle += Math.PI * 2;
    if (deltaAngle > Math.PI * 2) deltaAngle -= Math.PI * 2;
    var angle;
    if (this.aClockwise === true) {
        angle = this.aEndAngle + (1 - t) * (Math.PI * 2 - deltaAngle);
    } else {
        angle = this.aStartAngle + t * deltaAngle;
    }
    var vector = new THREE.Vector2();
    vector.x = this.aX + this.xRadius * Math.cos(angle);
    vector.y = this.aY + this.yRadius * Math.sin(angle);
    return vector;
};

THREE.ArcCurve = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
};

THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);

THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

THREE.LineCurve3 = THREE.Curve.create(function(v1, v2) {
    this.v1 = v1;
    this.v2 = v2;
}, function(t) {
    var vector = new THREE.Vector3();
    vector.subVectors(this.v2, this.v1);
    vector.multiplyScalar(t);
    vector.add(this.v1);
    return vector;
});

THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(v0, v1, v2) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
}, function(t) {
    var vector = new THREE.Vector3();
    vector.x = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);
    vector.y = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);
    vector.z = THREE.Shape.Utils.b2(t, this.v0.z, this.v1.z, this.v2.z);
    return vector;
});

THREE.CubicBezierCurve3 = THREE.Curve.create(function(v0, v1, v2, v3) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
}, function(t) {
    var vector = new THREE.Vector3();
    vector.x = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
    vector.y = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
    vector.z = THREE.Shape.Utils.b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
    return vector;
});

THREE.SplineCurve3 = THREE.Curve.create(function(points) {
    this.points = points == undefined ? [] : points;
}, function(t) {
    var points = this.points;
    var point = (points.length - 1) * t;
    var intPoint = Math.floor(point);
    var weight = point - intPoint;
    var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
    var point1 = points[intPoint];
    var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    var vector = new THREE.Vector3();
    vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);
    vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);
    vector.z = THREE.Curve.Utils.interpolate(point0.z, point1.z, point2.z, point3.z, weight);
    return vector;
});

THREE.ClosedSplineCurve3 = THREE.Curve.create(function(points) {
    this.points = points == undefined ? [] : points;
}, function(t) {
    var points = this.points;
    var point = (points.length - 0) * t;
    var intPoint = Math.floor(point);
    var weight = point - intPoint;
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
    var point0 = points[(intPoint - 1) % points.length];
    var point1 = points[intPoint % points.length];
    var point2 = points[(intPoint + 1) % points.length];
    var point3 = points[(intPoint + 2) % points.length];
    var vector = new THREE.Vector3();
    vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);
    vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);
    vector.z = THREE.Curve.Utils.interpolate(point0.z, point1.z, point2.z, point3.z, weight);
    return vector;
});

THREE.AnimationHandler = {
    LINEAR: 0,
    CATMULLROM: 1,
    CATMULLROM_FORWARD: 2,
    add: function() {
        THREE.warn("THREE.AnimationHandler.add() has been deprecated.");
    },
    get: function() {
        THREE.warn("THREE.AnimationHandler.get() has been deprecated.");
    },
    remove: function() {
        THREE.warn("THREE.AnimationHandler.remove() has been deprecated.");
    },
    animations: [],
    init: function(data) {
        if (data.initialized === true) return data;
        for (var h = 0; h < data.hierarchy.length; h++) {
            for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
                if (data.hierarchy[h].keys[k].time < 0) {
                    data.hierarchy[h].keys[k].time = 0;
                }
                if (data.hierarchy[h].keys[k].rot !== undefined && !(data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {
                    var quat = data.hierarchy[h].keys[k].rot;
                    data.hierarchy[h].keys[k].rot = new THREE.Quaternion().fromArray(quat);
                }
            }
            if (data.hierarchy[h].keys.length && data.hierarchy[h].keys[0].morphTargets !== undefined) {
                var usedMorphTargets = {};
                for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
                    for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
                        var morphTargetName = data.hierarchy[h].keys[k].morphTargets[m];
                        usedMorphTargets[morphTargetName] = -1;
                    }
                }
                data.hierarchy[h].usedMorphTargets = usedMorphTargets;
                for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
                    var influences = {};
                    for (var morphTargetName in usedMorphTargets) {
                        for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
                            if (data.hierarchy[h].keys[k].morphTargets[m] === morphTargetName) {
                                influences[morphTargetName] = data.hierarchy[h].keys[k].morphTargetsInfluences[m];
                                break;
                            }
                        }
                        if (m === data.hierarchy[h].keys[k].morphTargets.length) {
                            influences[morphTargetName] = 0;
                        }
                    }
                    data.hierarchy[h].keys[k].morphTargetsInfluences = influences;
                }
            }
            for (var k = 1; k < data.hierarchy[h].keys.length; k++) {
                if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {
                    data.hierarchy[h].keys.splice(k, 1);
                    k--;
                }
            }
            for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
                data.hierarchy[h].keys[k].index = k;
            }
        }
        data.initialized = true;
        return data;
    },
    parse: function(root) {
        var parseRecurseHierarchy = function(root, hierarchy) {
            hierarchy.push(root);
            for (var c = 0; c < root.children.length; c++) parseRecurseHierarchy(root.children[c], hierarchy);
        };
        var hierarchy = [];
        if (root instanceof THREE.SkinnedMesh) {
            for (var b = 0; b < root.skeleton.bones.length; b++) {
                hierarchy.push(root.skeleton.bones[b]);
            }
        } else {
            parseRecurseHierarchy(root, hierarchy);
        }
        return hierarchy;
    },
    play: function(animation) {
        if (this.animations.indexOf(animation) === -1) {
            this.animations.push(animation);
        }
    },
    stop: function(animation) {
        var index = this.animations.indexOf(animation);
        if (index !== -1) {
            this.animations.splice(index, 1);
        }
    },
    update: function(deltaTimeMS) {
        for (var i = 0; i < this.animations.length; i++) {
            this.animations[i].resetBlendWeights();
        }
        for (var i = 0; i < this.animations.length; i++) {
            this.animations[i].update(deltaTimeMS);
        }
    }
};

THREE.Animation = function(root, data) {
    this.root = root;
    this.data = THREE.AnimationHandler.init(data);
    this.hierarchy = THREE.AnimationHandler.parse(root);
    this.currentTime = 0;
    this.timeScale = 1;
    this.isPlaying = false;
    this.loop = true;
    this.weight = 0;
    this.interpolationType = THREE.AnimationHandler.LINEAR;
};

THREE.Animation.prototype = {
    constructor: THREE.Animation,
    keyTypes: [ "pos", "rot", "scl" ],
    play: function(startTime, weight) {
        this.currentTime = startTime !== undefined ? startTime : 0;
        this.weight = weight !== undefined ? weight : 1;
        this.isPlaying = true;
        this.reset();
        THREE.AnimationHandler.play(this);
    },
    stop: function() {
        this.isPlaying = false;
        THREE.AnimationHandler.stop(this);
    },
    reset: function() {
        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            if (object.animationCache === undefined) {
                object.animationCache = {
                    animations: {},
                    blending: {
                        positionWeight: 0,
                        quaternionWeight: 0,
                        scaleWeight: 0
                    }
                };
            }
            var name = this.data.name;
            var animations = object.animationCache.animations;
            var animationCache = animations[name];
            if (animationCache === undefined) {
                animationCache = {
                    prevKey: {
                        pos: 0,
                        rot: 0,
                        scl: 0
                    },
                    nextKey: {
                        pos: 0,
                        rot: 0,
                        scl: 0
                    },
                    originalMatrix: object.matrix
                };
                animations[name] = animationCache;
            }
            for (var t = 0; t < 3; t++) {
                var type = this.keyTypes[t];
                var prevKey = this.data.hierarchy[h].keys[0];
                var nextKey = this.getNextKeyWith(type, h, 1);
                while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                    prevKey = nextKey;
                    nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                }
                animationCache.prevKey[type] = prevKey;
                animationCache.nextKey[type] = nextKey;
            }
        }
    },
    resetBlendWeights: function() {
        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache;
            if (animationCache !== undefined) {
                var blending = animationCache.blending;
                blending.positionWeight = 0;
                blending.quaternionWeight = 0;
                blending.scaleWeight = 0;
            }
        }
    },
    update: function() {
        var points = [];
        var target = new THREE.Vector3();
        var newVector = new THREE.Vector3();
        var newQuat = new THREE.Quaternion();
        var interpolateCatmullRom = function(points, scale) {
            var c = [], v3 = [], point, intPoint, weight, w2, w3, pa, pb, pc, pd;
            point = (points.length - 1) * scale;
            intPoint = Math.floor(point);
            weight = point - intPoint;
            c[0] = intPoint === 0 ? intPoint : intPoint - 1;
            c[1] = intPoint;
            c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
            c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
            pa = points[c[0]];
            pb = points[c[1]];
            pc = points[c[2]];
            pd = points[c[3]];
            w2 = weight * weight;
            w3 = weight * w2;
            v3[0] = interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);
            v3[1] = interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);
            v3[2] = interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);
            return v3;
        };
        var interpolate = function(p0, p1, p2, p3, t, t2, t3) {
            var v0 = (p2 - p0) * .5, v1 = (p3 - p1) * .5;
            return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        };
        return function(delta) {
            if (this.isPlaying === false) return;
            this.currentTime += delta * this.timeScale;
            if (this.weight === 0) return;
            var duration = this.data.length;
            if (this.currentTime > duration || this.currentTime < 0) {
                if (this.loop) {
                    this.currentTime %= duration;
                    if (this.currentTime < 0) this.currentTime += duration;
                    this.reset();
                } else {
                    this.stop();
                }
            }
            for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
                var object = this.hierarchy[h];
                var animationCache = object.animationCache.animations[this.data.name];
                var blending = object.animationCache.blending;
                for (var t = 0; t < 3; t++) {
                    var type = this.keyTypes[t];
                    var prevKey = animationCache.prevKey[type];
                    var nextKey = animationCache.nextKey[type];
                    if (this.timeScale > 0 && nextKey.time <= this.currentTime || this.timeScale < 0 && prevKey.time >= this.currentTime) {
                        prevKey = this.data.hierarchy[h].keys[0];
                        nextKey = this.getNextKeyWith(type, h, 1);
                        while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                            prevKey = nextKey;
                            nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                        }
                        animationCache.prevKey[type] = prevKey;
                        animationCache.nextKey[type] = nextKey;
                    }
                    var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                    var prevXYZ = prevKey[type];
                    var nextXYZ = nextKey[type];
                    if (scale < 0) scale = 0;
                    if (scale > 1) scale = 1;
                    if (type === "pos") {
                        if (this.interpolationType === THREE.AnimationHandler.LINEAR) {
                            newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                            newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                            newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                            var proportionalWeight = this.weight / (this.weight + blending.positionWeight);
                            object.position.lerp(newVector, proportionalWeight);
                            blending.positionWeight += this.weight;
                        } else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
                            points[0] = this.getPrevKeyWith("pos", h, prevKey.index - 1)["pos"];
                            points[1] = prevXYZ;
                            points[2] = nextXYZ;
                            points[3] = this.getNextKeyWith("pos", h, nextKey.index + 1)["pos"];
                            scale = scale * .33 + .33;
                            var currentPoint = interpolateCatmullRom(points, scale);
                            var proportionalWeight = this.weight / (this.weight + blending.positionWeight);
                            blending.positionWeight += this.weight;
                            var vector = object.position;
                            vector.x = vector.x + (currentPoint[0] - vector.x) * proportionalWeight;
                            vector.y = vector.y + (currentPoint[1] - vector.y) * proportionalWeight;
                            vector.z = vector.z + (currentPoint[2] - vector.z) * proportionalWeight;
                            if (this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
                                var forwardPoint = interpolateCatmullRom(points, scale * 1.01);
                                target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                                target.sub(vector);
                                target.y = 0;
                                target.normalize();
                                var angle = Math.atan2(target.x, target.z);
                                object.rotation.set(0, angle, 0);
                            }
                        }
                    } else if (type === "rot") {
                        THREE.Quaternion.slerp(prevXYZ, nextXYZ, newQuat, scale);
                        if (blending.quaternionWeight === 0) {
                            object.quaternion.copy(newQuat);
                            blending.quaternionWeight = this.weight;
                        } else {
                            var proportionalWeight = this.weight / (this.weight + blending.quaternionWeight);
                            THREE.Quaternion.slerp(object.quaternion, newQuat, object.quaternion, proportionalWeight);
                            blending.quaternionWeight += this.weight;
                        }
                    } else if (type === "scl") {
                        newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                        newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                        newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                        var proportionalWeight = this.weight / (this.weight + blending.scaleWeight);
                        object.scale.lerp(newVector, proportionalWeight);
                        blending.scaleWeight += this.weight;
                    }
                }
            }
            return true;
        };
    }(),
    getNextKeyWith: function(type, h, key) {
        var keys = this.data.hierarchy[h].keys;
        if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
            key = key < keys.length - 1 ? key : keys.length - 1;
        } else {
            key = key % keys.length;
        }
        for (;key < keys.length; key++) {
            if (keys[key][type] !== undefined) {
                return keys[key];
            }
        }
        return this.data.hierarchy[h].keys[0];
    },
    getPrevKeyWith: function(type, h, key) {
        var keys = this.data.hierarchy[h].keys;
        if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
            key = key > 0 ? key : 0;
        } else {
            key = key >= 0 ? key : key + keys.length;
        }
        for (;key >= 0; key--) {
            if (keys[key][type] !== undefined) {
                return keys[key];
            }
        }
        return this.data.hierarchy[h].keys[keys.length - 1];
    }
};

THREE.KeyFrameAnimation = function(data) {
    this.root = data.node;
    this.data = THREE.AnimationHandler.init(data);
    this.hierarchy = THREE.AnimationHandler.parse(this.root);
    this.currentTime = 0;
    this.timeScale = .001;
    this.isPlaying = false;
    this.isPaused = true;
    this.loop = true;
    for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
        var keys = this.data.hierarchy[h].keys, sids = this.data.hierarchy[h].sids, obj = this.hierarchy[h];
        if (keys.length && sids) {
            for (var s = 0; s < sids.length; s++) {
                var sid = sids[s], next = this.getNextKeyWith(sid, h, 0);
                if (next) {
                    next.apply(sid);
                }
            }
            obj.matrixAutoUpdate = false;
            this.data.hierarchy[h].node.updateMatrix();
            obj.matrixWorldNeedsUpdate = true;
        }
    }
};

THREE.KeyFrameAnimation.prototype = {
    constructor: THREE.KeyFrameAnimation,
    play: function(startTime) {
        this.currentTime = startTime !== undefined ? startTime : 0;
        if (this.isPlaying === false) {
            this.isPlaying = true;
            var h, hl = this.hierarchy.length, object, node;
            for (h = 0; h < hl; h++) {
                object = this.hierarchy[h];
                node = this.data.hierarchy[h];
                if (node.animationCache === undefined) {
                    node.animationCache = {};
                    node.animationCache.prevKey = null;
                    node.animationCache.nextKey = null;
                    node.animationCache.originalMatrix = object.matrix;
                }
                var keys = this.data.hierarchy[h].keys;
                if (keys.length) {
                    node.animationCache.prevKey = keys[0];
                    node.animationCache.nextKey = keys[1];
                    this.startTime = Math.min(keys[0].time, this.startTime);
                    this.endTime = Math.max(keys[keys.length - 1].time, this.endTime);
                }
            }
            this.update(0);
        }
        this.isPaused = false;
        THREE.AnimationHandler.play(this);
    },
    stop: function() {
        this.isPlaying = false;
        this.isPaused = false;
        THREE.AnimationHandler.stop(this);
        for (var h = 0; h < this.data.hierarchy.length; h++) {
            var obj = this.hierarchy[h];
            var node = this.data.hierarchy[h];
            if (node.animationCache !== undefined) {
                var original = node.animationCache.originalMatrix;
                original.copy(obj.matrix);
                obj.matrix = original;
                delete node.animationCache;
            }
        }
    },
    update: function(delta) {
        if (this.isPlaying === false) return;
        this.currentTime += delta * this.timeScale;
        var duration = this.data.length;
        if (this.loop === true && this.currentTime > duration) {
            this.currentTime %= duration;
        }
        this.currentTime = Math.min(this.currentTime, duration);
        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var node = this.data.hierarchy[h];
            var keys = node.keys, animationCache = node.animationCache;
            if (keys.length) {
                var prevKey = animationCache.prevKey;
                var nextKey = animationCache.nextKey;
                if (nextKey.time <= this.currentTime) {
                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = keys[prevKey.index + 1];
                    }
                    animationCache.prevKey = prevKey;
                    animationCache.nextKey = nextKey;
                }
                if (nextKey.time >= this.currentTime) {
                    prevKey.interpolate(nextKey, this.currentTime);
                } else {
                    prevKey.interpolate(nextKey, nextKey.time);
                }
                this.data.hierarchy[h].node.updateMatrix();
                object.matrixWorldNeedsUpdate = true;
            }
        }
    },
    getNextKeyWith: function(sid, h, key) {
        var keys = this.data.hierarchy[h].keys;
        key = key % keys.length;
        for (;key < keys.length; key++) {
            if (keys[key].hasTarget(sid)) {
                return keys[key];
            }
        }
        return keys[0];
    },
    getPrevKeyWith: function(sid, h, key) {
        var keys = this.data.hierarchy[h].keys;
        key = key >= 0 ? key : key + keys.length;
        for (;key >= 0; key--) {
            if (keys[key].hasTarget(sid)) {
                return keys[key];
            }
        }
        return keys[keys.length - 1];
    }
};

THREE.MorphAnimation = function(mesh) {
    this.mesh = mesh;
    this.frames = mesh.morphTargetInfluences.length;
    this.currentTime = 0;
    this.duration = 1e3;
    this.loop = true;
    this.lastFrame = 0;
    this.currentFrame = 0;
    this.isPlaying = false;
};

THREE.MorphAnimation.prototype = {
    constructor: THREE.MorphAnimation,
    play: function() {
        this.isPlaying = true;
    },
    pause: function() {
        this.isPlaying = false;
    },
    update: function(delta) {
        if (this.isPlaying === false) return;
        this.currentTime += delta;
        if (this.loop === true && this.currentTime > this.duration) {
            this.currentTime %= this.duration;
        }
        this.currentTime = Math.min(this.currentTime, this.duration);
        var interpolation = this.duration / this.frames;
        var frame = Math.floor(this.currentTime / interpolation);
        var influences = this.mesh.morphTargetInfluences;
        if (frame != this.currentFrame) {
            influences[this.lastFrame] = 0;
            influences[this.currentFrame] = 1;
            influences[frame] = 0;
            this.lastFrame = this.currentFrame;
            this.currentFrame = frame;
        }
        influences[frame] = this.currentTime % interpolation / interpolation;
        influences[this.lastFrame] = 1 - influences[frame];
    }
};

THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
    THREE.Geometry.call(this);
    this.type = "BoxGeometry";
    this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
    };
    this.widthSegments = widthSegments || 1;
    this.heightSegments = heightSegments || 1;
    this.depthSegments = depthSegments || 1;
    var scope = this;
    var width_half = width / 2;
    var height_half = height / 2;
    var depth_half = depth / 2;
    buildPlane("z", "y", -1, -1, depth, height, width_half, 0);
    buildPlane("z", "y", 1, -1, depth, height, -width_half, 1);
    buildPlane("x", "z", 1, 1, width, depth, height_half, 2);
    buildPlane("x", "z", 1, -1, width, depth, -height_half, 3);
    buildPlane("x", "y", 1, -1, width, height, depth_half, 4);
    buildPlane("x", "y", -1, -1, width, height, -depth_half, 5);
    function buildPlane(u, v, udir, vdir, width, height, depth, materialIndex) {
        var w, ix, iy, gridX = scope.widthSegments, gridY = scope.heightSegments, width_half = width / 2, height_half = height / 2, offset = scope.vertices.length;
        if (u === "x" && v === "y" || u === "y" && v === "x") {
            w = "z";
        } else if (u === "x" && v === "z" || u === "z" && v === "x") {
            w = "y";
            gridY = scope.depthSegments;
        } else if (u === "z" && v === "y" || u === "y" && v === "z") {
            w = "x";
            gridX = scope.depthSegments;
        }
        var gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, normal = new THREE.Vector3();
        normal[w] = depth > 0 ? 1 : -1;
        for (iy = 0; iy < gridY1; iy++) {
            for (ix = 0; ix < gridX1; ix++) {
                var vector = new THREE.Vector3();
                vector[u] = (ix * segment_width - width_half) * udir;
                vector[v] = (iy * segment_height - height_half) * vdir;
                vector[w] = depth;
                scope.vertices.push(vector);
            }
        }
        for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * (iy + 1);
                var c = ix + 1 + gridX1 * (iy + 1);
                var d = ix + 1 + gridX1 * iy;
                var uva = new THREE.Vector2(ix / gridX, 1 - iy / gridY);
                var uvb = new THREE.Vector2(ix / gridX, 1 - (iy + 1) / gridY);
                var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iy + 1) / gridY);
                var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iy / gridY);
                var face = new THREE.Face3(a + offset, b + offset, d + offset);
                face.normal.copy(normal);
                face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
                face.materialIndex = materialIndex;
                scope.faces.push(face);
                scope.faceVertexUvs[0].push([ uva, uvb, uvd ]);
                face = new THREE.Face3(b + offset, c + offset, d + offset);
                face.normal.copy(normal);
                face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
                face.materialIndex = materialIndex;
                scope.faces.push(face);
                scope.faceVertexUvs[0].push([ uvb.clone(), uvc, uvd.clone() ]);
            }
        }
    }
    this.mergeVertices();
};

THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.CircleGeometry = function(radius, segments, thetaStart, thetaLength) {
    THREE.Geometry.call(this);
    this.type = "CircleGeometry";
    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    radius = radius || 50;
    segments = segments !== undefined ? Math.max(3, segments) : 8;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    var i, uvs = [], center = new THREE.Vector3(), centerUV = new THREE.Vector2(.5, .5);
    this.vertices.push(center);
    uvs.push(centerUV);
    for (i = 0; i <= segments; i++) {
        var vertex = new THREE.Vector3();
        var segment = thetaStart + i / segments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        this.vertices.push(vertex);
        uvs.push(new THREE.Vector2((vertex.x / radius + 1) / 2, (vertex.y / radius + 1) / 2));
    }
    var n = new THREE.Vector3(0, 0, 1);
    for (i = 1; i <= segments; i++) {
        this.faces.push(new THREE.Face3(i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ]));
        this.faceVertexUvs[0].push([ uvs[i].clone(), uvs[i + 1].clone(), centerUV.clone() ]);
    }
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
};

THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

THREE.CubeGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
    THREE.warn("THREE.CubeGeometry has been renamed to THREE.BoxGeometry.");
    return new THREE.BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);
};

THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    THREE.Geometry.call(this);
    this.type = "CylinderGeometry";
    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    radiusTop = radiusTop !== undefined ? radiusTop : 20;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    height = height !== undefined ? height : 100;
    radialSegments = radialSegments || 8;
    heightSegments = heightSegments || 1;
    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
    var heightHalf = height / 2;
    var x, y, vertices = [], uvs = [];
    for (y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var uvsRow = [];
        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (x = 0; x <= radialSegments; x++) {
            var u = x / radialSegments;
            var vertex = new THREE.Vector3();
            vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
            vertex.y = -v * height + heightHalf;
            vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
            this.vertices.push(vertex);
            verticesRow.push(this.vertices.length - 1);
            uvsRow.push(new THREE.Vector2(u, 1 - v));
        }
        vertices.push(verticesRow);
        uvs.push(uvsRow);
    }
    var tanTheta = (radiusBottom - radiusTop) / height;
    var na, nb;
    for (x = 0; x < radialSegments; x++) {
        if (radiusTop !== 0) {
            na = this.vertices[vertices[0][x]].clone();
            nb = this.vertices[vertices[0][x + 1]].clone();
        } else {
            na = this.vertices[vertices[1][x]].clone();
            nb = this.vertices[vertices[1][x + 1]].clone();
        }
        na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();
        nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();
        for (y = 0; y < heightSegments; y++) {
            var v1 = vertices[y][x];
            var v2 = vertices[y + 1][x];
            var v3 = vertices[y + 1][x + 1];
            var v4 = vertices[y][x + 1];
            var n1 = na.clone();
            var n2 = na.clone();
            var n3 = nb.clone();
            var n4 = nb.clone();
            var uv1 = uvs[y][x].clone();
            var uv2 = uvs[y + 1][x].clone();
            var uv3 = uvs[y + 1][x + 1].clone();
            var uv4 = uvs[y][x + 1].clone();
            this.faces.push(new THREE.Face3(v1, v2, v4, [ n1, n2, n4 ]));
            this.faceVertexUvs[0].push([ uv1, uv2, uv4 ]);
            this.faces.push(new THREE.Face3(v2, v3, v4, [ n2.clone(), n3, n4.clone() ]));
            this.faceVertexUvs[0].push([ uv2.clone(), uv3, uv4.clone() ]);
        }
    }
    if (openEnded === false && radiusTop > 0) {
        this.vertices.push(new THREE.Vector3(0, heightHalf, 0));
        for (x = 0; x < radialSegments; x++) {
            var v1 = vertices[0][x];
            var v2 = vertices[0][x + 1];
            var v3 = this.vertices.length - 1;
            var n1 = new THREE.Vector3(0, 1, 0);
            var n2 = new THREE.Vector3(0, 1, 0);
            var n3 = new THREE.Vector3(0, 1, 0);
            var uv1 = uvs[0][x].clone();
            var uv2 = uvs[0][x + 1].clone();
            var uv3 = new THREE.Vector2(uv2.x, 0);
            this.faces.push(new THREE.Face3(v1, v2, v3, [ n1, n2, n3 ]));
            this.faceVertexUvs[0].push([ uv1, uv2, uv3 ]);
        }
    }
    if (openEnded === false && radiusBottom > 0) {
        this.vertices.push(new THREE.Vector3(0, -heightHalf, 0));
        for (x = 0; x < radialSegments; x++) {
            var v1 = vertices[heightSegments][x + 1];
            var v2 = vertices[heightSegments][x];
            var v3 = this.vertices.length - 1;
            var n1 = new THREE.Vector3(0, -1, 0);
            var n2 = new THREE.Vector3(0, -1, 0);
            var n3 = new THREE.Vector3(0, -1, 0);
            var uv1 = uvs[heightSegments][x + 1].clone();
            var uv2 = uvs[heightSegments][x].clone();
            var uv3 = new THREE.Vector2(uv2.x, 1);
            this.faces.push(new THREE.Face3(v1, v2, v3, [ n1, n2, n3 ]));
            this.faceVertexUvs[0].push([ uv1, uv2, uv3 ]);
        }
    }
    this.computeFaceNormals();
};

THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

THREE.ExtrudeGeometry = function(shapes, options) {
    if (typeof shapes === "undefined") {
        shapes = [];
        return;
    }
    THREE.Geometry.call(this);
    this.type = "ExtrudeGeometry";
    shapes = shapes instanceof Array ? shapes : [ shapes ];
    this.addShapeList(shapes, options);
    this.computeFaceNormals();
};

THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {
    var sl = shapes.length;
    for (var s = 0; s < sl; s++) {
        var shape = shapes[s];
        this.addShape(shape, options);
    }
};

THREE.ExtrudeGeometry.prototype.addShape = function(shape, options) {
    var amount = options.amount !== undefined ? options.amount : 100;
    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
    var steps = options.steps !== undefined ? options.steps : 1;
    var extrudePath = options.extrudePath;
    var extrudePts, extrudeByPath = false;
    var material = options.material;
    var extrudeMaterial = options.extrudeMaterial;
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
    var splineTube, binormal, normal, position2;
    if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
        binormal = new THREE.Vector3();
        normal = new THREE.Vector3();
        position2 = new THREE.Vector3();
    }
    if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
    }
    var ahole, h, hl;
    var scope = this;
    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints(curveSegments);
    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;
    var reverse = !THREE.Shape.Utils.isClockWise(vertices);
    if (reverse) {
        vertices = vertices.reverse();
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            if (THREE.Shape.Utils.isClockWise(ahole)) {
                holes[h] = ahole.reverse();
            }
        }
        reverse = false;
    }
    var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);
    var contour = vertices;
    for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        vertices = vertices.concat(ahole);
    }
    function scalePt2(pt, vec, size) {
        if (!vec) THREE.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
    }
    var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
    function getBevelVec(inPt, inPrev, inNext) {
        var EPSILON = 1e-10;
        var v_trans_x, v_trans_y, shrink_by = 1;
        var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        var colinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(colinear0) > EPSILON) {
            var v_prev_len = Math.sqrt(v_prev_lensq);
            var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
            var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
            var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
            var ptNextShift_x = inNext.x - v_next_y / v_next_len;
            var ptNextShift_y = inNext.y + v_next_x / v_next_len;
            var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
            v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
            v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
            var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
            if (v_trans_lensq <= 2) {
                return new THREE.Vector2(v_trans_x, v_trans_y);
            } else {
                shrink_by = Math.sqrt(v_trans_lensq / 2);
            }
        } else {
            var direction_eq = false;
            if (v_prev_x > EPSILON) {
                if (v_next_x > EPSILON) {
                    direction_eq = true;
                }
            } else {
                if (v_prev_x < -EPSILON) {
                    if (v_next_x < -EPSILON) {
                        direction_eq = true;
                    }
                } else {
                    if (Math.sign(v_prev_y) == Math.sign(v_next_y)) {
                        direction_eq = true;
                    }
                }
            }
            if (direction_eq) {
                v_trans_x = -v_prev_y;
                v_trans_y = v_prev_x;
                shrink_by = Math.sqrt(v_prev_lensq);
            } else {
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt(v_prev_lensq / 2);
            }
        }
        return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
    }
    var contourMovements = [];
    for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
    }
    var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
    for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = [];
        for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
            if (j === il) j = 0;
            if (k === il) k = 0;
            oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
    }
    for (b = 0; b < bevelSegments; b++) {
        t = b / bevelSegments;
        z = bevelThickness * (1 - t);
        bs = bevelSize * Math.sin(t * Math.PI / 2);
        for (i = 0, il = contour.length; i < il; i++) {
            vert = scalePt2(contour[i], contourMovements[i], bs);
            v(vert.x, vert.y, -z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            oneHoleMovements = holesMovements[h];
            for (i = 0, il = ahole.length; i < il; i++) {
                vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                v(vert.x, vert.y, -z);
            }
        }
    }
    bs = bevelSize;
    for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
            v(vert.x, vert.y, 0);
        } else {
            normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
            position2.copy(extrudePts[0]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
        }
    }
    var s;
    for (s = 1; s <= steps; s++) {
        for (i = 0; i < vlen; i++) {
            vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
            if (!extrudeByPath) {
                v(vert.x, vert.y, amount / steps * s);
            } else {
                normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                position2.copy(extrudePts[s]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
            }
        }
    }
    for (b = bevelSegments - 1; b >= 0; b--) {
        t = b / bevelSegments;
        z = bevelThickness * (1 - t);
        bs = bevelSize * Math.sin(t * Math.PI / 2);
        for (i = 0, il = contour.length; i < il; i++) {
            vert = scalePt2(contour[i], contourMovements[i], bs);
            v(vert.x, vert.y, amount + z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            oneHoleMovements = holesMovements[h];
            for (i = 0, il = ahole.length; i < il; i++) {
                vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                if (!extrudeByPath) {
                    v(vert.x, vert.y, amount + z);
                } else {
                    v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                }
            }
        }
    }
    buildLidFaces();
    buildSideFaces();
    function buildLidFaces() {
        if (bevelEnabled) {
            var layer = 0;
            var offset = vlen * layer;
            for (i = 0; i < flen; i++) {
                face = faces[i];
                f3(face[2] + offset, face[1] + offset, face[0] + offset);
            }
            layer = steps + bevelSegments * 2;
            offset = vlen * layer;
            for (i = 0; i < flen; i++) {
                face = faces[i];
                f3(face[0] + offset, face[1] + offset, face[2] + offset);
            }
        } else {
            for (i = 0; i < flen; i++) {
                face = faces[i];
                f3(face[2], face[1], face[0]);
            }
            for (i = 0; i < flen; i++) {
                face = faces[i];
                f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
            }
        }
    }
    function buildSideFaces() {
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            sidewalls(ahole, layeroffset);
            layeroffset += ahole.length;
        }
    }
    function sidewalls(contour, layeroffset) {
        var j, k;
        i = contour.length;
        while (--i >= 0) {
            j = i;
            k = i - 1;
            if (k < 0) k = contour.length - 1;
            var s = 0, sl = steps + bevelSegments * 2;
            for (s = 0; s < sl; s++) {
                var slen1 = vlen * s;
                var slen2 = vlen * (s + 1);
                var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                f4(a, b, c, d, contour, s, sl, j, k);
            }
        }
    }
    function v(x, y, z) {
        scope.vertices.push(new THREE.Vector3(x, y, z));
    }
    function f3(a, b, c) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        scope.faces.push(new THREE.Face3(a, b, c, null, null, material));
        var uvs = uvgen.generateTopUV(scope, a, b, c);
        scope.faceVertexUvs[0].push(uvs);
    }
    function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;
        scope.faces.push(new THREE.Face3(a, b, d, null, null, extrudeMaterial));
        scope.faces.push(new THREE.Face3(b, c, d, null, null, extrudeMaterial));
        var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
        scope.faceVertexUvs[0].push([ uvs[0], uvs[1], uvs[3] ]);
        scope.faceVertexUvs[0].push([ uvs[1], uvs[2], uvs[3] ]);
    }
};

THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function(geometry, indexA, indexB, indexC) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        return [ new THREE.Vector2(a.x, a.y), new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y) ];
    },
    generateSideWallUV: function(geometry, indexA, indexB, indexC, indexD) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        var d = vertices[indexD];
        if (Math.abs(a.y - b.y) < .01) {
            return [ new THREE.Vector2(a.x, 1 - a.z), new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z) ];
        } else {
            return [ new THREE.Vector2(a.y, 1 - a.z), new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z) ];
        }
    }
};

THREE.ShapeGeometry = function(shapes, options) {
    THREE.Geometry.call(this);
    this.type = "ShapeGeometry";
    if (shapes instanceof Array === false) shapes = [ shapes ];
    this.addShapeList(shapes, options);
    this.computeFaceNormals();
};

THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

THREE.ShapeGeometry.prototype.addShapeList = function(shapes, options) {
    for (var i = 0, l = shapes.length; i < l; i++) {
        this.addShape(shapes[i], options);
    }
    return this;
};

THREE.ShapeGeometry.prototype.addShape = function(shape, options) {
    if (options === undefined) options = {};
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
    var material = options.material;
    var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
    var i, l, hole;
    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints(curveSegments);
    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;
    var reverse = !THREE.Shape.Utils.isClockWise(vertices);
    if (reverse) {
        vertices = vertices.reverse();
        for (i = 0, l = holes.length; i < l; i++) {
            hole = holes[i];
            if (THREE.Shape.Utils.isClockWise(hole)) {
                holes[i] = hole.reverse();
            }
        }
        reverse = false;
    }
    var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);
    var contour = vertices;
    for (i = 0, l = holes.length; i < l; i++) {
        hole = holes[i];
        vertices = vertices.concat(hole);
    }
    var vert, vlen = vertices.length;
    var face, flen = faces.length;
    for (i = 0; i < vlen; i++) {
        vert = vertices[i];
        this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));
    }
    for (i = 0; i < flen; i++) {
        face = faces[i];
        var a = face[0] + shapesOffset;
        var b = face[1] + shapesOffset;
        var c = face[2] + shapesOffset;
        this.faces.push(new THREE.Face3(a, b, c, null, null, material));
        this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
    }
};

THREE.LatheGeometry = function(points, segments, phiStart, phiLength) {
    THREE.Geometry.call(this);
    this.type = "LatheGeometry";
    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };
    segments = segments || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || 2 * Math.PI;
    var inversePointLength = 1 / (points.length - 1);
    var inverseSegments = 1 / segments;
    for (var i = 0, il = segments; i <= il; i++) {
        var phi = phiStart + i * inverseSegments * phiLength;
        var c = Math.cos(phi), s = Math.sin(phi);
        for (var j = 0, jl = points.length; j < jl; j++) {
            var pt = points[j];
            var vertex = new THREE.Vector3();
            vertex.x = c * pt.x - s * pt.y;
            vertex.y = s * pt.x + c * pt.y;
            vertex.z = pt.z;
            this.vertices.push(vertex);
        }
    }
    var np = points.length;
    for (var i = 0, il = segments; i < il; i++) {
        for (var j = 0, jl = points.length - 1; j < jl; j++) {
            var base = j + np * i;
            var a = base;
            var b = base + np;
            var c = base + 1 + np;
            var d = base + 1;
            var u0 = i * inverseSegments;
            var v0 = j * inversePointLength;
            var u1 = u0 + inverseSegments;
            var v1 = v0 + inversePointLength;
            this.faces.push(new THREE.Face3(a, b, d));
            this.faceVertexUvs[0].push([ new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1) ]);
            this.faces.push(new THREE.Face3(b, c, d));
            this.faceVertexUvs[0].push([ new THREE.Vector2(u1, v0), new THREE.Vector2(u1, v1), new THREE.Vector2(u0, v1) ]);
        }
    }
    this.mergeVertices();
    this.computeFaceNormals();
    this.computeVertexNormals();
};

THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
    console.info("THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.");
    THREE.Geometry.call(this);
    this.type = "PlaneGeometry";
    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };
    this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments));
};

THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneBufferGeometry = function(width, height, widthSegments, heightSegments) {
    THREE.BufferGeometry.call(this);
    this.type = "PlaneBufferGeometry";
    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };
    var width_half = width / 2;
    var height_half = height / 2;
    var gridX = widthSegments || 1;
    var gridY = heightSegments || 1;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var segment_width = width / gridX;
    var segment_height = height / gridY;
    var vertices = new Float32Array(gridX1 * gridY1 * 3);
    var normals = new Float32Array(gridX1 * gridY1 * 3);
    var uvs = new Float32Array(gridX1 * gridY1 * 2);
    var offset = 0;
    var offset2 = 0;
    for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segment_height - height_half;
        for (var ix = 0; ix < gridX1; ix++) {
            var x = ix * segment_width - width_half;
            vertices[offset] = x;
            vertices[offset + 1] = -y;
            normals[offset + 2] = 1;
            uvs[offset2] = ix / gridX;
            uvs[offset2 + 1] = 1 - iy / gridY;
            offset += 3;
            offset2 += 2;
        }
    }
    offset = 0;
    var indices = new (vertices.length / 3 > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
    for (var iy = 0; iy < gridY; iy++) {
        for (var ix = 0; ix < gridX; ix++) {
            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * (iy + 1);
            var c = ix + 1 + gridX1 * (iy + 1);
            var d = ix + 1 + gridX1 * iy;
            indices[offset] = a;
            indices[offset + 1] = b;
            indices[offset + 2] = d;
            indices[offset + 3] = b;
            indices[offset + 4] = c;
            indices[offset + 5] = d;
            offset += 6;
        }
    }
    this.addAttribute("index", new THREE.BufferAttribute(indices, 1));
    this.addAttribute("position", new THREE.BufferAttribute(vertices, 3));
    this.addAttribute("normal", new THREE.BufferAttribute(normals, 3));
    this.addAttribute("uv", new THREE.BufferAttribute(uvs, 2));
};

THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);

THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    THREE.Geometry.call(this);
    this.type = "RingGeometry";
    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    innerRadius = innerRadius || 0;
    outerRadius = outerRadius || 50;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
    phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 8;
    var i, o, uvs = [], radius = innerRadius, radiusStep = (outerRadius - innerRadius) / phiSegments;
    for (i = 0; i < phiSegments + 1; i++) {
        for (o = 0; o < thetaSegments + 1; o++) {
            var vertex = new THREE.Vector3();
            var segment = thetaStart + o / thetaSegments * thetaLength;
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            this.vertices.push(vertex);
            uvs.push(new THREE.Vector2((vertex.x / outerRadius + 1) / 2, (vertex.y / outerRadius + 1) / 2));
        }
        radius += radiusStep;
    }
    var n = new THREE.Vector3(0, 0, 1);
    for (i = 0; i < phiSegments; i++) {
        var thetaSegment = i * (thetaSegments + 1);
        for (o = 0; o < thetaSegments; o++) {
            var segment = o + thetaSegment;
            var v1 = segment;
            var v2 = segment + thetaSegments + 1;
            var v3 = segment + thetaSegments + 2;
            this.faces.push(new THREE.Face3(v1, v2, v3, [ n.clone(), n.clone(), n.clone() ]));
            this.faceVertexUvs[0].push([ uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone() ]);
            v1 = segment;
            v2 = segment + thetaSegments + 2;
            v3 = segment + 1;
            this.faces.push(new THREE.Face3(v1, v2, v3, [ n.clone(), n.clone(), n.clone() ]));
            this.faceVertexUvs[0].push([ uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone() ]);
        }
    }
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
};

THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    THREE.Geometry.call(this);
    this.type = "SphereGeometry";
    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    radius = radius || 50;
    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
    var x, y, vertices = [], uvs = [];
    for (y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var uvsRow = [];
        for (x = 0; x <= widthSegments; x++) {
            var u = x / widthSegments;
            var v = y / heightSegments;
            var vertex = new THREE.Vector3();
            vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
            vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            this.vertices.push(vertex);
            verticesRow.push(this.vertices.length - 1);
            uvsRow.push(new THREE.Vector2(u, 1 - v));
        }
        vertices.push(verticesRow);
        uvs.push(uvsRow);
    }
    for (y = 0; y < heightSegments; y++) {
        for (x = 0; x < widthSegments; x++) {
            var v1 = vertices[y][x + 1];
            var v2 = vertices[y][x];
            var v3 = vertices[y + 1][x];
            var v4 = vertices[y + 1][x + 1];
            var n1 = this.vertices[v1].clone().normalize();
            var n2 = this.vertices[v2].clone().normalize();
            var n3 = this.vertices[v3].clone().normalize();
            var n4 = this.vertices[v4].clone().normalize();
            var uv1 = uvs[y][x + 1].clone();
            var uv2 = uvs[y][x].clone();
            var uv3 = uvs[y + 1][x].clone();
            var uv4 = uvs[y + 1][x + 1].clone();
            if (Math.abs(this.vertices[v1].y) === radius) {
                uv1.x = (uv1.x + uv2.x) / 2;
                this.faces.push(new THREE.Face3(v1, v3, v4, [ n1, n3, n4 ]));
                this.faceVertexUvs[0].push([ uv1, uv3, uv4 ]);
            } else if (Math.abs(this.vertices[v3].y) === radius) {
                uv3.x = (uv3.x + uv4.x) / 2;
                this.faces.push(new THREE.Face3(v1, v2, v3, [ n1, n2, n3 ]));
                this.faceVertexUvs[0].push([ uv1, uv2, uv3 ]);
            } else {
                this.faces.push(new THREE.Face3(v1, v2, v4, [ n1, n2, n4 ]));
                this.faceVertexUvs[0].push([ uv1, uv2, uv4 ]);
                this.faces.push(new THREE.Face3(v2, v3, v4, [ n2.clone(), n3, n4.clone() ]));
                this.faceVertexUvs[0].push([ uv2.clone(), uv3, uv4.clone() ]);
            }
        }
    }
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
};

THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

THREE.TextGeometry = function(text, parameters) {
    parameters = parameters || {};
    var textShapes = THREE.FontUtils.generateShapes(text, parameters);
    parameters.amount = parameters.height !== undefined ? parameters.height : 50;
    if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
    if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
    if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
    THREE.ExtrudeGeometry.call(this, textShapes, parameters);
    this.type = "TextGeometry";
};

THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);

THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

THREE.TorusGeometry = function(radius, tube, radialSegments, tubularSegments, arc) {
    THREE.Geometry.call(this);
    this.type = "TorusGeometry";
    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };
    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;
    var center = new THREE.Vector3(), uvs = [], normals = [];
    for (var j = 0; j <= radialSegments; j++) {
        for (var i = 0; i <= tubularSegments; i++) {
            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;
            center.x = radius * Math.cos(u);
            center.y = radius * Math.sin(u);
            var vertex = new THREE.Vector3();
            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
            vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
            vertex.z = tube * Math.sin(v);
            this.vertices.push(vertex);
            uvs.push(new THREE.Vector2(i / tubularSegments, j / radialSegments));
            normals.push(vertex.clone().sub(center).normalize());
        }
    }
    for (var j = 1; j <= radialSegments; j++) {
        for (var i = 1; i <= tubularSegments; i++) {
            var a = (tubularSegments + 1) * j + i - 1;
            var b = (tubularSegments + 1) * (j - 1) + i - 1;
            var c = (tubularSegments + 1) * (j - 1) + i;
            var d = (tubularSegments + 1) * j + i;
            var face = new THREE.Face3(a, b, d, [ normals[a].clone(), normals[b].clone(), normals[d].clone() ]);
            this.faces.push(face);
            this.faceVertexUvs[0].push([ uvs[a].clone(), uvs[b].clone(), uvs[d].clone() ]);
            face = new THREE.Face3(b, c, d, [ normals[b].clone(), normals[c].clone(), normals[d].clone() ]);
            this.faces.push(face);
            this.faceVertexUvs[0].push([ uvs[b].clone(), uvs[c].clone(), uvs[d].clone() ]);
        }
    }
    this.computeFaceNormals();
};

THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

THREE.TorusKnotGeometry = function(radius, tube, radialSegments, tubularSegments, p, q, heightScale) {
    THREE.Geometry.call(this);
    this.type = "TorusKnotGeometry";
    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        heightScale: heightScale
    };
    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 64;
    tubularSegments = tubularSegments || 8;
    p = p || 2;
    q = q || 3;
    heightScale = heightScale || 1;
    var grid = new Array(radialSegments);
    var tang = new THREE.Vector3();
    var n = new THREE.Vector3();
    var bitan = new THREE.Vector3();
    for (var i = 0; i < radialSegments; ++i) {
        grid[i] = new Array(tubularSegments);
        var u = i / radialSegments * 2 * p * Math.PI;
        var p1 = getPos(u, q, p, radius, heightScale);
        var p2 = getPos(u + .01, q, p, radius, heightScale);
        tang.subVectors(p2, p1);
        n.addVectors(p2, p1);
        bitan.crossVectors(tang, n);
        n.crossVectors(bitan, tang);
        bitan.normalize();
        n.normalize();
        for (var j = 0; j < tubularSegments; ++j) {
            var v = j / tubularSegments * 2 * Math.PI;
            var cx = -tube * Math.cos(v);
            var cy = tube * Math.sin(v);
            var pos = new THREE.Vector3();
            pos.x = p1.x + cx * n.x + cy * bitan.x;
            pos.y = p1.y + cx * n.y + cy * bitan.y;
            pos.z = p1.z + cx * n.z + cy * bitan.z;
            grid[i][j] = this.vertices.push(pos) - 1;
        }
    }
    for (var i = 0; i < radialSegments; ++i) {
        for (var j = 0; j < tubularSegments; ++j) {
            var ip = (i + 1) % radialSegments;
            var jp = (j + 1) % tubularSegments;
            var a = grid[i][j];
            var b = grid[ip][j];
            var c = grid[ip][jp];
            var d = grid[i][jp];
            var uva = new THREE.Vector2(i / radialSegments, j / tubularSegments);
            var uvb = new THREE.Vector2((i + 1) / radialSegments, j / tubularSegments);
            var uvc = new THREE.Vector2((i + 1) / radialSegments, (j + 1) / tubularSegments);
            var uvd = new THREE.Vector2(i / radialSegments, (j + 1) / tubularSegments);
            this.faces.push(new THREE.Face3(a, b, d));
            this.faceVertexUvs[0].push([ uva, uvb, uvd ]);
            this.faces.push(new THREE.Face3(b, c, d));
            this.faceVertexUvs[0].push([ uvb.clone(), uvc, uvd.clone() ]);
        }
    }
    this.computeFaceNormals();
    this.computeVertexNormals();
    function getPos(u, in_q, in_p, radius, heightScale) {
        var cu = Math.cos(u);
        var su = Math.sin(u);
        var quOverP = in_q / in_p * u;
        var cs = Math.cos(quOverP);
        var tx = radius * (2 + cs) * .5 * cu;
        var ty = radius * (2 + cs) * su * .5;
        var tz = heightScale * radius * Math.sin(quOverP) * .5;
        return new THREE.Vector3(tx, ty, tz);
    }
};

THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

THREE.TubeGeometry = function(path, segments, radius, radialSegments, closed, taper) {
    THREE.Geometry.call(this);
    this.type = "TubeGeometry";
    this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
    };
    segments = segments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    taper = taper || THREE.TubeGeometry.NoTaper;
    var grid = [];
    var scope = this, tangent, normal, binormal, numpoints = segments + 1, u, v, r, cx, cy, pos, pos2 = new THREE.Vector3(), i, j, ip, jp, a, b, c, d, uva, uvb, uvc, uvd;
    var frames = new THREE.TubeGeometry.FrenetFrames(path, segments, closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;
    function vert(x, y, z) {
        return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;
    }
    for (i = 0; i < numpoints; i++) {
        grid[i] = [];
        u = i / (numpoints - 1);
        pos = path.getPointAt(u);
        tangent = tangents[i];
        normal = normals[i];
        binormal = binormals[i];
        r = radius * taper(u);
        for (j = 0; j < radialSegments; j++) {
            v = j / radialSegments * 2 * Math.PI;
            cx = -r * Math.cos(v);
            cy = r * Math.sin(v);
            pos2.copy(pos);
            pos2.x += cx * normal.x + cy * binormal.x;
            pos2.y += cx * normal.y + cy * binormal.y;
            pos2.z += cx * normal.z + cy * binormal.z;
            grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
        }
    }
    for (i = 0; i < segments; i++) {
        for (j = 0; j < radialSegments; j++) {
            ip = closed ? (i + 1) % segments : i + 1;
            jp = (j + 1) % radialSegments;
            a = grid[i][j];
            b = grid[ip][j];
            c = grid[ip][jp];
            d = grid[i][jp];
            uva = new THREE.Vector2(i / segments, j / radialSegments);
            uvb = new THREE.Vector2((i + 1) / segments, j / radialSegments);
            uvc = new THREE.Vector2((i + 1) / segments, (j + 1) / radialSegments);
            uvd = new THREE.Vector2(i / segments, (j + 1) / radialSegments);
            this.faces.push(new THREE.Face3(a, b, d));
            this.faceVertexUvs[0].push([ uva, uvb, uvd ]);
            this.faces.push(new THREE.Face3(b, c, d));
            this.faceVertexUvs[0].push([ uvb.clone(), uvc, uvd.clone() ]);
        }
    }
    this.computeFaceNormals();
    this.computeVertexNormals();
};

THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

THREE.TubeGeometry.NoTaper = function(u) {
    return 1;
};

THREE.TubeGeometry.SinusoidalTaper = function(u) {
    return Math.sin(Math.PI * u);
};

THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {
    var normal = new THREE.Vector3(), tangents = [], normals = [], binormals = [], vec = new THREE.Vector3(), mat = new THREE.Matrix4(), numpoints = segments + 1, theta, epsilon = 1e-4, smallest, tx, ty, tz, i, u;
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;
    for (i = 0; i < numpoints; i++) {
        u = i / (numpoints - 1);
        tangents[i] = path.getTangentAt(u);
        tangents[i].normalize();
    }
    initialNormal3();
    function initialNormal3() {
        normals[0] = new THREE.Vector3();
        binormals[0] = new THREE.Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs(tangents[0].x);
        ty = Math.abs(tangents[0].y);
        tz = Math.abs(tangents[0].z);
        if (tx <= smallest) {
            smallest = tx;
            normal.set(1, 0, 0);
        }
        if (ty <= smallest) {
            smallest = ty;
            normal.set(0, 1, 0);
        }
        if (tz <= smallest) {
            normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
    }
    for (i = 1; i < numpoints; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);
        if (vec.length() > epsilon) {
            vec.normalize();
            theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
            normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed) {
        theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
        theta /= numpoints - 1;
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
            theta = -theta;
        }
        for (i = 1; i < numpoints; i++) {
            normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
            binormals[i].crossVectors(tangents[i], normals[i]);
        }
    }
};

THREE.PolyhedronGeometry = function(vertices, indices, radius, detail) {
    THREE.Geometry.call(this);
    this.type = "PolyhedronGeometry";
    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };
    radius = radius || 1;
    detail = detail || 0;
    var that = this;
    for (var i = 0, l = vertices.length; i < l; i += 3) {
        prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
    }
    var p = this.vertices;
    var faces = [];
    for (var i = 0, j = 0, l = indices.length; i < l; i += 3, j++) {
        var v1 = p[indices[i]];
        var v2 = p[indices[i + 1]];
        var v3 = p[indices[i + 2]];
        faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ]);
    }
    var centroid = new THREE.Vector3();
    for (var i = 0, l = faces.length; i < l; i++) {
        subdivide(faces[i], detail);
    }
    for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {
        var uvs = this.faceVertexUvs[0][i];
        var x0 = uvs[0].x;
        var x1 = uvs[1].x;
        var x2 = uvs[2].x;
        var max = Math.max(x0, Math.max(x1, x2));
        var min = Math.min(x0, Math.min(x1, x2));
        if (max > .9 && min < .1) {
            if (x0 < .2) uvs[0].x += 1;
            if (x1 < .2) uvs[1].x += 1;
            if (x2 < .2) uvs[2].x += 1;
        }
    }
    for (var i = 0, l = this.vertices.length; i < l; i++) {
        this.vertices[i].multiplyScalar(radius);
    }
    this.mergeVertices();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    function prepare(vector) {
        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push(vertex) - 1;
        var u = azimuth(vector) / 2 / Math.PI + .5;
        var v = inclination(vector) / Math.PI + .5;
        vertex.uv = new THREE.Vector2(u, 1 - v);
        return vertex;
    }
    function make(v1, v2, v3) {
        var face = new THREE.Face3(v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ]);
        that.faces.push(face);
        centroid.copy(v1).add(v2).add(v3).divideScalar(3);
        var azi = azimuth(centroid);
        that.faceVertexUvs[0].push([ correctUV(v1.uv, v1, azi), correctUV(v2.uv, v2, azi), correctUV(v3.uv, v3, azi) ]);
    }
    function subdivide(face, detail) {
        var cols = Math.pow(2, detail);
        var a = prepare(that.vertices[face.a]);
        var b = prepare(that.vertices[face.b]);
        var c = prepare(that.vertices[face.c]);
        var v = [];
        for (var i = 0; i <= cols; i++) {
            v[i] = [];
            var aj = prepare(a.clone().lerp(c, i / cols));
            var bj = prepare(b.clone().lerp(c, i / cols));
            var rows = cols - i;
            for (var j = 0; j <= rows; j++) {
                if (j == 0 && i == cols) {
                    v[i][j] = aj;
                } else {
                    v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
                }
            }
        }
        for (var i = 0; i < cols; i++) {
            for (var j = 0; j < 2 * (cols - i) - 1; j++) {
                var k = Math.floor(j / 2);
                if (j % 2 == 0) {
                    make(v[i][k + 1], v[i + 1][k], v[i][k]);
                } else {
                    make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k]);
                }
            }
        }
    }
    function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
    function correctUV(uv, vector, azimuth) {
        if (azimuth < 0 && uv.x === 1) uv = new THREE.Vector2(uv.x - 1, uv.y);
        if (vector.x === 0 && vector.z === 0) uv = new THREE.Vector2(azimuth / 2 / Math.PI + .5, uv.y);
        return uv.clone();
    }
};

THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

THREE.DodecahedronGeometry = function(radius, detail) {
    this.parameters = {
        radius: radius,
        detail: detail
    };
    var t = (1 + Math.sqrt(5)) / 2;
    var r = 1 / t;
    var vertices = [ -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r ];
    var indices = [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ];
    THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
};

THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

THREE.IcosahedronGeometry = function(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var vertices = [ -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1 ];
    var indices = [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ];
    THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
};

THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

THREE.OctahedronGeometry = function(radius, detail) {
    this.parameters = {
        radius: radius,
        detail: detail
    };
    var vertices = [ 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1 ];
    var indices = [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ];
    THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
};

THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

THREE.TetrahedronGeometry = function(radius, detail) {
    var vertices = [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ];
    var indices = [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ];
    THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
};

THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

THREE.ParametricGeometry = function(func, slices, stacks) {
    THREE.Geometry.call(this);
    this.type = "ParametricGeometry";
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    var verts = this.vertices;
    var faces = this.faces;
    var uvs = this.faceVertexUvs[0];
    var i, j, p;
    var u, v;
    var sliceCount = slices + 1;
    for (i = 0; i <= stacks; i++) {
        v = i / stacks;
        for (j = 0; j <= slices; j++) {
            u = j / slices;
            p = func(u, v);
            verts.push(p);
        }
    }
    var a, b, c, d;
    var uva, uvb, uvc, uvd;
    for (i = 0; i < stacks; i++) {
        for (j = 0; j < slices; j++) {
            a = i * sliceCount + j;
            b = i * sliceCount + j + 1;
            c = (i + 1) * sliceCount + j + 1;
            d = (i + 1) * sliceCount + j;
            uva = new THREE.Vector2(j / slices, i / stacks);
            uvb = new THREE.Vector2((j + 1) / slices, i / stacks);
            uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);
            uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);
            faces.push(new THREE.Face3(a, b, d));
            uvs.push([ uva, uvb, uvd ]);
            faces.push(new THREE.Face3(b, c, d));
            uvs.push([ uvb.clone(), uvc, uvd.clone() ]);
        }
    }
    this.computeFaceNormals();
    this.computeVertexNormals();
};

THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);

THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

THREE.AxisHelper = function(size) {
    size = size || 1;
    var vertices = new Float32Array([ 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size ]);
    var colors = new Float32Array([ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ]);
    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute("position", new THREE.BufferAttribute(vertices, 3));
    geometry.addAttribute("color", new THREE.BufferAttribute(colors, 3));
    var material = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    });
    THREE.Line.call(this, geometry, material, THREE.LinePieces);
};

THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);

THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

THREE.ArrowHelper = function() {
    var lineGeometry = new THREE.Geometry();
    lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
    var coneGeometry = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
    coneGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -.5, 0));
    return function(dir, origin, length, color, headLength, headWidth) {
        THREE.Object3D.call(this);
        if (color === undefined) color = 16776960;
        if (length === undefined) length = 1;
        if (headLength === undefined) headLength = .2 * length;
        if (headWidth === undefined) headWidth = .2 * headLength;
        this.position.copy(origin);
        this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({
            color: color
        }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({
            color: color
        }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
    };
}();

THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);

THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = function() {
    var axis = new THREE.Vector3();
    var radians;
    return function(dir) {
        if (dir.y > .99999) {
            this.quaternion.set(0, 0, 0, 1);
        } else if (dir.y < -.99999) {
            this.quaternion.set(1, 0, 0, 0);
        } else {
            axis.set(dir.z, 0, -dir.x).normalize();
            radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(axis, radians);
        }
    };
}();

THREE.ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
    if (headLength === undefined) headLength = .2 * length;
    if (headWidth === undefined) headWidth = .2 * headLength;
    this.line.scale.set(1, length - headLength, 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
};

THREE.ArrowHelper.prototype.setColor = function(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
};

THREE.BoxHelper = function(object) {
    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3));
    THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: 16776960
    }), THREE.LinePieces);
    if (object !== undefined) {
        this.update(object);
    }
};

THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);

THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = function(object) {
    var geometry = object.geometry;
    if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
    }
    var min = geometry.boundingBox.min;
    var max = geometry.boundingBox.max;
    var vertices = this.geometry.attributes.position.array;
    vertices[0] = max.x;
    vertices[1] = max.y;
    vertices[2] = max.z;
    vertices[3] = min.x;
    vertices[4] = max.y;
    vertices[5] = max.z;
    vertices[6] = min.x;
    vertices[7] = max.y;
    vertices[8] = max.z;
    vertices[9] = min.x;
    vertices[10] = min.y;
    vertices[11] = max.z;
    vertices[12] = min.x;
    vertices[13] = min.y;
    vertices[14] = max.z;
    vertices[15] = max.x;
    vertices[16] = min.y;
    vertices[17] = max.z;
    vertices[18] = max.x;
    vertices[19] = min.y;
    vertices[20] = max.z;
    vertices[21] = max.x;
    vertices[22] = max.y;
    vertices[23] = max.z;
    vertices[24] = max.x;
    vertices[25] = max.y;
    vertices[26] = min.z;
    vertices[27] = min.x;
    vertices[28] = max.y;
    vertices[29] = min.z;
    vertices[30] = min.x;
    vertices[31] = max.y;
    vertices[32] = min.z;
    vertices[33] = min.x;
    vertices[34] = min.y;
    vertices[35] = min.z;
    vertices[36] = min.x;
    vertices[37] = min.y;
    vertices[38] = min.z;
    vertices[39] = max.x;
    vertices[40] = min.y;
    vertices[41] = min.z;
    vertices[42] = max.x;
    vertices[43] = min.y;
    vertices[44] = min.z;
    vertices[45] = max.x;
    vertices[46] = max.y;
    vertices[47] = min.z;
    vertices[48] = max.x;
    vertices[49] = max.y;
    vertices[50] = max.z;
    vertices[51] = max.x;
    vertices[52] = max.y;
    vertices[53] = min.z;
    vertices[54] = min.x;
    vertices[55] = max.y;
    vertices[56] = max.z;
    vertices[57] = min.x;
    vertices[58] = max.y;
    vertices[59] = min.z;
    vertices[60] = min.x;
    vertices[61] = min.y;
    vertices[62] = max.z;
    vertices[63] = min.x;
    vertices[64] = min.y;
    vertices[65] = min.z;
    vertices[66] = max.x;
    vertices[67] = min.y;
    vertices[68] = max.z;
    vertices[69] = max.x;
    vertices[70] = min.y;
    vertices[71] = min.z;
    this.geometry.attributes.position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
};

THREE.BoundingBoxHelper = function(object, hex) {
    var color = hex !== undefined ? hex : 8947848;
    this.object = object;
    this.box = new THREE.Box3();
    THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true
    }));
};

THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);

THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function() {
    this.box.setFromObject(this.object);
    this.box.size(this.scale);
    this.box.center(this.position);
};

THREE.CameraHelper = function(camera) {
    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial({
        color: 16777215,
        vertexColors: THREE.FaceColors
    });
    var pointMap = {};
    var hexFrustum = 16755200;
    var hexCone = 16711680;
    var hexUp = 43775;
    var hexTarget = 16777215;
    var hexCross = 3355443;
    addLine("n1", "n2", hexFrustum);
    addLine("n2", "n4", hexFrustum);
    addLine("n4", "n3", hexFrustum);
    addLine("n3", "n1", hexFrustum);
    addLine("f1", "f2", hexFrustum);
    addLine("f2", "f4", hexFrustum);
    addLine("f4", "f3", hexFrustum);
    addLine("f3", "f1", hexFrustum);
    addLine("n1", "f1", hexFrustum);
    addLine("n2", "f2", hexFrustum);
    addLine("n3", "f3", hexFrustum);
    addLine("n4", "f4", hexFrustum);
    addLine("p", "n1", hexCone);
    addLine("p", "n2", hexCone);
    addLine("p", "n3", hexCone);
    addLine("p", "n4", hexCone);
    addLine("u1", "u2", hexUp);
    addLine("u2", "u3", hexUp);
    addLine("u3", "u1", hexUp);
    addLine("c", "t", hexTarget);
    addLine("p", "c", hexCross);
    addLine("cn1", "cn2", hexCross);
    addLine("cn3", "cn4", hexCross);
    addLine("cf1", "cf2", hexCross);
    addLine("cf3", "cf4", hexCross);
    function addLine(a, b, hex) {
        addPoint(a, hex);
        addPoint(b, hex);
    }
    function addPoint(id, hex) {
        geometry.vertices.push(new THREE.Vector3());
        geometry.colors.push(new THREE.Color(hex));
        if (pointMap[id] === undefined) {
            pointMap[id] = [];
        }
        pointMap[id].push(geometry.vertices.length - 1);
    }
    THREE.Line.call(this, geometry, material, THREE.LinePieces);
    this.camera = camera;
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
};

THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);

THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function() {
    var geometry, pointMap;
    var vector = new THREE.Vector3();
    var camera = new THREE.Camera();
    var setPoint = function(point, x, y, z) {
        vector.set(x, y, z).unproject(camera);
        var points = pointMap[point];
        if (points !== undefined) {
            for (var i = 0, il = points.length; i < il; i++) {
                geometry.vertices[points[i]].copy(vector);
            }
        }
    };
    return function() {
        geometry = this.geometry;
        pointMap = this.pointMap;
        var w = 1, h = 1;
        camera.projectionMatrix.copy(this.camera.projectionMatrix);
        setPoint("c", 0, 0, -1);
        setPoint("t", 0, 0, 1);
        setPoint("n1", -w, -h, -1);
        setPoint("n2", w, -h, -1);
        setPoint("n3", -w, h, -1);
        setPoint("n4", w, h, -1);
        setPoint("f1", -w, -h, 1);
        setPoint("f2", w, -h, 1);
        setPoint("f3", -w, h, 1);
        setPoint("f4", w, h, 1);
        setPoint("u1", w * .7, h * 1.1, -1);
        setPoint("u2", -w * .7, h * 1.1, -1);
        setPoint("u3", 0, h * 2, -1);
        setPoint("cf1", -w, 0, 1);
        setPoint("cf2", w, 0, 1);
        setPoint("cf3", 0, -h, 1);
        setPoint("cf4", 0, h, 1);
        setPoint("cn1", -w, 0, -1);
        setPoint("cn2", w, 0, -1);
        setPoint("cn3", 0, -h, -1);
        setPoint("cn4", 0, h, -1);
        geometry.verticesNeedUpdate = true;
    };
}();

THREE.DirectionalLightHelper = function(light, size) {
    THREE.Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    size = size || 1;
    var geometry = new THREE.Geometry();
    geometry.vertices.push(new THREE.Vector3(-size, size, 0), new THREE.Vector3(size, size, 0), new THREE.Vector3(size, -size, 0), new THREE.Vector3(-size, -size, 0), new THREE.Vector3(-size, size, 0));
    var material = new THREE.LineBasicMaterial({
        fog: false
    });
    material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.lightPlane = new THREE.Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new THREE.Geometry();
    geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
    material = new THREE.LineBasicMaterial({
        fog: false
    });
    material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine = new THREE.Line(geometry, material);
    this.add(this.targetLine);
    this.update();
};

THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);

THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function() {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var v3 = new THREE.Vector3();
    return function() {
        v1.setFromMatrixPosition(this.light.matrixWorld);
        v2.setFromMatrixPosition(this.light.target.matrixWorld);
        v3.subVectors(v2, v1);
        this.lightPlane.lookAt(v3);
        this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine.geometry.vertices[1].copy(v3);
        this.targetLine.geometry.verticesNeedUpdate = true;
        this.targetLine.material.color.copy(this.lightPlane.material.color);
    };
}();

THREE.EdgesHelper = function(object, hex, thresholdAngle) {
    var color = hex !== undefined ? hex : 16777215;
    thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
    var thresholdDot = Math.cos(THREE.Math.degToRad(thresholdAngle));
    var edge = [ 0, 0 ], hash = {};
    var sortFunction = function(a, b) {
        return a - b;
    };
    var keys = [ "a", "b", "c" ];
    var geometry = new THREE.BufferGeometry();
    var geometry2;
    if (object.geometry instanceof THREE.BufferGeometry) {
        geometry2 = new THREE.Geometry();
        geometry2.fromBufferGeometry(object.geometry);
    } else {
        geometry2 = object.geometry.clone();
    }
    geometry2.mergeVertices();
    geometry2.computeFaceNormals();
    var vertices = geometry2.vertices;
    var faces = geometry2.faces;
    var numEdges = 0;
    for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0; j < 3; j++) {
            edge[0] = face[keys[j]];
            edge[1] = face[keys[(j + 1) % 3]];
            edge.sort(sortFunction);
            var key = edge.toString();
            if (hash[key] === undefined) {
                hash[key] = {
                    vert1: edge[0],
                    vert2: edge[1],
                    face1: i,
                    face2: undefined
                };
                numEdges++;
            } else {
                hash[key].face2 = i;
            }
        }
    }
    var coords = new Float32Array(numEdges * 2 * 3);
    var index = 0;
    for (var key in hash) {
        var h = hash[key];
        if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
            var vertex = vertices[h.vert1];
            coords[index++] = vertex.x;
            coords[index++] = vertex.y;
            coords[index++] = vertex.z;
            vertex = vertices[h.vert2];
            coords[index++] = vertex.x;
            coords[index++] = vertex.y;
            coords[index++] = vertex.z;
        }
    }
    geometry.addAttribute("position", new THREE.BufferAttribute(coords, 3));
    THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color
    }), THREE.LinePieces);
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
};

THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);

THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

THREE.FaceNormalsHelper = function(object, size, hex, linewidth) {
    this.object = object;
    this.size = size !== undefined ? size : 1;
    var color = hex !== undefined ? hex : 16776960;
    var width = linewidth !== undefined ? linewidth : 1;
    var geometry = new THREE.Geometry();
    var faces = this.object.geometry.faces;
    for (var i = 0, l = faces.length; i < l; i++) {
        geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
    }
    THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
    }), THREE.LinePieces);
    this.matrixAutoUpdate = false;
    this.normalMatrix = new THREE.Matrix3();
    this.update();
};

THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);

THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = function() {
    var vertices = this.geometry.vertices;
    var object = this.object;
    var objectVertices = object.geometry.vertices;
    var objectFaces = object.geometry.faces;
    var objectWorldMatrix = object.matrixWorld;
    object.updateMatrixWorld(true);
    this.normalMatrix.getNormalMatrix(objectWorldMatrix);
    for (var i = 0, i2 = 0, l = objectFaces.length; i < l; i++, i2 += 2) {
        var face = objectFaces[i];
        vertices[i2].copy(objectVertices[face.a]).add(objectVertices[face.b]).add(objectVertices[face.c]).divideScalar(3).applyMatrix4(objectWorldMatrix);
        vertices[i2 + 1].copy(face.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(vertices[i2]);
    }
    this.geometry.verticesNeedUpdate = true;
    return this;
};

THREE.GridHelper = function(size, step) {
    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    });
    this.color1 = new THREE.Color(4473924);
    this.color2 = new THREE.Color(8947848);
    for (var i = -size; i <= size; i += step) {
        geometry.vertices.push(new THREE.Vector3(-size, 0, i), new THREE.Vector3(size, 0, i), new THREE.Vector3(i, 0, -size), new THREE.Vector3(i, 0, size));
        var color = i === 0 ? this.color1 : this.color2;
        geometry.colors.push(color, color, color, color);
    }
    THREE.Line.call(this, geometry, material, THREE.LinePieces);
};

THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);

THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function(colorCenterLine, colorGrid) {
    this.color1.set(colorCenterLine);
    this.color2.set(colorGrid);
    this.geometry.colorsNeedUpdate = true;
};

THREE.HemisphereLightHelper = function(light, sphereSize) {
    THREE.Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.colors = [ new THREE.Color(), new THREE.Color() ];
    var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
    geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
    for (var i = 0, il = 8; i < il; i++) {
        geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
    }
    var material = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: true
    });
    this.lightSphere = new THREE.Mesh(geometry, material);
    this.add(this.lightSphere);
    this.update();
};

THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);

THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function() {
    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function() {
    var vector = new THREE.Vector3();
    return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = true;
    };
}();

THREE.PointLightHelper = function(light, sphereSize) {
    this.light = light;
    this.light.updateMatrixWorld();
    var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
    var material = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false
    });
    material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    THREE.Mesh.call(this, geometry, material);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
};

THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);

THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function() {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
};

THREE.SkeletonHelper = function(object) {
    this.bones = this.getBoneList(object);
    var geometry = new THREE.Geometry();
    for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent instanceof THREE.Bone) {
            geometry.vertices.push(new THREE.Vector3());
            geometry.vertices.push(new THREE.Vector3());
            geometry.colors.push(new THREE.Color(0, 0, 1));
            geometry.colors.push(new THREE.Color(0, 1, 0));
        }
    }
    var material = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
    });
    THREE.Line.call(this, geometry, material, THREE.LinePieces);
    this.root = object;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
};

THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype);

THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function(object) {
    var boneList = [];
    if (object instanceof THREE.Bone) {
        boneList.push(object);
    }
    for (var i = 0; i < object.children.length; i++) {
        boneList.push.apply(boneList, this.getBoneList(object.children[i]));
    }
    return boneList;
};

THREE.SkeletonHelper.prototype.update = function() {
    var geometry = this.geometry;
    var matrixWorldInv = new THREE.Matrix4().getInverse(this.root.matrixWorld);
    var boneMatrix = new THREE.Matrix4();
    var j = 0;
    for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent instanceof THREE.Bone) {
            boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
            geometry.vertices[j].setFromMatrixPosition(boneMatrix);
            boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
            geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
            j += 2;
        }
    }
    geometry.verticesNeedUpdate = true;
    geometry.computeBoundingSphere();
};

THREE.SpotLightHelper = function(light) {
    THREE.Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    var geometry = new THREE.CylinderGeometry(0, 1, 1, 8, 1, true);
    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -.5, 0));
    geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
    var material = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false
    });
    this.cone = new THREE.Mesh(geometry, material);
    this.add(this.cone);
    this.update();
};

THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);

THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function() {
    var vector = new THREE.Vector3();
    var vector2 = new THREE.Vector3();
    return function() {
        var coneLength = this.light.distance ? this.light.distance : 1e4;
        var coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        vector.setFromMatrixPosition(this.light.matrixWorld);
        vector2.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(vector2.sub(vector));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
}();

THREE.VertexNormalsHelper = function(object, size, hex, linewidth) {
    this.object = object;
    this.size = size !== undefined ? size : 1;
    var color = hex !== undefined ? hex : 16711680;
    var width = linewidth !== undefined ? linewidth : 1;
    var geometry = new THREE.Geometry();
    var faces = object.geometry.faces;
    for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
            geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
        }
    }
    THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
    }), THREE.LinePieces);
    this.matrixAutoUpdate = false;
    this.normalMatrix = new THREE.Matrix3();
    this.update();
};

THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);

THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = function(object) {
    var v1 = new THREE.Vector3();
    return function(object) {
        var keys = [ "a", "b", "c", "d" ];
        this.object.updateMatrixWorld(true);
        this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var vertices = this.geometry.vertices;
        var verts = this.object.geometry.vertices;
        var faces = this.object.geometry.faces;
        var worldMatrix = this.object.matrixWorld;
        var idx = 0;
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                var vertexId = face[keys[j]];
                var vertex = verts[vertexId];
                var normal = face.vertexNormals[j];
                vertices[idx].copy(vertex).applyMatrix4(worldMatrix);
                v1.copy(normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
                v1.add(vertices[idx]);
                idx = idx + 1;
                vertices[idx].copy(v1);
                idx = idx + 1;
            }
        }
        this.geometry.verticesNeedUpdate = true;
        return this;
    };
}();

THREE.VertexTangentsHelper = function(object, size, hex, linewidth) {
    this.object = object;
    this.size = size !== undefined ? size : 1;
    var color = hex !== undefined ? hex : 255;
    var width = linewidth !== undefined ? linewidth : 1;
    var geometry = new THREE.Geometry();
    var faces = object.geometry.faces;
    for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0, jl = face.vertexTangents.length; j < jl; j++) {
            geometry.vertices.push(new THREE.Vector3());
            geometry.vertices.push(new THREE.Vector3());
        }
    }
    THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
    }), THREE.LinePieces);
    this.matrixAutoUpdate = false;
    this.update();
};

THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);

THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;

THREE.VertexTangentsHelper.prototype.update = function(object) {
    var v1 = new THREE.Vector3();
    return function(object) {
        var keys = [ "a", "b", "c", "d" ];
        this.object.updateMatrixWorld(true);
        var vertices = this.geometry.vertices;
        var verts = this.object.geometry.vertices;
        var faces = this.object.geometry.faces;
        var worldMatrix = this.object.matrixWorld;
        var idx = 0;
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0, jl = face.vertexTangents.length; j < jl; j++) {
                var vertexId = face[keys[j]];
                var vertex = verts[vertexId];
                var tangent = face.vertexTangents[j];
                vertices[idx].copy(vertex).applyMatrix4(worldMatrix);
                v1.copy(tangent).transformDirection(worldMatrix).multiplyScalar(this.size);
                v1.add(vertices[idx]);
                idx = idx + 1;
                vertices[idx].copy(v1);
                idx = idx + 1;
            }
        }
        this.geometry.verticesNeedUpdate = true;
        return this;
    };
}();

THREE.WireframeHelper = function(object, hex) {
    var color = hex !== undefined ? hex : 16777215;
    var edge = [ 0, 0 ], hash = {};
    var sortFunction = function(a, b) {
        return a - b;
    };
    var keys = [ "a", "b", "c" ];
    var geometry = new THREE.BufferGeometry();
    if (object.geometry instanceof THREE.Geometry) {
        var vertices = object.geometry.vertices;
        var faces = object.geometry.faces;
        var numEdges = 0;
        var edges = new Uint32Array(6 * faces.length);
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0; j < 3; j++) {
                edge[0] = face[keys[j]];
                edge[1] = face[keys[(j + 1) % 3]];
                edge.sort(sortFunction);
                var key = edge.toString();
                if (hash[key] === undefined) {
                    edges[2 * numEdges] = edge[0];
                    edges[2 * numEdges + 1] = edge[1];
                    hash[key] = true;
                    numEdges++;
                }
            }
        }
        var coords = new Float32Array(numEdges * 2 * 3);
        for (var i = 0, l = numEdges; i < l; i++) {
            for (var j = 0; j < 2; j++) {
                var vertex = vertices[edges[2 * i + j]];
                var index = 6 * i + 3 * j;
                coords[index + 0] = vertex.x;
                coords[index + 1] = vertex.y;
                coords[index + 2] = vertex.z;
            }
        }
        geometry.addAttribute("position", new THREE.BufferAttribute(coords, 3));
    } else if (object.geometry instanceof THREE.BufferGeometry) {
        if (object.geometry.attributes.index !== undefined) {
            var vertices = object.geometry.attributes.position.array;
            var indices = object.geometry.attributes.index.array;
            var drawcalls = object.geometry.drawcalls;
            var numEdges = 0;
            if (drawcalls.length === 0) {
                drawcalls = [ {
                    count: indices.length,
                    index: 0,
                    start: 0
                } ];
            }
            var edges = new Uint32Array(2 * indices.length);
            for (var o = 0, ol = drawcalls.length; o < ol; ++o) {
                var start = drawcalls[o].start;
                var count = drawcalls[o].count;
                var index = drawcalls[o].index;
                for (var i = start, il = start + count; i < il; i += 3) {
                    for (var j = 0; j < 3; j++) {
                        edge[0] = index + indices[i + j];
                        edge[1] = index + indices[i + (j + 1) % 3];
                        edge.sort(sortFunction);
                        var key = edge.toString();
                        if (hash[key] === undefined) {
                            edges[2 * numEdges] = edge[0];
                            edges[2 * numEdges + 1] = edge[1];
                            hash[key] = true;
                            numEdges++;
                        }
                    }
                }
            }
            var coords = new Float32Array(numEdges * 2 * 3);
            for (var i = 0, l = numEdges; i < l; i++) {
                for (var j = 0; j < 2; j++) {
                    var index = 6 * i + 3 * j;
                    var index2 = 3 * edges[2 * i + j];
                    coords[index + 0] = vertices[index2];
                    coords[index + 1] = vertices[index2 + 1];
                    coords[index + 2] = vertices[index2 + 2];
                }
            }
            geometry.addAttribute("position", new THREE.BufferAttribute(coords, 3));
        } else {
            var vertices = object.geometry.attributes.position.array;
            var numEdges = vertices.length / 3;
            var numTris = numEdges / 3;
            var coords = new Float32Array(numEdges * 2 * 3);
            for (var i = 0, l = numTris; i < l; i++) {
                for (var j = 0; j < 3; j++) {
                    var index = 18 * i + 6 * j;
                    var index1 = 9 * i + 3 * j;
                    coords[index + 0] = vertices[index1];
                    coords[index + 1] = vertices[index1 + 1];
                    coords[index + 2] = vertices[index1 + 2];
                    var index2 = 9 * i + 3 * ((j + 1) % 3);
                    coords[index + 3] = vertices[index2];
                    coords[index + 4] = vertices[index2 + 1];
                    coords[index + 5] = vertices[index2 + 2];
                }
            }
            geometry.addAttribute("position", new THREE.BufferAttribute(coords, 3));
        }
    }
    THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color
    }), THREE.LinePieces);
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
};

THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);

THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

THREE.ImmediateRenderObject = function() {
    THREE.Object3D.call(this);
    this.render = function(renderCallback) {};
};

THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);

THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

THREE.MorphBlendMesh = function(geometry, material) {
    THREE.Mesh.call(this, geometry, material);
    this.animationsMap = {};
    this.animationsList = [];
    var numFrames = this.geometry.morphTargets.length;
    var name = "__default";
    var startFrame = 0;
    var endFrame = numFrames - 1;
    var fps = numFrames / 1;
    this.createAnimation(name, startFrame, endFrame, fps);
    this.setAnimationWeight(name, 1);
};

THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);

THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {
    var animation = {
        startFrame: start,
        endFrame: end,
        length: end - start + 1,
        fps: fps,
        duration: (end - start) / fps,
        lastFrame: 0,
        currentFrame: 0,
        active: false,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: false,
        mirroredLoop: false
    };
    this.animationsMap[name] = animation;
    this.animationsList.push(animation);
};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {
    var pattern = /([a-z]+)_?(\d+)/;
    var firstAnimation, frameRanges = {};
    var geometry = this.geometry;
    for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
        var morph = geometry.morphTargets[i];
        var chunks = morph.name.match(pattern);
        if (chunks && chunks.length > 1) {
            var name = chunks[1];
            if (!frameRanges[name]) frameRanges[name] = {
                start: Infinity,
                end: -Infinity
            };
            var range = frameRanges[name];
            if (i < range.start) range.start = i;
            if (i > range.end) range.end = i;
            if (!firstAnimation) firstAnimation = name;
        }
    }
    for (var name in frameRanges) {
        var range = frameRanges[name];
        this.createAnimation(name, range.start, range.end, fps);
    }
    this.firstAnimation = firstAnimation;
};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.direction = 1;
        animation.directionBackwards = false;
    }
};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.direction = -1;
        animation.directionBackwards = true;
    }
};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.fps = fps;
        animation.duration = (animation.end - animation.start) / animation.fps;
    }
};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.duration = duration;
        animation.fps = (animation.end - animation.start) / animation.duration;
    }
};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.weight = weight;
    }
};

THREE.MorphBlendMesh.prototype.setAnimationTime = function(name, time) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.time = time;
    }
};

THREE.MorphBlendMesh.prototype.getAnimationTime = function(name) {
    var time = 0;
    var animation = this.animationsMap[name];
    if (animation) {
        time = animation.time;
    }
    return time;
};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function(name) {
    var duration = -1;
    var animation = this.animationsMap[name];
    if (animation) {
        duration = animation.duration;
    }
    return duration;
};

THREE.MorphBlendMesh.prototype.playAnimation = function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.time = 0;
        animation.active = true;
    } else {
        THREE.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
    }
};

THREE.MorphBlendMesh.prototype.stopAnimation = function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.active = false;
    }
};

THREE.MorphBlendMesh.prototype.update = function(delta) {
    for (var i = 0, il = this.animationsList.length; i < il; i++) {
        var animation = this.animationsList[i];
        if (!animation.active) continue;
        var frameTime = animation.duration / animation.length;
        animation.time += animation.direction * delta;
        if (animation.mirroredLoop) {
            if (animation.time > animation.duration || animation.time < 0) {
                animation.direction *= -1;
                if (animation.time > animation.duration) {
                    animation.time = animation.duration;
                    animation.directionBackwards = true;
                }
                if (animation.time < 0) {
                    animation.time = 0;
                    animation.directionBackwards = false;
                }
            }
        } else {
            animation.time = animation.time % animation.duration;
            if (animation.time < 0) animation.time += animation.duration;
        }
        var keyframe = animation.startFrame + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
        var weight = animation.weight;
        if (keyframe !== animation.currentFrame) {
            this.morphTargetInfluences[animation.lastFrame] = 0;
            this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
            this.morphTargetInfluences[keyframe] = 0;
            animation.lastFrame = animation.currentFrame;
            animation.currentFrame = keyframe;
        }
        var mix = animation.time % frameTime / frameTime;
        if (animation.directionBackwards) mix = 1 - mix;
        this.morphTargetInfluences[animation.currentFrame] = mix * weight;
        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
    }
};

THREE.OrbitControls = function(object, domElement) {
    this.object = object;
    this.domElement = domElement !== undefined ? domElement : document;
    this.enabled = true;
    this.target = new THREE.Vector3();
    this.center = this.target;
    this.noZoom = false;
    this.zoomSpeed = 1;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.noRotate = false;
    this.rotateSpeed = 1;
    this.noPan = false;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.noKeys = false;
    this.keys = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40
    };
    var scope = this;
    var EPS = 1e-6;
    var rotateStart = new THREE.Vector2();
    var rotateEnd = new THREE.Vector2();
    var rotateDelta = new THREE.Vector2();
    var panStart = new THREE.Vector2();
    var panEnd = new THREE.Vector2();
    var panDelta = new THREE.Vector2();
    var dollyStart = new THREE.Vector2();
    var dollyEnd = new THREE.Vector2();
    var dollyDelta = new THREE.Vector2();
    var phiDelta = 0;
    var thetaDelta = 0;
    var scale = 1;
    var pan = new THREE.Vector3();
    var lastPosition = new THREE.Vector3();
    var STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_DOLLY: 4,
        TOUCH_PAN: 5
    };
    var state = STATE.NONE;
    var changeEvent = {
        type: "change"
    };
    this.rotateLeft = function(angle) {
        if (angle === undefined) {
            angle = getAutoRotationAngle();
        }
        thetaDelta -= angle;
    };
    this.rotateUp = function(angle) {
        if (angle === undefined) {
            angle = getAutoRotationAngle();
        }
        phiDelta -= angle;
    };
    this.panLeft = function(distance) {
        var panOffset = new THREE.Vector3();
        var te = this.object.matrix.elements;
        panOffset.set(te[0], te[1], te[2]);
        panOffset.multiplyScalar(-distance);
        pan.add(panOffset);
    };
    this.panUp = function(distance) {
        var panOffset = new THREE.Vector3();
        var te = this.object.matrix.elements;
        panOffset.set(te[4], te[5], te[6]);
        panOffset.multiplyScalar(distance);
        pan.add(panOffset);
    };
    this.pan = function(delta) {
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        if (scope.object.fov !== undefined) {
            var position = scope.object.position;
            var offset = position.clone().sub(scope.target);
            var targetDistance = offset.length();
            targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
            scope.panLeft(2 * delta.x * targetDistance / element.clientHeight);
            scope.panUp(2 * delta.y * targetDistance / element.clientHeight);
        } else if (scope.object.top !== undefined) {
            scope.panLeft(delta.x * (scope.object.right - scope.object.left) / element.clientWidth);
            scope.panUp(delta.y * (scope.object.top - scope.object.bottom) / element.clientHeight);
        } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
        }
    };
    this.dollyIn = function(dollyScale) {
        if (dollyScale === undefined) {
            dollyScale = getZoomScale();
        }
        scale /= dollyScale;
    };
    this.dollyOut = function(dollyScale) {
        if (dollyScale === undefined) {
            dollyScale = getZoomScale();
        }
        scale *= dollyScale;
    };
    this.update = function() {
        var position = this.object.position;
        var offset = position.clone().sub(this.target);
        var theta = Math.atan2(offset.x, offset.z);
        var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);
        if (this.autoRotate) {
            this.rotateLeft(getAutoRotationAngle());
        }
        theta += thetaDelta;
        phi += phiDelta;
        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));
        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));
        var radius = offset.length() * scale;
        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));
        this.target.add(pan);
        offset.x = radius * Math.sin(phi) * Math.sin(theta);
        offset.y = radius * Math.cos(phi);
        offset.z = radius * Math.sin(phi) * Math.cos(theta);
        position.copy(this.target).add(offset);
        this.object.lookAt(this.target);
        thetaDelta = 0;
        phiDelta = 0;
        scale = 1;
        pan.set(0, 0, 0);
        if (lastPosition.distanceTo(this.object.position) > 0) {
            this.dispatchEvent(changeEvent);
            lastPosition.copy(this.object.position);
        }
    };
    function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
        return Math.pow(.95, scope.zoomSpeed);
    }
    function onMouseDown(event) {
        if (scope.enabled === false) {
            return;
        }
        event.preventDefault();
        if (event.button === 0) {
            if (scope.noRotate === true) {
                return;
            }
            state = STATE.ROTATE;
            rotateStart.set(event.clientX, event.clientY);
        } else if (event.button === 1) {
            if (scope.noZoom === true) {
                return;
            }
            state = STATE.DOLLY;
            dollyStart.set(event.clientX, event.clientY);
        } else if (event.button === 2) {
            if (scope.noPan === true) {
                return;
            }
            state = STATE.PAN;
            panStart.set(event.clientX, event.clientY);
        }
        scope.domElement.addEventListener("mousemove", onMouseMove, false);
        scope.domElement.addEventListener("mouseup", onMouseUp, false);
    }
    function onMouseMove(event) {
        if (scope.enabled === false) return;
        event.preventDefault();
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        if (state === STATE.ROTATE) {
            if (scope.noRotate === true) return;
            rotateEnd.set(event.clientX, event.clientY);
            rotateDelta.subVectors(rotateEnd, rotateStart);
            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
            rotateStart.copy(rotateEnd);
        } else if (state === STATE.DOLLY) {
            if (scope.noZoom === true) return;
            dollyEnd.set(event.clientX, event.clientY);
            dollyDelta.subVectors(dollyEnd, dollyStart);
            if (dollyDelta.y > 0) {
                scope.dollyIn();
            } else {
                scope.dollyOut();
            }
            dollyStart.copy(dollyEnd);
        } else if (state === STATE.PAN) {
            if (scope.noPan === true) return;
            panEnd.set(event.clientX, event.clientY);
            panDelta.subVectors(panEnd, panStart);
            scope.pan(panDelta);
            panStart.copy(panEnd);
        }
        scope.update();
    }
    function onMouseUp() {
        if (scope.enabled === false) return;
        scope.domElement.removeEventListener("mousemove", onMouseMove, false);
        scope.domElement.removeEventListener("mouseup", onMouseUp, false);
        state = STATE.NONE;
    }
    function onMouseWheel(event) {
        if (scope.enabled === false || scope.noZoom === true) return;
        var delta = 0;
        if (event.wheelDelta) {
            delta = event.wheelDelta;
        } else if (event.detail) {
            delta = -event.detail;
        }
        if (delta > 0) {
            scope.dollyOut();
        } else {
            scope.dollyIn();
        }
    }
    function onKeyDown(event) {
        if (scope.enabled === false) {
            return;
        }
        if (scope.noKeys === true) {
            return;
        }
        if (scope.noPan === true) {
            return;
        }
        var needUpdate = false;
        switch (event.keyCode) {
          case scope.keys.UP:
            scope.pan(new THREE.Vector2(0, scope.keyPanSpeed));
            needUpdate = true;
            break;

          case scope.keys.BOTTOM:
            scope.pan(new THREE.Vector2(0, -scope.keyPanSpeed));
            needUpdate = true;
            break;

          case scope.keys.LEFT:
            scope.pan(new THREE.Vector2(scope.keyPanSpeed, 0));
            needUpdate = true;
            break;

          case scope.keys.RIGHT:
            scope.pan(new THREE.Vector2(-scope.keyPanSpeed, 0));
            needUpdate = true;
            break;
        }
        if (needUpdate) {
            scope.update();
        }
    }
    function touchstart(event) {
        if (scope.enabled === false) {
            return;
        }
        switch (event.touches.length) {
          case 1:
            if (scope.noRotate === true) {
                return;
            }
            state = STATE.TOUCH_ROTATE;
            rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
            break;

          case 2:
            if (scope.noZoom === true) {
                return;
            }
            state = STATE.TOUCH_DOLLY;
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            dollyStart.set(0, distance);
            break;

          case 3:
            if (scope.noPan === true) {
                return;
            }
            state = STATE.TOUCH_PAN;
            panStart.set(event.touches[0].pageX, event.touches[0].pageY);
            break;

          default:
            state = STATE.NONE;
        }
    }
    function touchmove(event) {
        if (scope.enabled === false) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        switch (event.touches.length) {
          case 1:
            if (scope.noRotate === true) {
                return;
            }
            if (state !== STATE.TOUCH_ROTATE) {
                return;
            }
            rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
            rotateDelta.subVectors(rotateEnd, rotateStart);
            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
            rotateStart.copy(rotateEnd);
            break;

          case 2:
            if (scope.noZoom === true) {
                return;
            }
            if (state !== STATE.TOUCH_DOLLY) {
                return;
            }
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            dollyEnd.set(0, distance);
            dollyDelta.subVectors(dollyEnd, dollyStart);
            if (dollyDelta.y > 0) {
                scope.dollyOut();
            } else {
                scope.dollyIn();
            }
            dollyStart.copy(dollyEnd);
            break;

          case 3:
            if (scope.noPan === true) {
                return;
            }
            if (state !== STATE.TOUCH_PAN) {
                return;
            }
            panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
            panDelta.subVectors(panEnd, panStart);
            scope.pan(panDelta);
            panStart.copy(panEnd);
            break;

          default:
            state = STATE.NONE;
        }
    }
    function touchend() {
        if (scope.enabled === false) {
            return;
        }
        state = STATE.NONE;
    }
    this.domElement.addEventListener("contextmenu", function(event) {
        event.preventDefault();
    }, false);
    this.domElement.addEventListener("mousedown", onMouseDown, false);
    this.domElement.addEventListener("mousewheel", onMouseWheel, false);
    this.domElement.addEventListener("DOMMouseScroll", onMouseWheel, false);
    this.domElement.addEventListener("keydown", onKeyDown, false);
    this.domElement.addEventListener("touchstart", touchstart, false);
    this.domElement.addEventListener("touchend", touchend, false);
    this.domElement.addEventListener("touchmove", touchmove, false);
};

THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);

var WAGNER = WAGNER || {};

WAGNER.vertexShadersPath = "./vertex-shaders";

WAGNER.fragmentShadersPath = "./fragment-shaders";

WAGNER.assetsPath = "./assets";

WAGNER.log = function() {
    return;
    console.log(Array.prototype.slice.call(arguments).join(" "));
};

WAGNER.Composer = function(renderer, settings) {
    this.width = 1;
    this.height = 1;
    this.settings = settings || {};
    this.useRGBA = this.settings.useRGBA || false;
    this.renderer = renderer;
    this.copyPass = new WAGNER.CopyPass(this.settings);
    this.scene = new THREE.Scene();
    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1), this.defaultMaterial);
    this.scene.add(this.quad);
    this.camera = new THREE.OrthographicCamera(1, 1, 1, 1, -1e4, 1e4);
    this.front = new THREE.WebGLRenderTarget(1, 1, {
        minFilter: this.settings.minFilter !== undefined ? this.settings.minFilter : THREE.LinearFilter,
        magFilter: this.settings.magFilter !== undefined ? this.settings.magFilter : THREE.LinearFilter,
        wrapS: this.settings.wrapS !== undefined ? this.settings.wrapS : THREE.ClampToEdgeWrapping,
        wrapT: this.settings.wrapT !== undefined ? this.settings.wrapT : THREE.ClampToEdgeWrapping,
        format: this.useRGBA ? THREE.RGBAFormat : THREE.RGBFormat,
        type: this.settings.type !== undefined ? this.settings.type : THREE.UnsignedByteType,
        stencilBuffer: this.settings.stencilBuffer !== undefined ? this.settings.stencilBuffer : true
    });
    this.back = this.front.clone();
    this.startTime = Date.now();
    this.passes = {};
};

WAGNER.Composer.prototype.linkPass = function(id, pass) {
    function WagnerLoadPassException(message) {
        this.message = 'Pass "' + id + '" already loaded.';
        this.name = "WagnerLoadPassException";
        this.toString = function() {
            return this.message;
        };
    }
    if (this.passes[id]) {
        throw new WagnerLoadPassException(id, pass);
    }
    this.passes[id] = pass;
};

WAGNER.Composer.prototype.swapBuffers = function() {
    this.output = this.write;
    this.input = this.read;
    var t = this.write;
    this.write = this.read;
    this.read = t;
};

WAGNER.Composer.prototype.render = function(scene, camera, keep, output) {
    if (this.copyPass.isLoaded()) {
        if (keep) this.swapBuffers();
        this.renderer.render(scene, camera, output ? output : this.write, true);
        if (!output) this.swapBuffers();
    }
};

WAGNER.Composer.prototype.toScreen = function() {
    if (this.copyPass.isLoaded()) {
        this.quad.material = this.copyPass.shader;
        this.quad.material.uniforms.tInput.value = this.read;
        this.quad.material.uniforms.resolution.value.set(this.width, this.height);
        this.renderer.render(this.scene, this.camera);
    }
};

WAGNER.Composer.prototype.toTexture = function(t) {
    if (this.copyPass.isLoaded()) {
        this.quad.material = this.copyPass.shader;
        this.quad.material.uniforms.tInput.value = this.read;
        this.renderer.render(this.scene, this.camera, t, true);
    }
};

WAGNER.Composer.prototype.pass = function(pass, uniforms) {
    if (typeof pass === "string") {
        this.quad.material = this.passes[pass];
    }
    if (pass instanceof THREE.ShaderMaterial) {
        this.quad.material = pass;
    }
    if (pass instanceof WAGNER.Pass) {
        if (!pass.isLoaded()) return;
        pass.run(this);
        return;
    }
    if (!pass.isSim) this.quad.material.uniforms.tInput.value = this.read;
    for (var j in uniforms) {
        this.quad.material.uniforms[j].value = uniforms[j];
    }
    this.quad.material.uniforms.resolution.value.set(this.width, this.height);
    this.quad.material.uniforms.time.value = .001 * (Date.now() - this.startTime);
    this.renderer.render(this.scene, this.camera, this.write, false);
    this.swapBuffers();
};

WAGNER.Composer.prototype.reset = function() {
    this.read = this.front;
    this.write = this.back;
    this.output = this.write;
    this.input = this.read;
};

WAGNER.Composer.prototype.setSource = function(src) {
    if (this.copyPass.isLoaded()) {
        this.quad.material = this.copyPass.shader;
        this.quad.material.uniforms.tInput.value = src;
        this.renderer.render(this.scene, this.camera, this.write, true);
        this.swapBuffers();
    }
};

WAGNER.Composer.prototype.setSize = function(w, h) {
    this.width = w;
    this.height = h;
    this.camera.projectionMatrix.makeOrthographic(w / -2, w / 2, h / 2, h / -2, this.camera.near, this.camera.far);
    this.quad.scale.set(w, h, 1);
    var rt = this.front.clone();
    rt.width = w;
    rt.height = h;
    if (this.quad.material instanceof WAGNER.Pass) this.quad.material.uniforms.tInput.value = rt;
    this.front = rt;
    rt = this.back.clone();
    rt.width = w;
    rt.height = h;
    this.back = rt;
};

WAGNER.Composer.prototype.defaultMaterial = new THREE.MeshBasicMaterial();

WAGNER.loadShader = function(file, callback) {
    var oReq = new XMLHttpRequest();
    oReq.onload = function() {
        var content = oReq.responseText;
        callback(content);
    }.bind(this);
    oReq.onerror = function() {
        function WagnerLoadShaderException(f) {
            this.message = 'Shader "' + f + "\" couldn't be loaded.";
            this.name = "WagnerLoadShaderException";
            this.toString = function() {
                return this.message;
            };
        }
        throw new WagnerLoadShaderException(file);
    };
    oReq.onabort = function() {
        function WagnerLoadShaderException(f) {
            this.message = 'Shader "' + f + '" load was aborted.';
            this.name = "WagnerLoadShaderException";
            this.toString = function() {
                return this.message;
            };
        }
        throw new WagnerLoadShaderException(file);
    };
    oReq.open("get", file, true);
    oReq.send();
};

WAGNER.processShader = function(vertexShaderCode, fragmentShaderCode) {
    WAGNER.log("Processing Shader | Performing uniform Reflection...");
    var regExp = /uniform\s+([^\s]+)\s+([^\s]+)\s*;/gi;
    var regExp2 = /uniform\s+([^\s]+)\s+([^\s]+)\s*\[\s*(\w+)\s*\]*\s*;/gi;
    var typesMap = {
        sampler2D: {
            type: "t",
            value: function() {
                return new THREE.Texture();
            }
        },
        samplerCube: {
            type: "t",
            value: function() {}
        },
        bool: {
            type: "b",
            value: function() {
                return 0;
            }
        },
        "int": {
            type: "i",
            value: function() {
                return 0;
            }
        },
        "float": {
            type: "f",
            value: function() {
                return 0;
            }
        },
        vec2: {
            type: "v2",
            value: function() {
                return new THREE.Vector2();
            }
        },
        vec3: {
            type: "v3",
            value: function() {
                return new THREE.Vector3();
            }
        },
        vec4: {
            type: "v4",
            value: function() {
                return new THREE.Vector4();
            }
        },
        bvec2: {
            type: "v2",
            value: function() {
                return new THREE.Vector2();
            }
        },
        bvec3: {
            type: "v3",
            value: function() {
                return new THREE.Vector3();
            }
        },
        bvec4: {
            type: "v4",
            value: function() {
                return new THREE.Vector4();
            }
        },
        ivec2: {
            type: "v2",
            value: function() {
                return new THREE.Vector2();
            }
        },
        ivec3: {
            type: "v3",
            value: function() {
                return new THREE.Vector3();
            }
        },
        ivec4: {
            type: "v4",
            value: function() {
                return new THREE.Vector4();
            }
        },
        mat2: {
            type: "v2",
            value: function() {
                return new THREE.Matrix2();
            }
        },
        mat3: {
            type: "v3",
            value: function() {
                return new THREE.Matrix3();
            }
        },
        mat4: {
            type: "v4",
            value: function() {
                return new THREE.Matrix4();
            }
        }
    };
    var arrayTypesMap = {
        "float": {
            type: "fv",
            value: function() {
                return [];
            }
        },
        vec3: {
            type: "v3v",
            value: function() {
                return [];
            }
        }
    };
    var matches;
    var uniforms = {
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1, 1),
            "default": true
        },
        time: {
            type: "f",
            value: Date.now(),
            "default": true
        },
        tInput: {
            type: "t",
            value: new THREE.Texture(),
            "default": true
        }
    };
    var uniformType, uniformName, arraySize;
    while ((matches = regExp.exec(fragmentShaderCode)) !== null) {
        if (matches.index === regExp.lastIndex) {
            regExp.lastIndex++;
        }
        uniformType = matches[1];
        uniformName = matches[2];
        WAGNER.log("  > SINGLE", uniformType, uniformName);
        uniforms[uniformName] = {
            type: typesMap[uniformType].type,
            value: typesMap[uniformType].value()
        };
    }
    while ((matches = regExp2.exec(fragmentShaderCode)) !== null) {
        if (matches.index === regExp.lastIndex) {
            regExp.lastIndex++;
        }
        uniformType = matches[1];
        uniformName = matches[2];
        arraySize = matches[3];
        WAGNER.log("  > ARRAY", arraySize, uniformType, uniformName);
        uniforms[uniformName] = {
            type: arrayTypesMap[uniformType].type,
            value: arrayTypesMap[uniformType].value()
        };
    }
    WAGNER.log("Uniform reflection completed. Compiling...");
    var shader = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShaderCode,
        fragmentShader: fragmentShaderCode,
        shading: THREE.FlatShading,
        depthWrite: false,
        depthTest: false,
        transparent: true
    });
    WAGNER.log("Compiled");
    return shader;
};

WAGNER.Pass = function() {
    WAGNER.log("Pass constructor");
    this.shader = null;
    this.loaded = null;
    this.params = {};
    this.isSim = false;
};

WAGNER.GLSLList = {
    "blend-fs.glsl": "varying vec2 a;uniform sampler2D tInput;uniform sampler2D tInput2;uniform vec2 resolution;uniform vec2 resolution2;uniform float aspectRatio;uniform float aspectRatio2;uniform float opacity;uniform int mode;uniform int sizeMode;vec2 b=a;float e(float c,float d){return c<.5?2.*c*d:1.-2.*(1.-c)*(1.-d);}float f(float c,float d){return d<.5?2.*c*d+c*c*(1.-2.*d):sqrt(c)*(2.*d-1.)+2.*c*(1.-d);}float g(float c,float d){return d==0.?d:max(1.-(1.-c)/d,0.);}float h(float c,float d){return d==1.?d:min(c/(1.-d),1.);}float i(float c,float d){return max(c+d-1.,0.);}float j(float c,float d){return min(c+d,1.);}float k(float c,float d){return d<.5?i(c,2.*d):j(c,2.*(d-.5));}void main(){if(sizeMode==1){if(aspectRatio2>aspectRatio){b.x*=aspectRatio/aspectRatio2;    b.x+=.5*(1.-aspectRatio/aspectRatio2);}if(aspectRatio2<aspectRatio){b.y*=aspectRatio2/aspectRatio;    b.y+=.5*(1.-aspectRatio2/aspectRatio);}}vec4 c,d;c=texture2D(tInput,a);d=texture2D(tInput2,b);if(mode==1){gl_FragColor=c;    gl_FragColor.a*=opacity;return;}if(mode==2){}if(mode==3){gl_FragColor=min(c,d);    return;}if(mode==4){gl_FragColor=c*d;    return;}if(mode==5){gl_FragColor=vec4(g(c.r,d.r),g(c.g,d.g),g(c.b,d.b),g(c.a,d.a));    return;}if(mode==6){gl_FragColor=max(c+d-1.,0.);    return;}if(mode==7){}if(mode==8){gl_FragColor=max(c,d);    return;}if(mode==9){gl_FragColor=1.-(1.-c)*(1.-d);    gl_FragColor=gl_FragColor*opacity+c*(1.-opacity);return;}if(mode==10){gl_FragColor=vec4(h(c.r,d.r),h(c.g,d.g),h(c.b,d.b),h(c.a,d.a));    return;}if(mode==11){gl_FragColor=min(c+d,1.);    return;}if(mode==12){}if(mode==13){gl_FragColor=(gl_FragColor=vec4(e(c.r,d.r),e(c.g,d.g),e(c.b,d.b),e(c.a,d.a)));    gl_FragColor=gl_FragColor*opacity+c*(1.-opacity);return;}if(mode==14){gl_FragColor=vec4(f(c.r,d.r),f(c.g,d.g),f(c.b,d.b),f(c.a,d.a));    return;}if(mode==15){gl_FragColor=vec4(e(c.r,d.r),e(c.g,d.g),e(c.b,d.b),e(c.a,d.a));    gl_FragColor=gl_FragColor*opacity+c*(1.-opacity);return;}if(mode==16){}if(mode==17){gl_FragColor=vec4(k(c.r,d.r),k(c.g,d.g),k(c.b,d.b),k(c.a,d.a));    return;}if(mode==18){}if(mode==19){}if(mode==20){gl_FragColor=abs(c-d);    gl_FragColor.a=c.a+d.b;return;}if(mode==21)gl_FragColor=c+d-2.*c*d;if(mode==22){}if(mode==23){}gl_FragColor=vec4(1,0,1,1);}",
    "vignette-fs.glsl": "uniform sampler2D tInput;uniform float falloff;uniform float amount;varying vec2 a;void main(){vec4 b=texture2D(tInput,a);float c=distance(a,vec2(.5));b.rgb*=smoothstep(.8,falloff*.799,c*(amount+falloff));gl_FragColor=b;}",
    "vignette2-fs.glsl": "varying vec2 a;uniform sampler2D tInput;uniform vec2 resolution;uniform float reduction;uniform float boost;void main(){vec4 b=texture2D(tInput,a);vec2 c=resolution*.5;float d=distance(c,gl_FragCoord.xy)/resolution.x;d=boost-d*reduction;b.rgb*=d;gl_FragColor=b;}",
    "box-blur-fs.glsl": "varying vec2 a;uniform sampler2D tInput;uniform vec2 delta;float i(vec3 b,float c){return fract(sin(dot(gl_FragCoord.xyz+c,b))*43758.5453+c);}void main(){vec4 b=vec4(0);float c,d;c=0.;d=i(vec3(12.9898,78.233,151.7182),0.);for(float e=-30.;e<=30.;e++){float f,g;f=(e+d-.5)/30.;g=1.-abs(f);vec4 h=texture2D(tInput,a+delta*f);h.rgb*=h.a;b+=h*g;c+=g;}gl_FragColor=b/c;gl_FragColor.rgb/=gl_FragColor.a+1e-5;}",
    "zoom-blur-fs.glsl": "uniform sampler2D tInput;uniform vec2 center;uniform vec2 resolution;uniform float strength;varying vec2 a;float j(vec3 b,float c){return fract(sin(dot(gl_FragCoord.xyz+c,b))*43758.5453+c);}void main(){vec4 b=vec4(0);float c,e;c=0.;vec2 d=center-a*resolution;e=j(vec3(12.9898,78.233,151.7182),0.);for(float f=0.;f<=40.;f++){float g,h;g=(f+e)/40.;h=4.*(g-g*g);vec4 i=texture2D(tInput,a+d*g*strength/resolution);i.rgb*=i.a;b+=i*h;c+=h;}gl_FragColor=b/c;gl_FragColor.rgb/=gl_FragColor.a+1e-5;}",
    "orto-vs.glsl": "varying vec2 a;void main(){a=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1);}",
    "copy-fs.glsl": "varying vec2 a;uniform sampler2D tInput;void main(){gl_FragColor=texture2D(tInput,a);}"
};

WAGNER.Pass.prototype.loadShader = function(id, c) {
    var self = this;
    self.shader = WAGNER.processShader(WAGNER.GLSLList["orto-vs.glsl"], WAGNER.GLSLList[id]);
    if (c) c.apply(self);
};

WAGNER.Pass.prototype.mapUniforms = function(uniforms) {
    var params = this.params;
    for (var j in uniforms) {
        if (!uniforms[j].default) {
            (function(id) {
                Object.defineProperty(params, id, {
                    get: function() {
                        return uniforms[id].value;
                    },
                    set: function(v) {
                        uniforms[id].value = v;
                    },
                    configurable: false
                });
            })(j);
        }
    }
};

WAGNER.Pass.prototype.run = function(c) {
    c.pass(this.shader);
};

WAGNER.Pass.prototype.isLoaded = function() {
    if (this.loaded === null) {
        if (this.shader instanceof THREE.ShaderMaterial) {
            this.loaded = true;
        }
    } else {
        return this.loaded;
    }
};

WAGNER.Pass.prototype.getOfflineTexture = function(w, h, useRGBA) {
    var rtTexture = new THREE.WebGLRenderTarget(w, h, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: useRGBA ? THREE.RGBAFormat : THREE.RGBFormat
    });
    return rtTexture;
};

WAGNER.CopyPass = function() {
    WAGNER.Pass.call(this);
    WAGNER.log("CopyPass constructor");
    this.loadShader("copy-fs.glsl");
};

WAGNER.CopyPass.prototype = Object.create(WAGNER.Pass.prototype);

WAGNER.GenericPass = function(fragmentShaderSource, c) {
    WAGNER.Pass.call(this);
    var self = this;
    WAGNER.loadShader(WAGNER.vertexShadersPath + "/orto-vs.glsl", function(vs) {
        WAGNER.loadShader(fragmentShaderSource, function(fs) {
            self.shader = WAGNER.processShader(vs, fs);
            if (c) c.apply(self);
        });
    });
};

WAGNER.GenericPass.prototype = Object.create(WAGNER.Pass.prototype);

window.WAGNER = WAGNER;

WAGNER.BlendPass = function() {
    WAGNER.Pass.call(this);
    WAGNER.log("BlendPass constructor");
    this.loadShader("blend-fs.glsl");
    this.params.mode = 1;
    this.params.opacity = 1;
    this.params.tInput2 = null;
    this.params.resolution2 = new THREE.Vector2();
    this.params.sizeMode = 1;
    this.params.aspectRatio = 1;
    this.params.aspectRatio2 = 1;
};

WAGNER.BlendMode = {
    Normal: 1,
    Dissolve: 2,
    Darken: 3,
    Multiply: 4,
    ColorBurn: 5,
    LinearBurn: 6,
    DarkerColor: 7,
    Lighten: 8,
    Screen: 9,
    ColorDodge: 10,
    LinearDodge: 11,
    LighterColor: 12,
    Overlay: 13,
    SoftLight: 14,
    HardLight: 15,
    VividLight: 16,
    LinearLight: 17,
    PinLight: 18,
    HardMix: 19,
    Difference: 20,
    Exclusion: 21,
    Substract: 22,
    Divide: 23
};

WAGNER.BlendPass.prototype = Object.create(WAGNER.Pass.prototype);

WAGNER.BlendPass.prototype.run = function(c) {
    this.shader.uniforms.mode.value = this.params.mode;
    this.shader.uniforms.opacity.value = this.params.opacity;
    this.shader.uniforms.tInput2.value = this.params.tInput2;
    this.shader.uniforms.sizeMode.value = this.params.sizeMode;
    this.shader.uniforms.aspectRatio.value = this.params.aspectRatio;
    this.shader.uniforms.aspectRatio2.value = this.params.aspectRatio2;
    c.pass(this.shader);
};

WAGNER.Pass.prototype.bindUniform = function(p, s, v, c) {
    Object.defineProperty(p, v, {
        get: function() {
            return s.uniforms[id].value;
        },
        set: c,
        configurable: false
    });
};

WAGNER.VignettePass = function() {
    WAGNER.Pass.call(this);
    WAGNER.log("Vignette Pass constructor");
    this.loadShader("vignette-fs.glsl");
    this.params.amount = 1;
    this.params.falloff = .1;
};

WAGNER.VignettePass.prototype = Object.create(WAGNER.Pass.prototype);

WAGNER.VignettePass.prototype.run = function(c) {
    this.shader.uniforms.amount.value = this.params.amount;
    this.shader.uniforms.falloff.value = this.params.falloff;
    c.pass(this.shader);
};

WAGNER.Vignette2Pass = function() {
    WAGNER.Pass.call(this);
    WAGNER.log("Vignette Pass constructor");
    this.loadShader("vignette2-fs.glsl");
    this.params.boost = 2;
    this.params.reduction = 2;
};

WAGNER.Vignette2Pass.prototype = Object.create(WAGNER.Pass.prototype);

WAGNER.Vignette2Pass.prototype.run = function(c) {
    this.shader.uniforms.boost.value = this.params.boost;
    this.shader.uniforms.reduction.value = this.params.reduction;
    c.pass(this.shader);
};

WAGNER.BoxBlurPass = function() {
    WAGNER.Pass.call(this);
    WAGNER.log("BoxBlurPass Pass constructor");
    this.loadShader("box-blur-fs.glsl");
    this.params.delta = new THREE.Vector2(0, 0);
};

WAGNER.BoxBlurPass.prototype = Object.create(WAGNER.Pass.prototype);

WAGNER.BoxBlurPass.prototype.run = function(c) {
    this.shader.uniforms.delta.value.copy(this.params.delta);
    c.pass(this.shader);
};

WAGNER.FullBoxBlurPass = function() {
    WAGNER.Pass.call(this);
    WAGNER.log("FullBoxBlurPass Pass constructor");
    this.boxPass = new WAGNER.BoxBlurPass();
    this.params.amount = 20;
};

WAGNER.FullBoxBlurPass.prototype = Object.create(WAGNER.Pass.prototype);

WAGNER.FullBoxBlurPass.prototype.isLoaded = function() {
    if (this.boxPass.isLoaded()) {
        this.loaded = true;
    }
    return WAGNER.Pass.prototype.isLoaded.call(this);
};

WAGNER.FullBoxBlurPass.prototype.run = function(c) {
    this.boxPass.params.delta.set(this.params.amount / c.width, 0);
    c.pass(this.boxPass);
    this.boxPass.params.delta.set(0, this.params.amount / c.height);
    c.pass(this.boxPass);
};

WAGNER.ZoomBlurPass = function() {
    WAGNER.Pass.call(this);
    WAGNER.log("ZoomBlurPass Pass constructor");
    this.loadShader("zoom-blur-fs.glsl");
    this.params.center = new THREE.Vector2(.5, .5);
    this.params.strength = 2;
};

WAGNER.ZoomBlurPass.prototype = Object.create(WAGNER.Pass.prototype);

WAGNER.ZoomBlurPass.prototype.run = function(c) {
    this.shader.uniforms.center.value.copy(this.params.center);
    this.shader.uniforms.strength.value = this.params.strength;
    c.pass(this.shader);
};

WAGNER.MultiPassBloomPass = function() {
    WAGNER.Pass.call(this);
    WAGNER.log("MultiPassBloomPass Pass constructor");
    this.composer = null;
    var s = .25;
    this.tmpTexture = this.getOfflineTexture(512, 512);
    this.blurPass = new WAGNER.FullBoxBlurPass();
    this.blendPass = new WAGNER.BlendPass();
    this.zoomBlur = new WAGNER.ZoomBlurPass();
    this.params.blurAmount = 20;
    this.params.applyZoomBlur = false;
    this.params.zoomBlurStrength = 2;
    this.params.useTexture = false;
    this.params.zoomBlurCenter = new THREE.Vector2(0, 0);
};

WAGNER.MultiPassBloomPass.prototype = Object.create(WAGNER.Pass.prototype);

WAGNER.MultiPassBloomPass.prototype.isLoaded = function() {
    if (this.blurPass.isLoaded() && this.blendPass.isLoaded() && this.zoomBlur.isLoaded()) {
        this.loaded = true;
    }
    return WAGNER.Pass.prototype.isLoaded.call(this);
};

WAGNER.MultiPassBloomPass.prototype.run = function(c) {
    if (!this.composer) {
        this.composer = new WAGNER.Composer(c.renderer, {
            useRGBA: true
        });
        this.composer.setSize(this.tmpTexture.width, this.tmpTexture.height);
    }
    this.composer.reset();
    if (this.params.useTexture === true) {
        this.composer.setSource(this.params.glowTexture);
    } else {
        this.composer.setSource(c.output);
    }
    this.blurPass.params.amount = this.params.blurAmount;
    this.composer.pass(this.blurPass);
    if (this.params.applyZoomBlur) {
        this.zoomBlur.params.center.set(.5 * this.composer.width, .5 * this.composer.height);
        this.zoomBlur.params.strength = this.params.zoomBlurStrength;
        this.composer.pass(this.zoomBlur);
    }
    if (this.params.useTexture === true) {
        this.blendPass.params.mode = WAGNER.BlendMode.Screen;
        this.blendPass.params.tInput = this.params.glowTexture;
        c.pass(this.blendPass);
    }
    this.blendPass.params.mode = WAGNER.BlendMode.Screen;
    this.blendPass.params.tInput2 = this.composer.output;
    c.pass(this.blendPass);
};

WAGNER.DirtPass = function() {
    this.dirtTexture = THREE.ImageUtils.loadTexture("data:image/jpeg;base64,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AAAAAENudENib29sAAAAAABMYmxzYm9vbAAAAAAATmd0dmJvb2wAAAAAAEVtbERib29sAAAAAABJbnRyYm9vbAAAAAAAQmNrZ09iamMAAAABAAAAAAAAUkdCQwAAAAMAAAAAUmQgIGRvdWJAb+AAAAAAAAAAAABHcm4gZG91YkBv4AAAAAAAAAAAAEJsICBkb3ViQG/gAAAAAAAAAAAAQnJkVFVudEYjUmx0AAAAAAAAAAAAAAAAQmxkIFVudEYjUmx0AAAAAAAAAAAAAAAAUnNsdFVudEYjUHhsQFIAAAAAAAAAAAAKdmVjdG9yRGF0YWJvb2wBAAAAAFBnUHNlbnVtAAAAAFBnUHMAAAAAUGdQQwAAAABMZWZ0VW50RiNSbHQAAAAAAAAAAAAAAABUb3AgVW50RiNSbHQAAAAAAAAAAAAAAABTY2wgVW50RiNQcmNAWQAAAAAAAAAAABBjcm9wV2hlblByaW50aW5nYm9vbAAAAAAOY3JvcFJlY3RCb3R0b21sb25nAAAAAAAAAAxjcm9wUmVjdExlZnRsb25nAAAAAAAAAA1jcm9wUmVjdFJpZ2h0bG9uZwAAAAAAAAALY3JvcFJlY3RUb3Bsb25nAAAAAAA4QklNA+0AAAAAABAASAAAAAEAAgBIAAAAAQACOEJJTQQmAAAAAAAOAAAAAAAAAAAAAD+AAAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNJxAAAAAAAAoAAQAAAAAAAAACOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAAM/AAAABgAAAAAAAAAAAAACAAAABAAAAAAFAGQAaQByAHQAOAAA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/9k4QklNBCEAAAAAAFMAAAABAQAAAA8AQQBkAG8AYgBlACAAUABoAG8AdABvAHMAaABvAHAAAAASAEEAZABvAGIAZQAgAFAAaABvAHQAbwBzAGgAbwBwACAAQwBDAAAAAQA4QklNBAYAAAAAAAcACAEBAAEBAP/hDfNodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9IjBCM0IwMDc0OUQ2MkU0MjQ0MTRCNDVBMThBNDgxMkI5IiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmQzYWIwZGJiLTY2Y2UtNDEyZi04ZTI1LTE5NmEzNmRiMWE5YSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSIwQjNCMDA3NDlENjJFNDI0NDE0QjQ1QTE4QTQ4MTJCOSIgZGM6Zm9ybWF0PSJpbWFnZS9qcGVnIiBwaG90b3Nob3A6TGVnYWN5SVBUQ0RpZ2VzdD0iNTA5RTk1NzlCMUZCNEVBRjc5QTdBRTM3QUIzNTcwNjciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHhtcDpDcmVhdGVEYXRlPSIyMDEyLTExLTI2VDE4OjQzOjMzKzAxOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxNS0wNi0wOVQxNjozOTo0OSswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxNS0wNi0wOVQxNjozOTo0OSswMTowMCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgKE1hY2ludG9zaCkiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo4NUE5RDYyRUY2MzdFMjExQTQzQUEwQjQzNkMwMDE4RiIgc3RFdnQ6d2hlbj0iMjAxMi0xMS0yNlQxOToyMjowNiswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpkM2FiMGRiYi02NmNlLTQxMmYtOGUyNS0xOTZhMzZkYjFhOWEiIHN0RXZ0OndoZW49IjIwMTUtMDYtMDlUMTY6Mzk6NDkrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0idyI/Pv/uACFBZG9iZQBkQAAAAAEDABADAgMGAAAAAAAAAAAAAAAA/9sAhAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgIDAwMDAwMDAwMDAQEBAQEBAQEBAQECAgECAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwP/wgARCAIABAADAREAAhEBAxEB/8QA/AAAAgICAwEBAQAAAAAAAAAABAUDBgIHAAEICQoLAQADAQEBAQEBAAAAAAAAAAAAAQIDBAUGBwgQAAIBBAEDAwMEAgIDAQACAwECAwARBAUSIRMGEDEHICIUQTIjCDAVQglAMyQWQzQlNRgRAAEDAwIEBAMGAgYIBAQCCwERAgMAIQQxEkFRIhNhIxQFcYEykaFCMyQGsVLB0WJDNBUQ8OFyglNEByDxYyUwklQWQKKywnODZAjS4nQ1RRIAAgIBAgQCBwcCBwACAAYDAAERAiExEhBBIgNRYSDwcYEyEwQwkaGxwUIj0eFA8VJiMxQFckOCorJTJDRQkgb/2gAMAwEBAhEDEQAAAPg59H81vrbmedCZ1Or5219zUxkYuUPX0fPPi9vUnBtvifN++Xr/AB/t/wBfh9T9/Bcrh9ErnrjGv5/vN+m/Oz4H2Wv8N4QXpVvFUzklXm4QGCNElHUlj6AISzFkUi2bO2hJ1bdYywssOg6Ztiuf05fn7N35ihWWcrLSyt1x3pxddJ5aHRg6zZMpSXqqigrEuVYpOGrU4u7xOt4M6ygDq2Tc6rxpkhErqEbJnSGHYNSpYBeogjS365op0WwyCSRQVUcySKC9MonjshnKmvxVeHhJtrbG1aphLaPJsZZtOoXrdeV6Z7ONlU3PTIsKdO1H5tE+dOdY6RWt9vl7zfQaG5Oinqq7iVrnSDFiMikws7k4h9onWgys/okfcfnPl7orzvz6VDkrvS/AnP60PPDJpi1576fS8IeH6lYxe61xfezb4r7LfR+E8vr8MLr+f3J6nye8z6PxHy+qKVg0sTXSJYaDngeQaQzs0Q8kiZoSRlshIDLfSVq2YCLXuF07DSs1TsMw9pbeTY95hzDmrOY7F0yz6LqWDRF6LXbVuah4c2iFkjml1OvVaKdCc52pvg7zztW+TeZF3oLK6jlpPSe5YMfV31L511Ra06egRtXlKY0TqnKjf+vBobT0BudR3UGcgusEdu83K5MzS4ksADl1wciNjPK9dMmCnzztV5ZBsKMPce/k3rWLdrzv7Vk6Xn7vRoT5Wg+VOLzbTF01jyT2ev8AKXxPdps6okUfF0zlkfJxtwSsqGOisVjqxp0P+sjl8cbnflv6nzvmf7vm67yv5mV9F5m8DTiDySta8aR6+mPI6d7+xz62897D5+UC3p+O7VsbV56AFMkuMHEIAMtSmrmV2R9YPa8T5O+d7tY86E8PgTWpQkY/2ZlG4uzOOLbqdjmPuLo8a49WYmT7pxUnWUbJeAXTpWM6W5VUdtdJcnWDCzZBDFddOay9apnpYqjYNYXfTPYOuI4ZyV3akGOkgg8rz0kWaoU61wtOtq7FrXaHFcDGn0FtvN90GtsNkubYKJkLKsVudVCRxtOqDFzarsZuqCpl5Y3WT4x9XR5fof0Oez4xdOjmJ6tPv35vh/V/5j7f8jH7f5/m/wDO+Voszrm21Gh9u743eR9RUsXTDQJOkYNLhMACBKGAPdHcevV+Zf1tvnPLTdPKg7eTyH9n43y79Xi8Lr2vnl8/3gOpMzYOmVK6uryL4fY3opEthmpdHVZ0qOe9MVKYcoGEZ1YsqanTVooQGiEawuu8uarNCh0gimx1Gtu16lwtNXFqiPVd+T7F9LgpWNiOgwllW5xbuqapzuNtdFdC0c+6mc99yL5YEnQ0Wl1hW2mdjLn2v1851M9zOCmmrqssgehWtRnVL56TlV16Duka0qWWqXJCAej1R2+fcN40pr3aM8jVvb6UgDXSxdLKyQezEmnW0bD0xh7Ni8MmakvRJc9csF7Nz8Tenfha1m2FsD0Y+gunhfVrk1+L/wBt6ei/k5R4i3nghmr9+r43eL9PXvX69Y+AgB8CpQ0HMk0rtE4HbO4dA/Z/WM8n58dwNrmo6MPnR+hfO/DO/e8TeD2M1FwuLKLPSPAfmeyq5VDCPoUNoy1JVLNqTz7xUZSESptWCimzaMtWgC6XUVnlSnnmADdGfoEBZ9C6aogm0TDhT7Vfi+hO7lXXYEoCagbbuZgVSz7SwEUUsvXT3F1LCg4IKS5NMtlujLhbJOfYe3NYNiahy8iQALDbUQwbpJlrUs6UzasrJSq201jh2LcJhsjg3vrx7J7c9RnTrPg3I0O2uy0DQ2bWJ8otvQhxzomqbhpnG6lcNrzImtx8Xn747eW0RGzNs9u93Ps/08zVJ3JlY6z7t6i5uus8q0pr3/J75/3e/V31J5mqzIKUh3WscbTQwYRCD9nZ9C1k/wBZr5zzE/VzYlLt+HRn03nfnJ+nyunPzvNosRnx1qs6vmf5ftefPO3r/PZrWCkV2DFhpQ9GjDaBAAV1U21bydNE53Xnqozr0Brw+c+70tbeNKmJ6SYbUc1uvoxDWjCYmYwibLeftBePvP0cA5Mm3m0yhECXO1GYFACNSUpL1Hh1Jc2GVaqy1gdXJSFUxZeFjtPTks+0MrTKpNalJSvZKqTSQGtHx0r0sQppotZnShx2VZHTA5Gdo3SX7zrb6CpzIuYFqrdJ5IIb7SINKBHBJiVsHXmgvSZzYtIyJs1z6MjzdjVhtDSb7XNYN5Z2WHTKy5zeujN6sdZT1fPrD3Pl7837QUtTCxbJSSXpqLLUcWAZSEWWm1Y9T+tb8jxIOnmr/dw8K1H7vnfGf7fwaXyNu11RzJ6qOnz35PVpfs7vDXj+gpwRaTnolXg9ydeFb22TIDqj5gpqtPbzhn6Pmby+uvZNMqRjVS1EKdDy0zp3F52TSepN6Vxa06e2fmz9Z5eV6K9bkJzi1dClul8oeWJTW5lbhoVoAqoeW+tuXVG6FWg6cLcKFYEisTjYM4bE6sLTcEapVFvKhIWmlqIfTuoLVFjQokD1RFKqFfPrC2VR0adiaXktVNrjg5kbH6cNXnVTOB2rpaaqBVIpILq9Rhbe+T8ZtHRC7XQTmy9JPh2Tvjac8rTcTt7I0y2htz7J0wtOmZ7h2L5Bc31Hiv57r03l2VSKNlcAC701G80yQwls5qyuXKn+rj4XlJurnC1xzm/Ff6D8p86e2QMVtNYO99a3R5Oy7NOcG67CvHR6mhPJ1HG2ym6dubWpW3rqiNWe1oyMhmsXGnjbn9bSvl7JIasaGBZNnU+3k9ZeyLd0zzNZ0GzmzqfQ2Xm+2PT89rqLqtahMAudYJQ5uxayfbYxl5zffo3k6q9z2GnCmEUpQGxohmF1MLfeF63iVoGg2kpmq/FrM9DGkc1PSq70TKuk0lNXk+F4UhYtnWbLRRtNqlZlow1LheNAfRqrk6LBtFcnRNLcaoq0woshnfFy7/8ARyO6H5v4+q+4c3onv5EnKZCt847h1z2108910wbWOiNH5dXi7z/T0Z5/Rqs6taY9NWzGTVZetJmw5HFjAVhUnkN1P9TDh8DFpXvlrn1eHwz938/5X4On11wcXpPk3xvq0B7nLovprVme2p+ffzVydya/T+d3m72rzuZhtOdOrOtVz0ARWDplrGA5zPWN+h5E87vqPFS9tMPpLoZTTypsaiyXPSc0hjz2dtzbNx5Pbvo+fN0ONsRMQKNF1LPS/Y4WvpQ9uv5vUOXTXjTUvF0BwwXSl0ukfaKuRUiduWdpvJ3cH2SEl0lVaocC2ZY7f9qfMnmdEE0MMSqWzWDFGVZ2HUiWo2EgKNWwSbiHFVV1aqJHuohKGlcGXoN6he9LThhv30ORrsagz63qyEhvsMLlU7z14No6ZbC2ztVybWXnjLs17yao4rQ/L2CwqDXVqLHqkyzp+myOWMU1JtaztaidhLP6dc/LaQ+j8iq9vBffL9DS30PDY/OvdHi+iBZrP2/P8K+1OqubRbEySqgtbXz9nw58X2SokhrOygF6/jrXLAGew3eIXcgB0eWMPR1X5+mMpOWPI51XBZynihnZ1kmVK4PnvumV4jn3J0c2x9smGoqhpBqFVOnXZBizqWUlCq6ZnsoWmneXe6mdEregY6RhKnxrpjgVgmLHebPRBswARE6YwoZYjrNjaUBs67hd26c9Zc2zl5h3pIErmJkSBXVeLWZ7DXUmWW1fYereCkiqIa2aiGJoHMaTFwvNv0obMwK6o1rjrfeHm9J9Pn+hezk2LeVI030jj017n0sFZHWaZ4t55ZxGo67NM8/TR1UQNgsTmxrN7QxmWHTj/V3/ADr09V+95Ou/a8rUHveDqz2/PvPl727h6Tc7tHH3fOz9A8nyDyYptWBkxw8hT6/jz53qzyG/RNc0rVmfRSOfcfZxzeWsivRajqjXl9Pnby+wCQKSakVcqponOWqV16prvPV60xv65tpdeNY5XbdYfxltjqxJ0VHzsKarGd7N0wCGNLSOw5qhPXUnD1nznUb2yAGXI0CBCbelYpzd3mRYQIpEabOs1xpHmlia+mreq4cYQgeBCnOwOaMqBCgKcwuh4w6jv0bK4uH1h9FzeC/K9dbJ1s6nnpMgmpYpNqTjTMtjAyz00VVWleDoj5ltS8L5pz8YfQYx5OV71xlq9T8XQymHbjVunT4x5e9NDsNty4sYrOZPrR0wf05f1iPzP13fN1pevD58frf5tq/2/Fuvk7yO3GFXvyvRrnZXyN+28rUfnpXOmSXmI9Dy14Xb3KXW6Jnrps6a9OrHLOH2OgXzYjbWaX3aop0ec/M6xXQQZE4j6kzaAzD4WwOnLY8cktAau7LEzRpqHURaqwsNi6mgyrai5qBtsdISyvxen8u0XBJna0B2o05WYoPtEy3Zm0c5zNprMCtIIDLM5CGTKUGjp0bqh4SNXODcoTiCohdRMkaMS4CF61A6FUHQXHXGTQxdUedjFL0i1bZ4lXbfKtZvNrsoa9NV8GoUO6uHdZCy5VF+6Ye1F7yxTqkfJRVzCPVS6/FfP1iDtFDyk9Cwzi4tFpu9MP6yf5r7a/fCqehw609rzfHv6B8Q85JjdW3i6CE3vH1eYvqub5vdHLUsbW6aeO+D0NRcfSBma9x01G+nW+fQgNcc4db3hCgt9BlRpeurU/m7z9DrmDDA9gymN0gypoZ7WeGzr5+WRSWpZN7aUcSXVVDnMwCKtlb4a5z2sM5xKkUUtRjVglDNqh4ogAwcgsmM5kyiyLJixTLa65psLcaGRM6a6yp53WTbuh0pBtjo6RxklqNsxrFMlzX3pWs9ursQghs1zhdV2Lt2mJqmxaYstH+gqPhfkT9d915Y+WvCGj01ovBZsK2vFntXUwe5suedq0htnFSWh2KxmuVOta6PC/J3cbd2WS08BmS0nJoyxPP+sX+ed+uvd8xR0cexPH9ny9918jrf1vEGpQ1BGbsPL2crT5E/X+brriKOujx9wd+n+Tp1HjtrqNtaY9FYnQdjpvujLd4ZA7WOteccO+q4WPKEpiZ13cwKl+bXgwU7urk2GYsrzzBuo2N3rW3PopzfCcoqNhyVfWrOM87UUkoDlcENVdoBbSLSZotEqk+owVmEWhRtfXk13p01Lm0gCVhDUshmqUZujPcELcoSO1w5aTkm0Xmlq65F7PrnD69Na82tanevxUoKZNn64MelVit8OeXmystc5u9WXLKjXstxBK1pq1V8pszsj2N9Dw+jvUwT6VQ8dtKeA8PEip85Xpu2zk6URaGhzs8CeZ3l6t1q7PoNUihTt2GcrVcf1oPzj0a/38yDs4n/AB9WuvZ87yd938ORGdy4O6x8nawy2kivlh+jeD4c4Tyzzd+lOLp0fl1aT5ujXcb0jPRVpbNFkMmoKqcUonR07To0pz9SdWPbDYBzrtAQ10uZpk1udcew6xa6LLOWpG2unGixtWJtbATJxjlqvTeSnMIkDBkGQThixUtAavJLjJyT1BSHVIilbIwr+uyXKoEwgnCcTPRKIqjPYGwmABOAO2bFrGw6QA3qldN6jBn0vUmG9NnfGQXRg5J6p2B05g6PCnaKwabu03MaddhgzVevbUXDttCub6M/V+bsbox9Jb8t86MjaWXXfiTm9bzP8PVc8bGwRk2tVQ1+dOXs+cOHVtQ93dk1qxVMoNSLATbDL+sN8P0McOhnjvEZKuuPN32Xx80x26r3Tyh3LGNPlP8AoPg+M/P38e+f6Xn7Hs89c/VonDs1pGopUKJQc1J5OIy1Ew9SX2osrQFfrY9X8w/L17P6r5++OzilkpCsjkyFt05PQmvKRSGljAwUtnMDtdLIYasl7tDNYIhVSVOMshqQO0d0M2ls0LVLoo9xkSUm8qBSukRJ9MY6QhjSKZLCcG+06jz6K/Ore8xxxyRtuyLleKStNfRr0aClAw0I4WLUykLhnWtrdWMLdr0xa6LgNdiuzpzLPU2fbWeN+/PofJ3t6+OOum3p5PYHb590vNLpTDNeSe71/HPwGp2GSDt6fnF8z6HjbzOkeBxsnug86HbtByywqXBnYEv61P573uufqgvNLvgr6eep9/mPubuSdPNpD6X56ger5mpPVx+M3WtRcHTorLo0TPd5y4+rSs9mlcuyCpYvKCejpJo44wOWrhor3CECq9OHk+ONPZC5EY1uDp59ZV0UbjcrL7OHqfTgtJny30mVczZ5ktry8oh1rGqc+zEM1A6q1a5o1pLnLmyCTCjBFn2hTFV/KzXMTJUEsKZBBwcTTlRW60xlFURS7BpGnH0qMr7cy2sUP1Kp1CnxrDZAGgGO0MND0g+YpmpJQNMVOeHf+nO464WDTLPoqwxNcetPx11rhtuDXm9zfS+Za+oAre03z7Ay5/TvRxeiOnlg2qbReQa9jQXhX4J6Pe+a359pLjGj/Js1h7LX0l86i5stBm/csRf1tvzP1+wVbY91nq/3fFV6+e65+4XVa59ryvPX1HzngT3j5ueJ2g766W5NPP3P2ee57dJc3VpY7a9Nx867sHvQRSvip5nrZ9DiAEFUX2JWnGj0Cedpzr7qHxadiIZtieb1h0+fYKy6VSSyIxJ1fconNE9d+dOTvkIMHKR2NoR2NmlNaxTl0IYSqKyZMlmwVU4JZ1A80VUqFcAYSxLRcmwt8PTHZy+Hj19TebS5W/rLtOAcLCwXgRRCqTTYc0jbkprQxb2yuNV63Xq3ybe7TYKLDeWbnO2kz1US67Gnrft8r1b9Byn9Ire1eWk+haJjY+/Pslc9y3z09t2/NPn+g8/+Pfiz4cq/mxwOAcFu6VsTsezGriYOUDbH9aL827nPP1Vbv4BNM6528SLq5JIF3RhWPR5fPX1HlfD/ANfl0N5fTQctNPx1aX5+rVem+iMu7T2HVrddCTGghDFRMKYzqS92vxzhVzWZyDtgQKJadNRJKAgMWrcZ22p9YPyfSPbyUeejKJGyKfWut8uipVvJMvHMqTInNS0c5jZsiRJQTOeGmieSGBgyIJWuSyXJKrgoSc0NtZq2erVZ716eO1bT4vj1qxzVXnUcvpPAfVSxEGrwc92go0TZ6AB1T7AkmXpKjjoc0fRZLJNBoYgrVKnmhPNe7PV8bdvrYn9VonoLWy/SpLfV1AkFvaE18BcPp+OPzLlScwLBwOBIF22WyO6toPK7PM22rzP6yHxFvOPq7oA0ka8F/Tgg6+Vdtgi68PCn3/y3xa010T5u+r8dtO49WrToUev16Dz7POPh9NQrSv8AO1boUJ7M5CGptiSWLmWGo4V1QNBWIdckTpyShaZqGVJmG4ny7v25B5YMVV1qkLnalG1edhJMHIQ9M8kFsc0sw5JnWYU6DCxTlCelFNABOEwiBTOYy+3IzAJo0mjabV/PSFk6FwLVt0AqJWmDnJkDXVQBO1eysezOBZQVpSltnKk2GiD6UyFYw2Lxzw/ot6nhbX9rObfWrPeNA/RpPpSnRiXeNVy68L8/q/Pr8k5FXOcDgcDJlgtbT9Or91jjjzdqY6P63nwN1b0eOo93mWri7rf5npj6RT/R4KL63k6H+m+d8tfReF8zsvd84+X06Cy6/N3J3J2/pf8AonH8qo+p8dfnc193TI1p2Vox8t5UmynZHfNA57A52ak2JjdAJKB07Bq0xUph5sOBg1ZnAzqzLM8mcMwsAGvNzWb8T8l/rAmSu2udfxt3csDNbVzKYI1HuB5sqZkIhNcHMCoYMAMFKUzMFda0qdIC4GJipwlJTlZ2KM9O04GjKzhmpnMLoF6JM6XoCbiFFWg1DhQXsx2FJl0LZcloSKiR7r9Lxt5+xg73dPe3emkWt9aBXRVeehILqvxrPqfOb8j51PKsgwDgcA5n0I/RHvT7no8V/l+Y3j4kN/1cvN+Sq3bw8qbXwd7rl6ekJOzHWXs+NXOvk87/AEPl/NTD1tBcXR57x7PGfH6Jea95/UcHl2/T1F89KYqpG2mb7fPMd+mOHRZkuNlUntoTNmgRKzFmJhqtQ8+i9EUuZk4GsHQfSNY8SavN2pPBmDF5vazfkv3G0r5KkuiDMJY4qOwkJwdzzmOtYt5mwmYlerjLDbgRwUw5HPaqIEY8W1zoVVgwmYrr1BDGkDOmAynMU1m4jdAu6tnSoqZJc6CKzbsFxLoRZmGlZMXSQMGHUsn7Z6vL9bfRckmtC6Vhppj1bQjw1FkVJ1UKX42y9H54fkXOrxMgxDgcAuj9Jf6z4nqH7I/PR8f9Toz8y4X+r/qY+l+ZZA35dLbx9xC1yVTIT750P0fL0D9B5/ywy7dFcO3lePS1zy67y35a1vv5mw7NbZbFWHznD7XZRuF+Jeb1vPnlWVbxbZoOcE0PiKRlqphRAtgHRIOSiITFkgEsaMYg6UNnLNS7A9y3rGcLIKxGc6k0UtBopJRlLiiV0Q0NLY7JqRSsNJFY7IhjBmEoox9NrkQtLFcJWDIgCKTjhCOwXO5agWnhOkTsbOauqHYIWmemIhxkqHlrphOq6K7pQxVYq6jzLfu3L7++h8w7s0ho60vvfSDoriY8knRqM68B8Po+HPyrmEk4HA4HA7D6m/YcXrf9F2+NP536FM+W5XGz/rCeh+dMsdGeO/HDzn7SJ0D0zHpaa97xPHXv8ny35PR0F53RQ89t7dPJUa6PLeXfrLnuj1uC9AnSrbVHImrXwrw+nRfPkV281DVMUlcyMWJsSOjuDCUfvUwcY1SjHky/VC8bohqotNwNFsWNXi1qWiLEspSWgFNGCkanVHrItzMyGBvu6xiDusVrwjEeA4giF2qjaDAUInpGICrFkFYmVYMxAKqimsSQI0IuEca1ySamLrbHPOt6bJMwhDe5aWiKMG+pCtnW7vW/As5X0S9ny7/6hceiBtK5rR+tIXpPrUd3D1P5FfDejpX43m4GbMEcDgcA6y8+m6n5iOFLR/Xg6fjLNw9cqvlAVZg9ExJTq/F/3HzPzJ6H4Z4fS1vw6vNI2HWOoNe3zryddVh0hap6oHbav1qvzDqXnqvQ8deJ0hyjhH0+MqXOh8iFKUeOgRIx1ZLJ2iRjAyFsKs68aMVFhIut5rlTBB6zNqXjR5LhZmBYXnIIxhcww3Q2GcNWtnWA0MMYC+x9jgGQZjGnCRx9CwKDGO0yIrmm4Gb7Be2tTYOUL0VReYAJ9FV9C+6FzEl2ZMgOg3QgGtWBSdqdULxuaVQq9b8QlzN4bYe6/d4NnejnDtqx1lhvdaehltT07+Xsuz5sflEKOdcDgcDgTAfQ5pE0NKA0DB/WU9n8u398x9fYeX0Jo0r3ZyjaZB65a89Xg+P33vg+KvL6fKnN3av4NvVPVwR9Wmt8t9EZdlBh1l6VE2LaXet2VLyZS019a/PPzPT1j5knaD2y0dBr3jAMQiwpkIZARbeWoJfAKpEA7ZkDkhkJopctODPIbB5PmNFnZyMmNWjAMINnOSmGbQxiO3iWWZDm/SiMXbZBObMx19aWR5IjXEFiBy1oYlZMrdU2UPtjWufQqzclIGaUK6+kONc6Ceh6hc7CCECgckOdgJtenlKrdVROZq5SPlXoDpw9rfT4NtnsH0Mm9Ka2f01p++35Q/nu+u/CjgcDgcA5jmhnqjQlCWiOQeq/pd/cfivsDwfa9I/IfZ7F8f21+2NL9Pz9IfTeB5G+v8j48nRojzunyBj6lW8ePoj6ni2f0KoGW+psdqGt7V6j818PVv3z/M039d7nmz5nRVTkT+fPD6um/LBYGFhdHYMETW2WiVZPoQqcoWdpMMpo9ljJHGYS7Ut6k+R7UYzTi8LAJmQySakshSAyMZKWbcEYhm5ZMjeVsSJDW2I5jPAqMYw+DMJXldiwAQa0FL26AYDqimrdZGpBE/RNN59Vw1RUQI3faeLQg+BEEoP6XdkTIZIKE0OnZFN5RHgupez+iPen0vHu/wBbOxby83XnbT0vml8NvrHwY4HA4HAmB5Q02XQEgeEooB5B/Qw/Rfynd+XF6j8rq2l4vszvWu9nOfk/lz9hz/Nzyun5/cfsaF5OnYPJzfTz1vD2B35a3XVrXPdDFUldGrnvrCuncF8vnr1vW1T4IKP5y+Z6ml/FVh6B1oHUCS2NO9mVf0uHMnZChagsM2yBNmMlODCSXoNlLIRIFuLNWVmINMyBt0GVBDDo52dIYeMyCawGnSRTS81HEOOcMAyFwOB2BQBhGAgKnQruFCJ2GharWrTFT1VVuatvTnW5ujY6ggCV2EjBUHBGxs1AxYnnQQCFuh8irWCDyJrAMnEGyeud6+rkm6NvNXz1p+acA4HA4GbLJos0YAXoZSNqIg7Dgf0Vf0P8k3Frnt/hvaHkdez/ACPZGspXbPwy+h83xZw+j8zfP9xfkbEyw+q/p/PbM9ko2DoR1VzLStmmrMd9c671ab1K+ypY3qhdPgDxO2k8KvPUQgWxZnRtzbdRfkcY+EsbiR0nueuSlvohSOUsRdpEujVLNrMGrzt957MfPVZ06VXMw5TmjOdhJrGufoBToieciWBcJQoQDcGa1XmzIQ4xisyV5ZDnBLEaV3mlW9dUeVBTsO0lGvQKwcoNCR2A6WySIzZMzFnQNWLKYkJciQFqK/kVrBL8HgiJEQcZ3RgjNGSBQzZgjgOaHOq4xdzufUKtFBiHYZB+5v7T8y+oseX6U4PR2Z5Pr2Pk7Neelx/KT6jxvltw+p8teH39Zc27xxeJ5/qv1/P+gPo8df5bqsbqFWknTXsb6yz30lp1a8x1r86+EOT1dAeFNKzu17thocGBCuNR7C9jj8eeV38RKw8CWSCnR2SzUGCbgQDMMQjBi4bEOLhiplG6UbNfMJeguayJ6KiJLKwIxCM06JBNMQ4GQRjLJEGMAgQh2PgQlCAtegjEia9UMtBxp00wD0wkAF4DROkktgLpmAFsjDBk8vto5gTEklbzK3zpNzuGSGjmqxDvF9sgQY102PmZBED7RMtAWCFC6WZIZsjqIg6D7y9vyX2J9nwPTGeFm4fR8p+hXzpz7fA3L7On8OrY/wBTqP8AM8t20yaVl6qx8z6SfReQZ2UsNUeBV63pca6ty31MunXem2ocuz5NfP8Aran8ZG6qx9DlDsRujaU8WPKXSD2PGuINEyIT3o7zxnGycukSNyBGiQTFzJWbslwK0LM8lqSSsCb1XS+FnrnHuxp04SaQoNhgdVEYxZY44BjoJuQpcQxygnqEQINYUpAZaDpr1a0FodgpdKilbsFAaFss2kUyAGLMwNAdDDVL2xgBgq2ZS+MDzQkOMOB0HA6ZHBEEgdBwHdDvZKcweGoAxh0hmyCzY8g7LTquhc0oXMlZdug9h7ef6t/QNNT/AAnK9aS018P1lHj/AFG+i8e+dUCXSnBU46tXPp0/l0afOj5wcvu/P35TcGVa9haPCVet0omnGxO3xB9DUVvcBlMzOMrEk9KyuJBmuJjTiC3GKc7zmcvBWpZejerj1vl0wZs458S4lnMSuN+i8lHToBPBu0mG1NsKpW1Ex3SS2Ahm1SeIoihxiDXtry1ICDgW0JK8tJIAAgBPQF2ACdASFqeSCGiG52pwLHbujGrPUaBfN9KUEJZJWeNJ8XHJjajGQgcIUZsjRGjgNgbbJFk8AGDgTomHwUzFKOBwOBwOA1ZuT0TfWmOx752u+YcUJZBib7z4Ppv3+B6u9nnz2up5a6ZfR4e5PX+cnmet5B8roruAInDIRa9id/F5529FN58NtwmSSiduw2i2PlLtwQmpA1Q9A9zMqLqe5c1TNUZTTd5vSdh6c/oCuHSz7sMEcZdShy8mAmsYdpCug0Sssqx2xrzVy9dZZ9MEGRUIZuVicZQJWbgJaRMmoqpSqNUqsNNSEAw6StaQjTlZNIJaSWCBYGUoAITues56A0i0LfvK3N0/O1wq5hVc5IKp1/JdS5IOqOmMLarFBhwGbCQWowoz1QuD4BgH2NdFT8HwOBwOBwMg2H0m6+ydx3gVcSuC9CKUTSMxN95cHozu5dXdnZ5x6PS8r+T16n4aqXJI4Lc3LSt2r+nvoeJ8u8/dA4IabNhRlQW23pFhsXpgXnTZRnqxskxDfPZy6m5+meFMLJz2BJNgcPhsDNoobtFDMeUUgpWAdBkASsRkYdhKN2ZJ3Yc1AyYUoTUbZ35qpt0UfgZALaa2atlY0yuhZNVOdFFaV3NqnXakF2ENOXECGWuRiztHbIEWWlauhRo7ljaIJPJmUpRdxKde8BEirchAKTUw533Qw2QGDERKB7JGLkcR1uhcHkxmh1smtGu+d8DgcAlhQiW3+q273G9TBx1Z4pTqJWDVXZSvLaCEN6uo+prbPbUfgQmxngYhChxvRdJbku0+kme9diKpumOrW0a56jnoWxioZNNm/oz2eB4Ew9vqJ7T7SjcsGWVKz1jwDYRTCGm8c5tKJdagnEkYvAMAgDIIgMSXOuCKAQCR7kOD2x7fk0avQ8G+V6oHPABWLYYBLQehZpdDw6F1CeDBtGVCNO7BBehRD6ZEgulkFxstuymYBZkgS2ozMxKjZFlC5Xr7zsVXO+6GFJroE6Ox6CnMUYodh4Tgvgq2TGDgNKGNB1p7s9W8RwMgs2ptLsH+tnKAErbU7AcW7XmGu+oza0QUDGuBFYy6K716LOi6Hz1rrxc49XFmuZAoS2MtG31YsIRnaJUH23rTGh007WcojUi2HoJBvWTpw6oqMU1cummThrMPmo23E5P9UjzDpxjdQK15YhYwQhOEgQjaVmgm8QJDsJB3pc3t30PN1/09PmPg64YuqZ0jliugHp7k6/Icd1fPLm9rUvmaq0CttQVMpZqAnENUjJpbDkpThtjWNgdec7fKB0h7uISBaK06vg1Y9ReXKrmTDQJZYel23dnSlyEWTrHNIEmKC2LoaOSIHTDtFOgFFbzeYWHQ2x6Da2PSWI36ydkbJvFLrUtSwJlGOLEBlrWltTI0rmjqODreLjSxpKMUFmYIYaNxuZhmPtImnGg5mxHk3cYJtRN2nLkx5xjZC6SgZ03NJcqzMJscxPZkkUpKSM1kiI7p9MQxotnWEXQZhGGICBIEYZDnC2HPe9Iut4taMwxYk0vSePVQsNchfRfu8bDpr51R72ifK6A5ELLHTTjp60VprEQgBLHYIkwZvHbHfnp8sOtLY0gF07HFkUqda1jWv5VpTy1V+FB5jbVbC9LS6dMi8qxVLJSfMqnKoxNNm2oDzKdzorQFgR5PMIwfal+7B7oNmOGrEpNURA9C01kjWjfXBo5A06OpkLLRRYDgVl7V1lbKXrSNZV/FK8VAjEIUWrpbJnLc6UzLLQUI8CCLCouVZtbzYhkjFoSWwpdtD5npzr49YYdHbl4BoijMsZFxITOOJFFx6BURBOEgDgKA5WJPYThZCNpVys7TfSTAzCcI2d6GhZ7dU8vTeTkN6dPP2Hagz0VS1lAxSlNSUM2qQpQNLgFC2ULet5es/Y89nqxm+mJzXISZ6dJ1Ba6wnbzv4r1t5UQw3HQrj0vO6ZhIiVp0xPJKizWn6zIp6N57reChkHRxg6NhdtEosuqbNulk3vSJZYlPYzf2TiUJsLANA7N4TISfJK/WlWVq2JBrp0S4ZgTKuCx9LX5g2KbdDeaNpSeE2sgZ1CBSVvMnWmbRwamWkE3EiArJS/FfTn70bRpvUzOWZEFo6R2Tno02VUrHZDFzh2LgBBmAoZFYibk7Rrjf7PNJpQwc5pZsJR3SXXXl7L0NYxsDmxY0XFQW1mbV7aRY5xa3Xs6QFLkwRAS21gMmyax92d/l7n9aF1UMNG9BRpG8KY8vyXx+j5j8B1HikWQqh9obx9ONYcux43NqzEW6oeme0dMLu87JrHlye/zR521cyCreEibJW/sowLXoOFLElo5zRm1nI90La+dEbIIpiKW3IELMmI8SrGikpOC4aSdVWGSWJP0fUjncLo5NWCp27WB1kbfWZK5YCMcwKTBztQyS0p0pB2UyulZ23bLJ3xQy0zkls6RcjPSTUtd57VPm0RquhnC6DsfBBhADMXqPo4LH0RrqejHCWVoxTmGQFUomJ4qhb9Pm/k7K2rGEFntKxKWCOmqsC16WLK+2kzcoBASJtqemFx/Rj2fE2Z6Ymu10tRdZy6frv4a830vIfgdAKKZ50xhgh3RZetur2trxsSj03t5/rHq87bvRz22MuFOaz83ad3lDm9Px9w+jQ8KNZRsFct2zp2Am0mUkyWGQShgDILj15LwrHNqfo8YkerXyppSrpsaXEFRxtemkGkzBUTEhg1tvKdhqNmGG9tuPLalmSq63EmcwVzXWdEUs2ZLPGkcnmxpM24i/9HM32cymbVG8yO3Rjl1Mg1WnOLqiyisGsgFDFF0E4EjNI2uuT0B28klvV66F3MMdFKzJkqOhcQnqq/tt5q5Oykz0CQw7cKIc7SW6nm4G1b0gSUthohQtTnA9z0626+b1z0+d6a9Ll3Z24NNzy3PofNvx/X8weLqt54e9VKOSRpO2WDZ37pewtI2cuf03t5v0e6fE3B2YX31Xsj39fN3gPVHh1WVevb6PMD9HwZ5fr0XGkklqafEMRGqWQnVqTelvMYIahzdpM0DA2sy3da5XmTC7wAyYXdNocLStqgDKwShkNp4BYzP1D0ce69eLaOnMMnM0PNV6r17n06+ytZNKFeCXKB8dLVritGyhFItbx2/18rXYkQc0yEyrMXN6/jfVXF0dkwlYg+eQj1QSdhwroLTOPqfo8+fYoy1Mk7EY1MzFMhEYJNXW518kZ+hW8rUZ7Htw1PQBuq6VX41XEril6YonVFVkEkwY2AdNjaKafvPO3q7HSsYAuKHRsTsaLExzRejd6vaes7s6OP0McPuXXyfTnbxegfbx+uXTz72+d7vmD+ldPzi+Hy85eV2Cyq1pp4zv2PAng+mROd6M7H1ZYZU0J9N6edujo56a9dbz1a7x0qE3UlvSOe170nUwU1ZYosBsxWWce7qsKkBa0FpS6bb1kW26J9P7cO/OzitUYOZi5a52iJWNwAoNNFx1a0y3QZ6KbYmdKYp1UDMsJNg1R2eSuNNvXx37pyloT51VY1o2WyTO+wiFOA4mpGJotFKGQwwJDdpw3fpjBBTOBME7GAorBM2oqqRrt5I4/RruWze898ehh5t4eqt5UVTToXJrTRW2CNclACuX0B4s2G2CDQ5JciQBpBEQ5JdJeOt2DWlea4nsHWdwPDf98Xp3XzvYPZ5e2d8PuD63neyfm/U2X4/fo76TP4G/a8/l75V6j5eqQWh9u75X+T9BZ+fmtsZX/XLYzw909Pj+xerzbXtC0K7O2UKtab/J1fS+DPD9KpztnMrKpagFELLaRa6kCWieiAOgUKoXJQM2ejr4vUvd59x0xV4vbK59nb5LtKr2ABm2otb1tpiOurc+tWmqkaiy+gNCxOI6SnO+wNJbPMqWMVxrNBosHJKteLMnIqMroXZMgxR5i2muPdXTiGwgMgwDgdAcwRCnWtP11+cePtiksSy9J+hy+HOD1hM1kAjE6A61SlQgAhcmEi27Tau1UrntJzLaW+ercNkkoTNdUxUgcUqzCqezO1r4J6ez7z3rryb5fF7I083cHocuxKx/S/r5XqP5P6Fzy7Ub08fzc/r2OhvictJ8/RVs9NN69ny38r6HaWPDsMx9EV5/0y7PC9Y9nFcdYs/Qqdna6XhjHoauHTnqen+Uvwf0HyN4/amAIB000hTThjBkYgClKockadZXkyaeNe4u3y909HE3mLbUbJvNspRVSTnpayIa6XrZ9FD59a5GtKm0tXHJLLMSV0ES5KHSjCmMjuaNqWMSQZhFyOpFG9tOTeXp4+RcPRq/nkACO4y51lcjDe1cbncgDYmmVTNAZa9MlLuiu1p5sjupOWquH3qQRpW41YvKtZ6DDBHbt89b57ppoEFA7aZ+3Pb8++1l4u09fR3zrGG41VWh9JJ8zoZVgkJFzIjRtQt+7271RuQ4t9Pj37rxXfpjbD5P05ep4Hrf5j2rd5/X55+rn8/30fLrb55aVvr1/wA+nnBd3zU8z3PYh5Wwa5vpi/C+hvt+YXZtA5LR1KCWkwra+vM95cd01fwV9r7f8qPwX12usaBliJBtt6Z0qLRB50HCiTFSkamt2XV2Yj2d0eXvDs47K89rLnfdVK8VPmq27r+VK6cGYivXXGWouFayXRWS4EMG145EiaC0pUYBnLKa6ESk6rIGa6U9Fe19PI3Z6WXjY9Xz/wCV29mcaczUSNjLlNFuPfmLseWiWQUkEOKWO35vXoad5+uWs4QMaTPdNnWcysmmFJNtYcpcrFioiauXt05PY/qcDX0a8ic/o+XfB6MkuM4VWM57kufSFa1RuOe9HTvOkeHNS2r6L2U42ZeHpXTg3718d2rL7ker8x9ZTczHr+JH1vV5w+P5tdzrrGeqjmvlt+j87vG9j6P7+BtnLl+6PtfLXzpm+VzbA3jYGmLgbfnjY3Nva+Hv2f5HoaS9ro/nndX2nhP5foFlLcVlYwusoQ6SvM4BVEtuKQnUsm1WNz7A38z0J2cNzrPYJlZbgV0vzaiHV6uq56AAjnVBnS/KqVW1PiwixU5hWGc59TFPuSUXcvlLBVuZ+fYOl6X5+sSCJFoWW09ufUN9dcwskMS8SLKssmAlWYx2O+XbHTk22A067nVDnXQ0duuM9w0LZ0KZ2126Vqu5B25qOxDusqkSqW5FLWpcZ747uQvevIXD3IuZdAGnClC21tG1fQqxjKLlQ2L6ATZNc3sTvexbn0bvw+ia4d+9fJ6E15fcHu8fnKuyq+JhlNU576nW1RjTxzn63jvzO/6j9Pz3oPLg+6fufMWfti/GO2dML0nszze65cHXc/P9DZnjeubnsxw3/BT+ybfmy/MfTFgXgQiQBZcQSBIwq1MwlhTLH1VctF6R24vTPdwtJjatctgqO1S1C1MKXQa2ri3pXNdJnUfMqT2rOWmYNhMNM29RZYmPR4uU+ehNyXk+qUkqKjBUcPIRQn84C9OiDnrgHqRqZqAqcsRCUe1eTl2B1RX87pK21nnu3eZfTepuXpAijnMinq3G6Kgiu2z5hLohqB01JqK2rLrXGGuzq5tMa9dV41iLKRUNy17E9/m8X+H1Yyo0VznIc0Hk8AhCUNgd1W7U3U+f0H0cPsHfytiawzpEwm2kDaNHGuh56tN5dPjfj9XX2en1k6/nvQePm/e32Pk9m+pG1bx2Lhpszy/R2X5HobV8L37n5vpPOXrPy6LFxdn88H+gfnvzJfmPpgoiDIMQ4HAlA6gyWw3mRjOixddvmt4HL6e9Litsc/or0Oap8QLVFkhwgb0llahfZq7n21zl1HTnW51qst0hpcM3o4vmckjUzElcV1qpcX7N6vKx9Dfxr5PfYMcbn0TTMNJhMCZXM0uO1BLu3RnVctK5npjdSqJZTTZRSCtz0InUsIJ3SMthB9STsIuSjNhouDduOm1w2UpT061LDdayqq6DhdSxBhTNos1Pbizn0Z2c/mPj6c5UcijFxowRgjKgWB7qr32Ve7XpjXz/AFBpwbM152mygHKp5lVI2281Y9/lrk76HGmRX2W9D5fcGPF+g71fjvRnsY3bC96fP+zceDu2d4nt3ny/XuPmemVGjjHq156/P/K0/WvM+YPwe+IcDgcDgcDgSsZIb6DHVXXpScuzat2p33px7l25dudPLnLIqSoWFIAoKa1LPTr7LpqWOoOaVuxkWa5zkZ3JFZvyWGqHzF1MrMZOfpfr87j63T8xvJ9vrnTBhKVkeRbCUDNStwA9UUk0Am52+lAqpjomTj1Rp5s/r9PjPxOwaGm1tGtV+Z1KL1TtwJSmVWF5uHFicT267rpRubWuverq0sVWyta877kryY8TA2PIUxHgswkYvyM2dALm4EQ0EyWXct3Ubk1y9LacG6r5XekioSu6mtfMkejo3n3r2bIYyp/bH0PlrVnl+iTb4n3p7G934OrdPz3uXfzPWt/m9108z1bLx+j1U2zz/U+Hv7B8v/MN5XrrzTgcDgcDgcDgZAYFq6VAg1lh1pv07ciGtRv+uPd3VzXG8WGSl0Vh3mt8thSatOnVGPUngWlISjhWkmdhrhxculFj0zq9WDk2rQyLFOcFUsVtpTQgipdqTUYWZSFk4uowyuKzjosu4kOjM2jsLgsaTtuji4pI7YjMpdNmjx2yMlvRU6Xoa+GLd8Up66qvmVFaVvK6Zt0UfDUVPVWN1rnQMgmK5owclNoxpWKMEQZshAjB0YAPJgEoNKNk9ptDoW1Vz2oxTVdWnTTk71PGsLD6VioNp/X7v+dHzn6s8vyn3r+g4PS3z/0Oz/H9h5yduyPD9e++Z7L3l9DsYWy/mdf0F8R+d7887oUcDgcDgcDgcDgSAyBrqp7Hmo40vF3AsmTex9c946cuwNMWali5BQieup8OmmLQGXVqvidgcPVnZNVc6ykzlaU2eeGjCkyCRBNVLM4SrSs3dTkhyRgWRsmqg+p6EDNrRq5uuI6i3mkbM6MLz1QgVacw6hsIgTWFLIue1XqqJDJDpZv7WzN+UKdAddFEUjhLFVfm6HfVSstatF6+xKrzoy3WuZZ2DwYh3QNmdSdhEjFMZEdLoccHAZUWvdbG6ndbgxGujTXnFK3MY7Fw3d92DQgD6p9XzY2tPcc/tpl8f9+F6O4vN9++eP6m3PnffuHB6rLD0UXZ5v5gP2b4/wDnseJ6FB4FwOBwOBwMwyZEjgdha9S29bgSmZa9nCNRCX5JvqM2eh+vlX4G1duegnUszdQm6pOi1GDGpL0RSm61nYt0tKsWeEFaM5yz0eAL6M821zmSkSptZAo2RJimx6ya5Z3BTJWl0VU1tV5ckG2b5vRnpc01pPL1rfXqvzaox0L4AihBqKoHOrVUMFnsjTmz32UqlzcHNAetgJ0OdqwuioqkU3rLnqlc84Q8AWSupJ24tAfkImYB0ENKOX3RBBKHVk8EbLNort1PEIWA5lVzVho3R2F2IsWqohftFeReOjHZzwiF9JuP5z7d9vL9CfI+l9W/Dfcqd184PsfmPzV/Vcf5Svm/ptFebp0HA4HA4HAZUQolARGw+stvU4XomwyKsuGrPEOyqZNbJW+dNdS97vaDxb1MLNazvElwABnsZpNFnYXN41xMuj8oYXNbiwHZ8xnYeKQkaHcnkQJipJB3cs6kq885bXWTUGUqwtKPlrBD3zvxbn6eefZr20qvypyejDzyE2CAZdeKjmmBNlWe0OvnR6707iB7bBJFeqSHXFtTzWvuk0Xq/GqLxyLmHaGduu8ijR2n0wdrLNj0YogRmzpFi6CBCLA4DKhuxnos2H2SU9jbzu3ti31zmN2B5Ccr3DXFYdJrE6awz32/nxfQR+Hs3sXgTX2vnJwe5525ejTnAAI4HA4HA4HA4HAeWemPTyu/VWek1KtUfIlM00Jv3RKjOqvm6Ji6XyK2dBa9ghjVoSDMRGhWs6Po4hulI1ZlDl5tboCUQ2YlCxxWeIzyZhESrI85Zdo0yJmH21SrJtecrccGVhiR1mtMuhZlW5NeLdPblYtIWj12+nRHB0m3CvCxmVq9KXGuSDbmz552Hok51SqvvBFUk9VWY0q50I1del0ma1xyNDiLYXUmdMOCKDCTpGDMWYAOjgRI4BAQhmEQcCcG9DfRAw7V0L2Z6vK+2i2VlsTbPYevP5H8T0N0Xyq1aN3rzXa68eHof9S7Plv+X7pk1stDmq/zlJwOBwOBwOBwOBIG/evH7kfU/P6Mvuo0aUjHWqzqqzbCYr71Vqk5ShGifM0hSyba2jmV6HOK10H2CSLgKY3CIGznOE1ctBHCy1bfJMLy7t4xTGcr5eR1TMDF5s4GNQZrLyIG1qGA6kPbqcbKsKdXG5Xx3XsmfevP/J1rYLXpFVx0GbV63rvntXFsnnadZv3VC9WwJpVaCcqqC0QLRGb12aRqtc43r3lS3IiEw3s65r2JBCV876kGtcThg7ZxGAcDgcDgcDgcDgGgMG4enL6UfS+e0tbfvm27pzbm1w+NfzP0m0tuRFdp4uuzrTsdKl161HmvAQ6AiupWlfPSTM4HA4HYFMjCTZe8L8z9LP3fyuizv0nHXROd02dK+tKfOuvs9td4a1LLblPzrw60Lhlvq+whQHipqLD01ebzSq8QfkJC5WOhMRTUnhN2eFPjZtaMpFTPeYVpnslc5TdxMFu2pmaPjMjolmQ8axiV++qbHStTahOxOWljG5stZL2LzYCbLMCya4+mi4tPWjYix9CZ2BAYSSVQb11xxbV97AyV+XUo0pmLq2JNYz6anuknNKTGI2Xnlwpvf1UbyI7DpkocBn0tbzKBHQcDgcDgcDgcC+7r7RfSeBvfr59ibzuPo5b/AHh8Gvkfqb/WOvtNxQTTrqDn6K+9JkpgQt4A0U+eOCq5gQgUwUMUcAoI2fVvr8P9UX6J8fqTXr09l0aU5elMXV1pS+e9Wx0avy6NaZap4rxhy93n755v9VAxvZIibV5saW2qXtP0+Dxlwd8ozWmAPXNpWdurn18ul4ZyOhUypRNK0Xi6pWDPG13J6gajpU9cbI1wqVWFDX50lei1NbNFqbpri/3BqphGV3uKc7WTa01Tc4ht9jn6KiEXQjizYyZ73RDXVnL1I8mXSqWd0zOkcCRGw+pA9O50ZUDkFsCjNL+YVcxAHdGCMUe4/sp2H9v2eBPyvGqeVnwOBwOBwOBwOAxpfbj1/nPpr9fxbJfLsG8Nl3zfmH+K+53Bvy0zPVIr1auvVuXQK23URjWhAI4PLvmVGnCHUkYQDCFiHYfWnr+f/Zx+k/Car369V10awx2pvPox7q8xcHdqjgvU09VZyerL6/k/8962s/JUgmWhHBPQWyahlu2DLA5S1Rw5km9m0jmrPTuXywsqmiR6nMGOqaZTZdc8GTEuJV3nnebiDJuLThTFSET7KrpQCYJTlw4Ism0HpWi8rA5rtXr06kfMH2q1Ns6RXdVbxoixbroh5C/75aWnt17yaw5Qtq+0UmaqHOlMFs6Wz6Wky0XZYq4ajFKeQCRFJgjJnSPsd+h8OyPser4l/ju9c82OBwOBwOBwOBwOB746PK/Sj9v8tsrfm3v14bDrP8lnwv321tOMDbajZaeXsvRq0W8JbKDQGbDFR501cqqfGTABBIxdDGkHZKj3/wBflfvu+s/MtefT9NLNdXztqfDSpxprJdmtefTXWG+qI38xX6HxG+G9dYjmbIFZ6n0F7efmHxtm9DboeSDacQpG8kNrVsJhKiY4SbGRLZTRsKwVkTbsyzV6snN3V4TuYHWSTQkGhOtWMw4JxYlVnuG9GdJrM2DSVrcAyBUuNM6F0Ubay6KRRW9+nk1pt2684Bbe2ujopPGyxKGz8zX02LMoIp1sBtg5ypghQJkq7xg0nA4HYYhs30UmHS/OOg4HA4HA4HA4HA4Fiuf0w+t8R9ivufLs853WM/yc/Hfd2Zyqp+cl6GjOfrwZbFk1UnU2MqXSfNGXVWeee2+AszUzD9HVsEswcVG4OnL9qnV+XfUr73HUvQUGd9dzrq3LVOXruOjSmXTrnk1+HXJ9T88/jumal2n1AZooU8mjrDqDqGWzyb4ztDSk0Z2zNDmh4Taqzik4FmcldBBkzDJ2TYDNrpAM1A2TCX0+0br35aIb2HHOm1pjI3clNZ2+81m0FVZZRj0aL8xFVmJBbXUJ3tJlTunpE5JXaXrnLSDnFreCIGVnKgVK6Duw2nXJBckDmJuY6kuXaUTiMEcDgcDgcDgcDgcDgcDgcDgcDgbV1x+wXX839hfc8L1d6PJ8MvK+soBtqvHbzHj6Wss9k6p4oZsczm32eu4vWeV750wueuKJ6AKo26Dnrojz3UOcEY3D0R0836iuv8/+uX2fka907a3bqmNoaev8968afPt+5+Zz4H6ir8itPSKEuc76o4BFokGNBNBOh3BnQ06KMB7aXIbAQIkbpy1U2SouumCe9cc3enzpbD81Z9pS5V3QvTlazReTBM9YhHSl+mjeMrTcr7oGUzSFTqV6wpV2Nk16jZozSt4Y+XbPruvxD853SStJcd2ADLOpM9GDJWsjGFXIKtxGdhNpZg45I7OIHRGjMMA4HA4HA4HA4HA4HA4HA4HA4HA4Fn0nfl8v6MvpflNP4dfnmOvy/Hpaf5urWL1KRKKRpZdZZL0fvxNdJxkyb26+a6nOPT8er1vI3mdNN5UtzcIWrVfVbX577e+5816C9PFXpaJHlfn9H5Oed7/yw8X2Nf8ANWYcA1kQcR2DvZBSE0ZIOoabsaFOgzV2roccpoztnAsSme2fEsnNrvJtaySJbmrIUswmeTG31Izzg3RdMGDsbvPNpsHqW+whyCmqlW1fwusXuArWBEOnYUkbVJ8RrrmQGZmFz7HZtBvoIcmgh0bjldkhIeLXE8GF0hkAS8ZMQ6DgcDgcDgcDgcDgcDgcDgcDgZhgHA4HA/UL9T8lpjn31u+nV8b6EPQ828eybJdN5N27VehNeZhdPHzu4i+PLC1ZHlH060vl08P4+npfzhLAiyfAmC57T6xvzrBpPmfLu1Bjuuk7ZgjJmKGNkgCSZAw0QUPLZSZOZpjoFSQg33ZGg6ob0T0dgWFpIa0oRtVDS5bKYy2d5NbUErKXX3abGzai51mbpIzWC0MedonMB1YrgLa1mJQDsV5sYpZKq70RYuvAsRWMRjTSYSKyODbvZGtsNF0qKWvzUckQdy+ghktPWV/IX4nQ4xYhiHA4HA4HA4HA4HA4HA4HA4HA4HA4HA4H/9oACAECAAEFAFS1CEgg3oCpU5BvsJB7jJcQy80yY+w1OCaxNqgjSKSSh1FgKV6YiNeRNZOzEJmyGnPUehNg/wC2SipAItVhavur3qGEPUkfbojibi9vuiEZrITCWQKXIV+Q9FHRY2uB9vEBCtinVm7lKQU7aGnBIBLNe5sbtxFHqFTr0NEnl1oWpe3XUsqkDg1MCVmmMpZU4teiJAp+5nUKenasxrsuYOtLI8aHrUUTy1JG8VH2PQAWrkxPobBj6XNlHTpV7Vc0vJanaKSQKBRJt0UUxBpLsyANTHuUEpU6D7k+6utJ7OhYxtZsvHMDXvRUEGIURcAE1YqfevssLeirXWu21RZWpkLY2PkD8JoaaNRUMX8uRAUYJXBaMVm6T40qkVemW9YuZl69k3kORGMm8Z2uMtPtnUT5s2QSSfRiWJoj0v8AewJHAWxNdm5tSQtjyNxsBcrIyDkXKMoX/iv8lAAtFFGCBQArj0ZReEEAseQZLsosGBjjUlu2GokUn2GVBcrcHpRBI5rX2WBszNaj2wWIoR//ADsCKQEV91FescYnkY2C/wDrl5ip82PIx2tYqCOSCmjYR9RVwQbWqGQwyTz/AJDAXLMjp6frXWM0rKAwFj0BNz71a9KwQsoD9y6g/wAnSmtZgxqBeESXRrAMDesPCbJK+LZU0ckE+NNLYFQAqgiQgTM1psaQHnXvUimzBjVjTAj04NQUBgCT9zPxoNHwWTJx212+kkDYyhGB4Z8PJf8A+Zk6kfdy7cmbGHohuPj+rXfbHJiEeSIqROAdQpH18RRuKYXoxGtFtJdJNn5DZ+UUFFSKu9MtMQy8RQCmkVlqBYljBt6WuYk5hfvTjaTpyLhpeLUW40ZftNKSWUO7TRulN1Rn6m/FgL2D0GHEio2dXuxWNG4xlQ4HFQpvTj7x1KryrgQTa54sWUGmK8fagD3TYGuVhclY05UuMjVNE0NH2r9PuoFLVyXkAxo+/wCnBQkamiDQVgSoUgggMGrke46sw4ilLFYFWRtk7PWv2W012Zv449ppCvGuPKj9hjWwwiDFJ/7rED0kisPTp6xrc9B6cpaglktdJxoM/uwzLHwkcnDIIrrEqMO4Cbgl4JUeIQtJBV6UWNMoYWipwq+nT0QAmhzI/W3XjVqstOp5WBq1gRagpNLF0jUgrYAix6XJF2c1FZgvO7RkUoPHkFAF2aJCgvav41YMY5ZwHY2puIjUkkfc1zQ4pTterDiByMLBFHKOio4WJSwoCwIHOw5kcq4igptXSniaOnSRAeAHEgnkAQbQEdv3p/5IWBU9o1wACuFoled1o3ILfx9ughDGWIy5eMuFOVuetWQgwUVIqE8JzJIGUcD3TfEKkzYTuU8fWeTYZWM2uOEwqTHMYZbi16wlCRT2WTO0OXiY59/RkU06kGxt6RUPaokj4LErgqsaxZLYOVHlQ5+LsV4RdpjXZmr8VhX401QpxbIjPOluaCfd6XogMODg9tqKNRuT2qvah9xBsTSqWqbFngpv2lSDakswRAoCuot1SPnVrSWaOlW9KAZJP/c62roK4UFsLEoGd0Jsnp3KHMrJe114C5o0oQ17E9De5VSwjB4Hmgbp6fuHMAf8WXoAKjVhJxY1dQrKGDlindfgbWJu33OAbhGEbxzJXIxKbswMhZArqxU0ApDhVUx1w+5RamW9ciKNlPGQUvJWBtQdkjuklSRsjMSaDk1CnKoiqVHKpSVyI3VKJLRx2Ky47EuSpxT/APHOolMW5zIsGUhn6XofsYC/BKMQrtGh7gWF+scnaLPJIsQJeRQa8clabY7MGXIhjSGgZKDEkstIsYXIx0YywCOmTqeJa4porVxNwpJjxg1CKMV21o40bUcRbS40gDq6M6gCsZmin2ebHmFuVItAA0AVFiaxXWLInaJ5FX7+nds1gqsFHKRW7b0v7gpKmEWEaqGi4FgyhlIBISgDdftZr3arXMbBWexZF5N0ubUCVIWFq7nIJ1I6qAAaBBDX4FmUqAzEkUKv0AVJJCOUguLC7AqerEEKvAXVoTiH243WiK62C8VYALCXUG3augpmuQxqIG4bm/7WjFxyXkQGIUKnEVxFAg0e9ELk0qAFgVqzTxL3YqngAMyFMWWlUP6fpQP2t7+gXiAL+nNO011peYoydqNzaLxqNsaXM+2RRxAYH05tTHhGWLVcTRTxESlWAHu2Tktj3BpIwpY2oC9BqYdeZosKmgEiSLwAUn0saKlBYk2IqNQxtXUFh1SxMbmPIzshMzI5KaY2dz0W7rxApvfrR40zIVL2pwAWj6rCxqSNkW9w9iTa9dRV7+g926EEilIKWLnpQa1CxkZSW5intyVwAD3I1UKzEWuBXFfQkkfeQg6ALy5Dm6BqYEIhvR9LCwHcQ/bLGvKSxjdDwm4uEKhSeNwqKFZCYIpA5w5I4+kZx7d/IjF2DAsbDumlcFqWWgLi9JMvLZycFB50/wDGVUkeigdtqtegDe16At6XrsAtCquQgLSociTVYK4+PknkSOYtY2jkSOAhZ4GIfHtUf2LOnKNlJJfkKjjaOMMppWIpvbFmWKX7KN7lhcfecuIguvGj1q5pr3r2Ivevdn4rT9Kj6JYlhzFSW5QLzVERQATVj6MVqNmQdK7YJtUUhRiysZYuAKotKBVyT1Pofe9vQWFI3GlZhEvC3IcTZK7lqMjVcmiDe9wP3MOJBoFW9OHXt2oAglW5cRyHsxUVxXgSeMxXth07blWdhxnJVVPU3AKoONiqceUhQJUb/ciqRjN+OJUEbISxvFJEWCHlzr3o2FcgK5EVExDTRSx1NNCsTyLJG7FJgvcp+Hotr/8AAi4A6+p96MbAKnClilkGs1valWzCUManmVTLizTHHxEDRQDHjMsxp5gxeKNw8HbGhxvH95n7nXf6rOjRhUrXq6Cgaa9BySedBwfVfbIh4sPTqK9660qkkDijArT2NFARclhclbkSLWK6doWpTapC1MVCWU0CVKX5m4UmgRZhcRMjE/uPG3SrMte1RkFACT+tEAjl9pDLVzV+RkCqOYpudo8xHxKHsbMAOK2UVyU0Rals1e1X6+lr1ah7gdGsWLmkBLBWKc+MaryC9SVjNBiV7gc/uaNw4BIMsn3ASzQs5sMkEL2zGo+1VuFPUEkdFqbJZg95Cn30LEj7Vvyp1410NOfu+mzMfYww/ktj6aG2UkGGkGWWkw5ZQmbsZb/7IrSbJbYcySNkJZvan61e1MO9H43j43jrZ2Xk5+cASAhriGpPZx90X7OtcrKCD6A2OShKsQtN7SFSxHVVsGuArLQ4yVdQfvjoLyoWUcbqw5ERMKjlSwjKmQmi9MAKdiVSz1zalPEyMRX6Ifvnt3Y+rSxqh9PevaiACPc+560Gv6i97FyARRHU8ri1AhGaQEHiEiaMxNxuLFlBpP2gg+gvbrVmFHuWq4MkmpyIIDYBgAipyo9Sz86RKV1aksCF4ssr0t+aDtl3CJm48UIDcCmTxAyFt3ASXADysaZwD0Wo06DrSvyN+vQi3Utc3Boe/pEPQDpHkZWO+P5VscYQ7w7J8desuT2oZCHX8Y1PiR8FkmxnwstNrhzyTRiYYyOfdrVMDJGyv3AvGogePtTXFSXNIeFX5qr8iWsQCtfuDWZHANcRbt0i2BIvcCgO4rpesWJMqQnk3SiL1D+LkYIuHVgtEfZHkEVA6jIZQBUnvGvIMONXutzyJDLJ0jY8jY0WZiCLV04k39OliDS2B6ULWbjblZkLJKSDQJLksatzr7RQY1xrrfqaUVxHJbA3Cgnr6E3DCYDJaOSpo5JUxdtbDRrl1C0iMUdQ0asq1HegOKlRy4NZrs5bkbvwVTbJAMvJboC5IsWIJSQpSq9Bu293Ncj239uZoH773omh+1ff9fRF5UP3U8q3V3Jx8h8XI0kqZEUkacWUg8GFMBRi5y6zPk1mXkpHInFFAJIN6ncxxOCJZFAKEcCxJ964pUsiCsrAGBKPtBNdxaAsrHhESBR6D3FEXro4PbWhwNciGsBSdVPs1noKeUicS9+AYii55dxqLoKea1Y8xSnkDNys935OOJlZywr3NX6VfpQQ0AbD3axosSFH2sVFdbX4gfsNlodT0UMtq6CrG5Xpfoz3C3Wh0P30bAUQCK9qJ6leTA2VCtEXCsVCgmlAI7fVV7gsLYcOVJPLBkY0jJ0WlKcZbOLUv2UPagOAiUisiMQtKOsh7aMK5igwpCLMLgey/QjFT7GM2EK94LjXZsZe1o85oJEnV1dizNK/B27rNEsSOvNfH8xsmBkAoXBA+/KclmHV2CgfxUWvSuKMgFC5JduKOG9eRqVv4wnBkcmHiQosAHBoGTkwHFiDQICJe4a7DpX/ABATja9C0jm9mKuhc2PEjkOOEMaTLkAjk5stdw2LE0D1W1hcUAS9jfpbk1AA0WJF+NfpytQBY/to8bxOoSlIspAH8VwwIY3PvX6ixLl6DCylqN6/bRHIHoSL0AbgFjybiPZrcTKt7favDiGciIREcSr+5ARTqso4238hkWTFIRKIpiAGPWyuqq1GKUBVDBeqBmJkeVgCakHM+6muLUv7ZHKsvOwNvUEg1c39q5BKwsdWTJWNFmn7L6zOM0f8hq5qIx8slkoRcqw5jrdlnwrd3AoOpjna5ZrIzcqJABJtRJJXiCnU+9LILK32REMZD3ZGFwWKMzGQMOJaSxuzk2Ne4tUfQ26yW4gXU2DJA06FFV7cx0YOBS2CEyEnjejYrVreo42HRvuJq5sb39qIYeliDY3h4EyxAetjewNWoqxog36Em9Wq5NWsWtzc8iDRCsvQVEHY8e5E9lPQFWsAx7kpqN+TEqDJDNCnFqsaUdugi8WghlE0kr0ASHULTOQLqzYmI87RYONEscOHxhxsPujT4OdHkePZEVSQmKiwAv3CBdL9EYW/bCQoMbih70PU0X5LbtVi5c8VO0k5dBWiylWYMGqQ8VkyUWP8luMeRLebJZ1gcya0rxeWQ3ZrU5JLCzXpLkW+jtH0U8GZ7AMGF71BDNO08EuMFAIYURcm4IF6R2QKTZv3ohu/7ntxxcpoIw3IsSRYlDe7gChx4kkE25fr9N/uq/Q9KubG9dfQgAk8UQlDJIXBHFr/AECQmvuFHqRyKAkH0W14uJf3okk2HJG7bJIoV5AC5FgqFla9NI4IWzECZVlkWGO7BOan7UoE2ohJKtTcLO3M40BkeCIQx8Qxx2ctCeJkmKQrNAkeVhYmwi2GuyMMhfuNqRWNOQWyJLANc0jXpff0/WhU4QE5Bhr86Su6a12R2Z49qoE2xaSo3Ei8C5ePjSxNJJOOzE0vbp2VyfZmAqT95IWgCKAd24cSOot9DMWpUVWeS7+OzcYfKWVoQOKj9o6EsWFdavanvYWKlXNMw4/apWwLnoxsT9o5Gyjrfp04/r1J9iaBI9B0b+Ohe54gdauRQsCaRuNNXUmr/cidxnR0f0JqNSVYgknqU+0WANAEluQIa56AtJdgAtM6Vzroa4muinkeFgFBPbhmXsqGCAWqMi6OGpbSEmwYACbJ7tKPv1sJSNV6MeThgtLPjkAvHTmMt/6akjhyV2utlxXwsFZUzNFLBDO4gZ3ZmuTSftVuJV1JBv8ARe1STE0fdAtio44UKXyH+1eZlgypYZMSUylYHcarAj/JzchjKw+52Ao+7XLB703GxIHpcXAAK/ucqJOSmu4a6kcluBWHJ+FLl5U2XL+jWvi47ZuVmYUuFkelhcN0FxTFgP4ySqtQuK6CQfc7WusbvEw5A2r7asajZVkdU5e1J7+9cSKPvDGZmSLmPeutjda6EJ7jjf0FrKbM7s7UW6UpZXd2Y2oGwAIrg1gSpLcmYAEdW9OBLkFCDS2I4BqVipXkpU2WxpQFoOlITYLwqw5q3RpXUuwY40KGWKNVq4pzyqGNZh7UkzXTIQD7Zq4sj5MEWZDHAkbNJK6biBYciddSdVQJFBmqHoR68Hq6cfc2NRCvtvhQoI3ReTIOaQFziFYmgHKOFDi4MhsRjytr+V6Mhv8AoVKmpIJYV5NX3mlf7zLTFTVhyUrSuDQtzuHBDGr2r2pgVqNjDly5+TNkAWNXFEWr7oiQFThzTgwK9GTjR/8AaVYJiyoEoG3p+pBBClqsbe1N+24uP2gGrWoGxAoEA+ivxonqPuq1ifeiB6KqccVQqZ2PGvofe5UHr6E3IBY+zMSaW9/2MSSOTMef8V3YK/FVdFfMihMRFkHstgwJ7gcimZzX3kAspILVgxlnRo2kFAUbrQYChc0WYxxo6uzuDBI19koAk2CAbPIORkfQhII9b1EBRjo+8SqBFEHkE3Cu4tEmSkQIwuU8cLZcuZNR6UbUZLEdWHs56sFdS7sfoBIMliFi/wDnRVKmyupFEdw//wAfG9G9z736dRRuaBFyAaYkkMy0pHGQWrqQTxLMb/qeQ9Dxv0oEj0W9Na6i5JJN/vubsWplUel7gEgta4Ni1qFvoQi1rUfZR3VheSMT5JkVQOZRUcVcUDRbkVa1X6A2q/AH7n9LJQLtRteSKMqTIKXpI5ICFSbPQUGuoZ7gISJG4l9d91BVuzEUG6ISAedkCFhGWIFj0pUjNbscsVshwxPL6YnHIe1e1DtV+plTiy8m5G6HgUJ5K5BikF3nWoFmyK0WIdeMzlfqal9ix7aN1w9VLkR7TWS4BkZaND1awoKTRrlJftSJRUihwWv+J6Vy6e9XN2vSsbXNfrevYf8AFZFDO5eibm4FEkg2vyJNfpVyp4n06kAWCdGsQf8A+RgRX3EULXt9X217lffpcm5BIoyXFAE1a3paiLUepWr3LfaxBc2CUUDH9eD2BNxwJue2/wCyKwXpX7aBF/S5vyNKQ1YJCqjRkJyerBQLhlHKiesbG6tH3VjjYKwCbBRJh5QUZH0AElKxopMhp8HJx/XiRTBRLBiMQNekdZOGVHJkoCa2PHKywYKitbDGkha0+aCaboZVLqTcyX4YPaeLyKBJcVoTYqRXZ6MpFFSKuvEkxlmIovivr+U0kLJekANP+5jaugPEpGb3tQ5A2F6FfqC1HqLeg9vQdB6EEUBdSpWoUSYC9zQ6SPxDKyiuhbmLHqevqQAa9/pK9PTpb6OnEixtXvRAFfpR6x3BJDgegBJvZhzegeNWFj7UjAGlF3FFuIwXIoMoK8Va7rSWQrI11AEZMbUADIocM4Nsws+Pmf8A9n6QSteNYV0k08GRDuNccDI9MfVqK/CVCq8Q6g1JjIT+OoWGMxtH2+KMEKEMc1xUb9t6e1rM1abMCJsdkzFnBrmxoSqtdmJ6kxpY2biSxubtY8rqSIiWYMlAGlbjTMTRkUxtYMbkWt6AGut6BoC1EgD6Bb1axqOXtrICat1A6r9zqfuVipMl6H7zxBUgUxvX3Ee/pY29QStD0NXNBSRXsfU2FAdOrkJcqaJ5UtG7jkxFG4q55e1ezIQXFlEbE1cXpuRojovIgsScN7Ordt7guGZiC1omIpOPGNo2ruHuRvYLIY5dj9+JO3Ob6VNm8bmR4YJeMvmixxoJlrlSceLkASFGMkQYiJFIiUGZCRjuRUDGWXXt3ZMk3LECnbggBahEFBIFd01IOKi8lSTrBWfrDiiNzFWTF3FINQwyTORKjK4Asqr04wy8JGty5VcUxKjkgofttYe4W9uRq5uKNWsPUetqFgT70CLL0A9/u53NKo5rYrYU8Moijm4Q/wCCxtVvQfULVcX6WNqXqSzKx6mgSKBI9OoNWN4jSpJysPSNuLkG4Acm4IvGMeRZULmma5tyoEq3SlPOgeFF446hflNvpkxcVmLn6tFsQggzomPlG3kycnpXdFK6okkhemYJTSoa9m5zczNEQO2DhQ/wwRpjY+QLURenYg4+OsgccSzGx9j9tRSFAEDIGLUTelrIjVC3UliSWAH7x9wBYglgAxBoH+RHFWd6APqpIB6m5JA5Vb06iuD29OtwCR7eo9yACvVn/cepINL+4o4o9Qs0gi9qubUPf6Ov0AgEXuVIFXNqBsbmnYClZRTAmrCldlQkmj7KwUyRPDS2DSqgN7mr3biC/Nb9bWbmS4A4PR6NycHFmDhxzpVEtKjVdeYUrQZgiFqQRWhRGbynOEknoQR9KsVK7bLELF5CA9EsKkk4UZODFzzZ1cr/ACng1FONKUdtZETFkOTU7ElmsUUmgFFMysHUE9AOtKEoDoelLzAv98qJKrq0Z5WoXsHs7KQHYhhK5IXkRw5uDaPkGPWgK61e1H3F7rcGjXQhDxZrcquRQP0hiAw40bE3tUkRWOg7ChXU0LW9ASPT2+m3oDaluGllaZvQEgUDTrR4mlsD1FAlTUZCtYNV2+kWpbKbgAWtYXjktReNVZzc8VMcnB8eblHGxpHZVPVUd44TbtoHDRKVGVmLiYOVO2TN9Sreu3XBa96N6IBGfrzI2SJYpDI5pJFLJOBQllaTujlg6+TIkcQ4kTsWlnPekmc88S/GRm5WFOl6kHQcHoKaJEQzNVnYUP8AztUT9MxOJLg0QWIJUo6LUwLk82oqwIMl+KtUYFr9Lj0626GrH0JtV6NX9L1b7gAPQ+l+ifuDWC2uQCS7FW9vb/CSDQZgtA2LWJ6fQPQ/cT0qXHaAlxc9aVSxNvosK/X9PoJKkMLLYFSTTWLZHDl1oggNIQYJ2V8fO5xRySmudwjsaUlGRiaeeFI9tuGz5PpAJID0Pb0T91S/tjRAM7ViZs3Elx2eVyyySGsTX5Ez4WniWXSpEabhkV1SOfKjnxpfbDH2cSQ0Z9FFaNsGasmNPy82HIdtjtopsChal6VnLdOcCjlyLKAEDCnJA4LawJeGWBulFRa3p+lG1wLUDf0NE0SCDSqGYerWv6fpY+lnenXifVrqGVBGTcm1/wDFe/0G9cVYyO7mh79oKSCDxPH/AAoQHt0BC0oAq4AbkVJ4gyMVe1wGqLJZGwtqGWOdZaC8qUCpsqLCG03Mma/1A9R0H1dqpFFZupTi+ngWjgwQvAeByZu2kanE1jyRmKViFZyal/8AZh34XPoYuRZeNAkUByPHg+CInz9xjQYwak6NsZStI9jGyEcwCLUxU1cCiqsru8jWtQFq6kH2FxQHX3N6Hr+vqPQWsLEnoaIFmupoOy03Rvar+gtf9f8AIDYj3JJq/Vrcq639ObAEioJpMdYljZvQ/Rb0FwOVl/43uikinlJd+TMx5UxriSH/AHEcTBnTwUm8mRX8idVyMmXJf6QCaVVI6JXP0X9tX9YMzHnclBNkzcHyMxO603KR52U6TEk2eZnZBmriy1I5kf2M/vhkMptTuprjakAsqd6QgqUbkQTFJLkySszciDU0cmTldiSMwx3W16uQB1odCmPK6i49Pb0IvQBpGCM5BI6/Rc/QBRUioF7krgqaAJJQj0VSx4t6dAKuPS1z6gKfXp9IuDQJU+9G9SOrk9BXv6dateupPUVe/oKHSvc9PQAGg32MLJXW9H2dgpIIrjcA29enGx4lr0beoBPqFJoAAUfcNZfTpQN/QYwppXNZE4jqaRZDLKEGFp8vOdmXEglnxlE2S0jcgwU86k6R4ElqXqXANDlexBuaelew7i0aJtWZIqRR5DwyCRyY5GpWK05UoG+43rAzjj49wSRf6rfT19TQHQHoOh6+iniTycXIq5Kj3v8A4SCPoJJ/wAE+htRt6frRYkV+otaiL0PT29LXJIveval9wQKJuWXkCnFSh4i1BSK6H0t1+wk8jQ4gSujt6x+hchio4g9KVgfoxsufGMW3inqafXZFBMGGSLNxIA+zncPlTPRYscvxvMxtddzSkgdwmheM4eYMmJSGBFi4+6MAKByqRCtKxAIBDoorOmLSew5E1CenMARlTRCiutrn0ua9woLen6dTTuzn1PorcWo3omrelzb0It6G3D1uSPpCOQb/AEfpZeH+AfV+voa9zXtXQ+v6frSinCgCyqx5BwKZHvxIHViVtX/Dlek/d7L6+3orW9P317USK6+gboXJFAlT+RJXfkqTKnlf8iWu+5pJeVEsBn+TR5GjW4rkDRPGmUtS842gzYWH7ApDr1I9g6WHICgOQyp1CTOZJDUQjLSdtmoBFUBWK8bAir19te9C49bEehsaY8vSwNNwsLrV7CxFe1AkehNQohEsXbIBJ6sWJP0dR62t6xL2zxtUihX9OJ+q30G4PW4ADD1H0EE11Bq/XkPS9XFRdkxm1EUVNKC1HrTU3U2Yev31YrXUVY2IK10t6sTxuSfY0CR9ABP1hiKjfkvtQPWkt6fc9MljjbKbGKZGHLRDkCmJu8qR1NlMamlaagDdlQEgs33VgYJzMva6yTVT870Dyom1EenQeq2uRZuo9QbVa9Ai/S/QmxIHT1CNIIZb1JNzdmueJt62vViPX29DeojR4AsxJ9QAfov0vQtQXm3bN7UQR9BYMPT29D7jpRsDVha1qteoyquQSV6r+kTRkQO8M8lpHkjaMPFcEcaWGV64kOStAXoqQUsSR9A9yfT7a/T1CGgLD64mN73oKajJJ4AihxqwoqaKg1Bkz8osgzM0hIyluxNX9HjK0lrQAA4zph52fmT58xC3DcqUl1KsKF6HK4vUWPPNGfc2pxFxNAEnExZMqpI3hkHv+vtVq6XoWFdRVr0tzTCzDqtyx+jrf6P1LE0PU3sxBMOOJFkwWCEWItSfu60pZHY9xhRABdgRXv8AUenpYihah0FCgAK5KKPWrII+C3Ki9ioeUOGk4xy8QO8sYdi7Dh6gP6G3qFJLKVBt6fpQBJpVt9QBNe9BGIiBBHsB1terWC+9vv8ATiiUT3DjWMMNkkyeHZdiKa1LYs3U1EouQb8Sx4PYFqXkAWsaX39qhlfHA9PegbEktWryBi1PIZ5uBSiOJvXW5FjQCh2sfQ9TyBFLa9Wt/mHV6hcq+UOM3oCTVuvvViT2ZLC6sRyjoC56fQfajcUaHUdaUXIFgyIKPbCoo58I7BGsVYVxuHF1ZTIJAe5X3UEFLH9ixIaESCng6db+pS/0ACh91L1VFuvrFGXKwoBYCiq0FUUOgIIKXsetLS9V9CBUg6YjWHILJlutnQrQUCmUqPRX4gAlrdCoCkXVjaoyxFXr39fc+1e3oLFrE0OtKRYG4rqSFBrrRUqSAKLEn7Ghb0bjf/BG3Fza/wBBvUOWsg7qorqzv2evGzXrpY+2IhNK7o2whjAIK+g9/wDh1YUDehVzVx6W6+5j6si2o9AA4U/dRBuyK8dubyJai4Vn5qHU29pKVTSKTRiZPT9XXkCOJYEBbmi1gUNr9ACaX9yrauVq7h9UQkqAB1+j9Q5Wgwb0t9BNqLKtfdx/KcrIzSU63XjTWKn/ANZBBpG40CpDGjRYLXQixoAg36kG1iPQC9WYgBaA9PeiCBxNhagrGrMKteieQUKaajeliJqxUAAk9JWN/wDKiIaCBSPUFXpoTXVS9iMOQGMsA2YwEIQk0fdG40rkD9f1PSj1FjVqF7g3MRIaL7kKiwj6cFpEIAF6sPRkuXh6yxcWYFWF1ZX41AgepAgjccafqbCnQNTxBTa9NALCECngUg8BXSmbp6ohuqKoA9f1rqPQMQG5VfuUHHpckS0RYDp9HEX6XP3UQRXQFrsLiOudBg1dSwHGr/cL1brRrrQ6kXIsoNyK6qa6gC/H9Mc9ZgO4nVeKrT9VTqGNqsXChgGDGlJKsLf5BGxZekf0G10cCpYr0VK0oZWTKamZpiHINWArjdLfR+oJrqT+i+4JUwFeHG1XHp0ItxpxycLaiL00d6yTyDBielAlSmQ7xLKwrnei1An0ZQxWNV9PegORljuaKg0UF7GlTqsxTHQFaF/X7KP7OR9FXlStwr3KugDNxoj+OP8Ad959OVx6v78SpZQqqgYimjQUJLBQLjqehr9eoJIJZSte9WueNyGsFspIsTyWltc9aJJ9FLAsp4kfd+nGwVRcgCvamail6Y2Egs3+JAxaGQEvzA629OlqHIBG+2aJla1A9SbiwseNv1Z0ZCSakaPjf0/UdRejaltesWUKEWuH3iNa7YWu2VoxSAFGFIrquXKI2mLB+IBKsaHsOSDXSYUcoWrE119F/aqlqWEkBQoWE1LjtTQi7IVPartmlXibWoelh6cno1yav14guqk090pmLUf2cEUJJUX7ZCOPImv19WF6lr2ZpCtRggt2SpFGPqKBIqNCTH7dt7KORCMKSwF7FVLC/Qm1N739Ol0BopcFTe3RQ3EWsVKggijGKAAeULRN/wDFGn2kBiygBClz9H2V/wAOtBucfAGioNC9MSx+5iyih1ogj1AJZkKV70OhPQ/okbyCNyjQZCvQMb00dygFgOVKHErgCTJyoYg0zSPO6OvobAIORVQq8fuAuygtUUPcKQlgsKKO0AOCkqQXv1MCyVLA0ZsRVqRLUBXt6Frj0uPQ11pX+w+3I0iRtUnV5bcyTXUiwFclFRxrIPRiWDoCCqmhCHbtWbqAKVSxCciikAxmgLAqrUEIc9Cw4sOlffV2c01r9QFbjRocaBBH6Wu/pwQGvsDD7Glbk1qIt/gJAqOr9XPQC/oPdjc2sT70KRSEsAQSzNyJfiyotAXA/wDVeuvqSTRANWqxoXFXYG1AkFMl0aLZWpcrGlKywM0mVAi5Oy5iSbnQdi96NEX9IQC3tQj6rH0WzlI7AJc4WrlyhB4/hZcew08uBJw+9WkWVx3Ka8qTQmJqA9b29PelLLVqZSh9O4tSfvrkauKt6DoT6ALxH0WBoe4FiRc2NRwGSlCh1DCgpAsoPFSUjS7RDjb7TH0sFogghlA6ikJRieTVa9AkGORXHEGv0oACuBogXd1CnqfUC5ZQPo96YXELkUpUFjyIAHpbp/wNz6+8iAEsFRnCgEMKDNyJIPcNc1VHH0E2FAkEkA+560LUR1onlSSWJnYCWd2QPxjJJIsKVFKPdgxYkRVGgUAcj0HpCt2QVjYytJmZvCJthLjZGvzIPJ9dnYkkOQ6AnjY8C6sn5COoVqterLXBaYC8au1DHJBgsGhNvx7UYWUWbgPc+g6H6P1Wxb9fW5LURxJWywx3oErQW6R9Qo5qA5X0BpgHDclFyqMGpTxHtR48vZlVisUEskMXbZWHFo5SgWdXPICmYGu6CO4xNdbf4k6PQVQfUm5vcvb0b3QWVr8ze4cKINek6SKyOCaDWAc8R9JFG1/f0FjQA4hHamPUA8uTcnHKrckZStEdYn5ARgt2+ZtYC1MhLor0ASVTjGByD5JhiycwNUsxZ/E9o2FtvKMYJksncoilNj0izc4fz9pfReVioYrASBjqpERox2Fmo8SI05DIwiVk6NXv63AoV+pYlvoJA9L0Tcxr3X42HDoyLSg9yP8AjNc3pf2/fGP0kHIN+1+Vf8BckqRQNIxR4yyLRBvY0VsOtWo2q/oa/T6rH1NA3A+rkbVeyEfZRJNMGcYmU0UbyO8lXvQFzRFj6nrXsYoHlKYKuJ8WfGq1qxsmTGRVa72DHmX7YNcVAcOCb0rhXVkKnlQHTj/H9tJysn7rXq962LfbydqkjatRePP8tMVLcDiQD7yHnWaQZQVelSg4JxoBI62uqCxU0QCOKA5SffxFY7CaLYYZif1PSupK1cULX9DYVcimINe7UAWOJYFf/WhQlVZ6KXFiZWsRQUlbG5NqBXi1ACgQA3QnkD+lrn7lPvRDXPJa6iuJvQCCrWo/REoeQCBRl4qRrXvQJHqbVGbUOnpjS0y3HFhRFvS32qpKlyE6GrFjxuWTpL0cLcW9LVDIYXBFvQg0q8mjjEakVmgZGFcmha7OFpjyNqLDn2hITC5L4zRgC5SQowmoFSI4uUaKDVyHIF0sA0ojqXFOZizxdp5g8r+Iah87Z+RZ8WbsC16MUro3uw/kym5SWBNQr35UQIBc0w4063hChqyP/wC1wDSAiOWTKCRhE2upmj7chb0JAq1itKbhgq0ZVFd0UZFrmzESrSkn0tyMPvayqRcfbJ7U9yoZ1UgMOXI13OLt1VwxZQWcnqx+7iQCAERrk3NfyV1pbGrXahaiCKtegHv1B9MdgsqXcTPbDq5tQuPoVw3onslcrUy2NxQIFSPcMw5Kxv8Ac1L9rO3EN3K/ShyUzSd2W32rxCkm62Y0oLPIs5GRkNMZ5O1hliABaibVyIpyQFVgQFAMvNWtRdbMSXv9ysTUeXKsaswV26qSY4THxUXOunihOVhgyYGhyM6eXMw9DgdzuOWonr91ObNI3J6kYg63FaFBTKVIAUBabitSOscr5RRpdqslS5jc/Fdm2PtPJMM42Xeu4l2YtUbWPNK7gppA49LqSX4t+thGASaF6g9415KLlisrIrBqJApmUg8bkJRHAMoenYgPIHp2+5lUpysbcmViKuCALli1fxkNawsD70eVdaRirK3Ev9xItVqIBpZpYqkcy0PXr6MLEiy8egd0pZQ3pbqeZoMFYyA0TYG9uRoML8iGalY8o1+7+Ljzo/yHggBU9wqCBFairUQwMcgemeO2Tkd4i4olRX69K6ikKg/bRY0x4gs1+X3FifSM/wAgN6PtF94jYkcAY4SLYuxhWPK8gnmiLlwpPcPvQZ1klfiT7seIk61q2tiqlMp7SItTOIBkZJYz5fItMQFyk7y5RZZM58eTfsuZ49I5DdwVzFK9XNcmpmJosxrmaVr0L+gJupNhUQ/kjXkh6UrkqO5bmKKnm3bNAlRVlFOSDYCiK+9Bck+9AkULcvcta68rJ0PLqy8lNLxr3PJqJNrVY3U2J6UzRxkerXoixt1/WjxIUlSWVR3Dx7t64m7MASqOv7a+23BmHUC16tdzypUBCdG40AAajRWjv1pughkWPIzmxjP0J6XN660ABWp1GPssGQFJLkhjYOxJYGmNyLgjkWUdYmACt916kVikU38cTDiJKL/z9y/oW6s1xHIAryFvV2PDU/djBQFvxRpwRkZFZD8BPM1S5jAvM6rHO8iztI0m5YYvjTEsfruPQe1KeLd5nSvao+YBIAx5IJdUDduI4X5mwvewjZknkZA3Elnu4W4Ja4vc0Bel+9yOi9KJUEj+RSyjp6YipJQxcadXVopCSAUjaOhe4JUgoKJuQoagLmCE5UkgtJehdT/yJNpO2U/RgeHEgW+5lvTNxBBDOPu6XUKx4kPyN7BaAVaN7elyryujFuC0QQXCtTAijevdbXohKtcBWUYs8+Mj9XMh48brIbnm1ieR/UEqB0Iks9wAL2Rg9Ie0Faxtevb05m/tTy8Q0rNV7n7aJBqVb1oyZAhCjLYlZcgpLkT/AHZeS7Fp2qWYd15Waud68XwW2/knmmasmX/gv6WJJDCoZgioQa/Q2pHKMWLFWj7Y/jpzYElKUhFuWRWSpTTEAMzB+tKQCSOSg8vYpfkTwKECuLgcrVe4U8Tz4SYkwRoSofJkDzDqR0prVYcTe3EGh0NgK/aYyyOzEt7kcgQC1fqPYKqtjkvMSDjhQD9lvtQXU0w62IooWHH7QCKJ5L0FAG6gE9pxTxoB7UQK62HUdDTAB+Kmm9j97DoHJVzyUMzMQbqbWH3gK3IrwbqfQsT6QyFaSQNQJNB2Wu7VxXShMWotYNNcFiSW+6rmo/diSdXIYsh5ZY6zMtqyZuk87Msp4pkSduR2RSWWjML/ABZrfxY9rlnMzP8AEHuKBIMd7Bga5GgRdWKj955ugPE1K7yASq+LzK0ryKz/AHF25Akk11o0CRXH7RdauzlhxpS6IK9muauEYryHI8RYkWHp70OVFSKAYr+rfuFwXqysP1IAPEigPu6GuPJlAMk00jLyPMm6o3IE2IKvTE197Vfk1WqF2SWQ/cpBq5sXXmwsVFyw5r7ejn7+XVrqlH7iG5lH6kdV60SFr9zfZXL7V5UWY/QrlaikY171er0GNMxNPMCeQaukgVWtxHpHTixV5IJpcj8mPNnidsodxp3RI2lvUj85JpBz5SNWFhTbTZ7yTH0WnYlj/jQk+kRsVQqGau5YiRTXWkl40G5i5oObsDSmySkksST6X6m1ibmFuDWkILBzYgkBQrBqC8Kvxq1qINrrZuNdRVy5JIduoXr6ANfgLBAaEZoLxoqGr3cUCrBYC5EUcS9qGpYGQRp3JGRo2UAAk10FWUHoTSsQ1r0qgL2xXWxJaOHrSryHVaY/Z1LMQoYlibCjKOFAOGd0JpWNuP3MLselW4Mp410up40f2enBrRuEKyIwrpRvZ3ag9KAWROJ9QSKI5iSKo5pcZ8nFUxoUY5cZInBQlwtRcJHixcrYTeK+PY3iWNsc6TPy/qHU2N/VY70qqoI50pKmj1BS44FSzqo5AnDSLIyGIvj5E2NkMSwXjwY+n6+/p+v6hjbkwCoSlwpYqCQpPLrfinsLW9Ga9e9FSKJVqt1BK0G+xBx9ASKVm4EBha1cRZV6qrNIoUIGt6Lcrw7E7NypQ3Fm40eANACOrdB+2NLAqDV2BJJq7Cms6D7WPUUeoYpaVTRPCjfgyFVBYElRSISzAxD9SWrqT1Uk8l+2mPT04+gPVD0SUAObgNTqKJtUYYkCr12jTJQcA0p6yqGCtJC8ceHkjY6+RKlxclpMLxbZ574fg2NjDHm1mnTNz5so/WpYUSSSCPSLHNcbh42QiJKUKPQWubU68gFAFgJI2FKSQBcre5dwa/Wh7en63FJ0ToiuAT3LryKqGK1+1u5TC9EBWrryuBTcRX20BZ+T10WrhkuStr0E4qyrdhcItYxuy/a9jXsQAXyTeVgaZlZv1FiegBCLV7UyklVUyyKY2ZiQ3WQI9mP39B6MBxuVPQ1MDRVxXMXWzmTG4x8qJY17sxJCkk0/7ibmrn0hjQtkdsSei2DIQADeibCPqxjVhDFQU0RGtCM0qpTFTUShgKainRk4lWmgkjz2BOzmUPNJIJHDKw4n/CoZji4byGSJVbs8TmSvlSGM37RoIxJiATh0KNaRGt9/MION7knkTwIPtawJQr15eh97k1YXBsVPNwSCrcTaOmoL0FgXFq/eaW4PvSgii3WWJ4hGBR4UQvFQUX2piSF4WtSDrA4jl7nUH7yQAAFV1LMqMykgC1BAUKsD+4XBqxpbKyl2PFplC82B++T2W/JlTkOJo1exYkUwFyFFAuGJkkpo3SvuDelzdSLv+696/X0/T6ebV+4citRfux4zx4rUcRukZpoiB70P2PehZ/SeRooZsbU7PxYexJHoykGZLN/hxwAuuhaLF4MwZeJMINPFajDauKihxcMgCCNaEbMhiVaLqKDA+nS965cQ3sAzn3o3v6H3BW9qCGzEiiKNmTkRRckdEBKlfer3W6uUjkLsGVrkyFrx3PEHjQXuEBiLdWIVi1D97KCUkkiZZ65MqSSu9WZnhbiH7bEK4FiSTevaT7UPCxAiRVaxVgG4REqAhcDkGAoXQ0V4U5ILi9EC3BpK7CqSouzSXaNgi1bozFT9nobf5YDdsdf/AJgFocTRhNQrciv+VKopiRFSZeTFj+lhVhTKCsicG+k2vYg+4QkRYsYOrmu1NH/AgUySIY5WjYUI2NMi2KFaC/cpYnNR4jdqVksXCgt3KuL3Nr9IpJYpuRNHrQP3E3av0JuQCVAJCNGHu7EnlXBVq/Qe/tRuUvdwXR5JhIQlqIKN+4J97oSGYSK8knIyNf0ZQ1chZV5xmIFFciO3Kh1AUogUh26U7KtAnuI1gisQAOIS6kolKbMt1ZwSA3Fj9iFbBiSA7CmuaIZFRCWEbRDsuUdAZHPGiqs0wsdlBgwH06k9asajwsmQEWP+HH/dqnEkMItRiSyJaljLiT9zj7B6N1QfUayP/ZRFqvaiCPoBIon+DHithPFRTmJIY2rs8ceLDfslJUqQDlIpAZAVIsmzYRpe5J5Ch1TmQO4gpubIOgrXYS7GE8lN7+gFyo5UrMKsWqQgsyOAbqwVuR6MLkhiK/i7QJjNoiQgcOXLXN+pXHkkhma8jEXButFgKVuVIaFgtiil3ahxBuDXtTLyNz3FKX/WwYqhZm4FVPFFsEbiyk9tCylb9wsBIxCsAnMWHJudWFXFYc3bJVainkgYCQUyMaNgJlUD0YFaJJ9PGtXDkVkaqKNNzFHBn/4Vbg2Dk/j5kkYxQ4/jkjLVGtkeo/8A0EG5HGmNwPaj6dfQnpJfkQbhSfrNuzrG7ulcAiKMl5YijlFCYxsuT22eReyZVIoqKmSL8nbOTkniRH6C7p7GiG4qOIDilspHUXF72NJYPOsahulNxtduIJWhYgO1gTytRUlZFZaAJB4lSzBbXAJspKqGFNcr7AWodGXlx91UcaBNXVaIJQyIIjJ2w7WW1qQKfSEASEoAouyLIW7aVKReMo0SNYXHGyVegrNUkj3uaYhhBIi0GvT2BUgLyYCVSRIxJ6qpNzQt6aLIjhw1zv4dnlJmZ3+IffFhTDOwQTLJE7CUW7vBqiuaMTV0vK1zQNjf0++h1qUlEjmSNCCRboV40UBLLx9Bb0VeUOhyP/klBcgiNpnaaa0feVikrqJHkjMoZZBB+6BeP407NJJQ++j95UIHGVhtqrE13DQJZSVFE2oEgn39faiSat6C9HlRJPp05AMtSEmiRd14gklAAqnogvyAAA/fItDgaBa/3EC1KACCRVgQJZDHI7SPe6xEWu1WPK1Rg82bk9+mPbtqVDlg8kbMFLcVuSxIAdr0BRUsAL01qh48mcXPQ3vRANSyFCSWP042wyMVcraZuYv+ONyja/PGBlJHG4x5YnWKTto3OgWFF1anDQmifQkmubmr3phZpPvpYyw7RoxEVxalUtXaFjYCgeNQMCMHKOHLj5McgJAkZhGXVRQP2K114/yWs7c0be5Cw4wZhXJrD91J7BmBtQ5EK3Kg3EAEPzJoi4PQXWw9P1om5WwClb8WII4CWB4GewFwykMqsykN9gDXpvYMGJCsqgXx2RjPGqsHYqKIALX9IxduRsCRQNkYU7h41tc/dIrBW/SzOiySRP3nAS0kacHrIe5/kWm+1bhipst+hINNe3IJSESFr0WHF3j4sSy3AES4ghJuf/BSTiuNkT4zY+/ZHjzcSY/j0YOnaIMrdCCPQ9a+5jeooWkXkeFr0ALqIqKKT20NCBrNEwqWIij0PFqU8WWZXrDyptdkYuxxthU8nZd+sUUqtCrcaSZ4slpC2Q0sWPFk5JyZ6jj7ikH0T93ViAQeNmF7JZndeNKWWmYkCgBcgcfXrfoWPI0CQY+wTFDLNS3ZQK4gkkcGVRCFRvQKQfYkrZQY2JJXowUlfRR1DWaQBRIgV+tj9pkANcio/wDWTYMP5HDIEynmjXKz8SfV8oyHKIJMqhITV5CqD7+ANNwWixIQcUdwtM7GhI6VzYAm/pc1zaup/wDFErqBN1kurCZ6aVGDr0KlWoX9A3Go5pIxY3CcVtXNaNjSIpPSlmlFSKk6yQ9WQr6pKy0p+/H3WSpTIjnrmHmGRHHKdhjxPPubVNkSTH1639vW/FSOhbopNcqHAEIVAZhUdyqlSSbmhb1N2HsStqDmJ1VmDcTTSc1uLAgtcGrMK6UGBIYiiFtYKGAVuK2+6MHgRf7uV3a6gxqSYiFUEE2JFWvRofYxYpTS00hId5SSCSOa0rmjIzF5mKdtiWcXlmIJaxYkkren/dxY0L09rXLf+RKCDY8ioAphdZHKASsWZ25pL91qVbBH5UzcaKUn7aHG+RkGaFJAjzob9RRCn6FldaEqA/l8abIclizGiSfQAn0AaijrXVj+pY1Zr1/IKFFuBDAm1KSZO4SzMqi3T9K9qDEMw5ErIxJcEXjZeHFFdSv3LGftA4EKQborOGVuS3Bcqb033sDevtpv4wTS/uiR5Kb25GzEgchdSSzNIqkk1evepLkXapP3sF4gu7RxsamcczKxPdY0bXPEH7SAQTYn0/GYRGN0/wDK/9oACAEDAAEFADMir3DKE5cXk4lXDirCitY0zK0TDje9Z+F30yI5YDI1lZlJsLozgr95SIynVaR42jTgoawC0GN/0+sC/wBMrOobhehf0YgBpUFSzuxFjXIWY8mPQA0khSlcN6fovWjY+iktQJArkSKJsOdM4Vv3UTYP3HXlxq9q/cbgqp4BW51cWJsEZJBfqq9sXFd1FZmNFitMQBZTQAB/a3W4op6e1BeJ96A4g1I0wbpcWFPYlr3oniJ5Sxdipdgy3pVqM39A1cgxLdMbKaFopRIFa/pb6ev02rlmChlFKSdWLTJUM6pKAtj6MCRiznjc2LA1l4cWQufp8iBrurCN5Y4dXkTHH8eucbVQQ0AALehtegbfQsbOSCD9fSha/oWtUsgSpZmmahXQCmNyp5UOoVirKwYXoGwFxX3X6WQWAN6T9zEKDIGR34jkbknkWZiHXuUGVqy1maCHuCEN9sZ6c15dCI1WNeho8RX6viu04NqblZb8K5NS3LdTXUEixoG4HWvautXqRwtEMQoIDobm16ley9CSwX1BRDBGr0VKvSHq1jJK3I66dmjBsbg+lifXoT62v6tE5fiJlyMIhwxFczWO4lj/AORBIpXKPFLcKfshzcXI2M0cbU2LA1R40UdKka0hHoGYVc+vtVyKNr1Y3wdTk4G5dubfV0oe8bSGr3pz0lk41LMZmVrFmIazGvauhp1e6i/pYmo3KGiA1G1he3SwvQNyCRTqrExqokIoluf6K4auR5dy9IRyZwp5lqUi6k8vehZQCSo9696NC9NMismRESQtrrb2NzYWtyHoHFGxNOeAuCGq1WN/anj6FWAyX+5h0pj938NQyI+9lx8TslxNjNYoGK1ewWzNqnYyKQ1LcEG4orYfSPdiF9CI6niQUUeM50QAPEx6y6wuGFdVBADCsaYBQ4ARYY5eS0zdAQSrFaupoHjXMV9lXSg165mlLE+t+llAP02qxq59CQCTWbOSqE36UTcjlVrl2sqnmDzFAgnrVjyjfn6CxHoBekB9OYqRAw4AHpZvuBuCKVuJU8aJvUYAAuW62q4WuR4q3I+rdFLdWXuVjse3Y1arigavRNhblGoIjvRvU+UkFOCp+8Ajt13avUn7J/8A2m9iLejswOfgPPLDm7Dgkoix3m5ejW4qLHVm8pkSJAl4x7Vej1Nje3qPS4FTFjIZWB5M5aETLko+OcEhcccbGSwEiGuQY4xKTejHiC1hXM0WF42F7VarH0tQNiH9enAhgDb6jagbtcX6iiSTlsS7CwFcgavXImiASFCj9fS1jB1agCQF9ACSLCrk0bAN+0exIHozXoGwLCgbikCEqV5UpFOvNZI2aOEGMe9Gvf0ljZW/WFCCSC3OzBgxt096/S3Vvf3r2NwS32gCwYhQPuZxxPcJGTEQbdSARdbENIegA6hhyooQsTNy6Gj9tadL1PjR5eNjRLjYhvXMUzAhfb9LCuNcDVza/wBvS8iLJQjiR57BB0OygVcdZ+0gyJyzSzE91xQmcHFyCJUyUZVa1M4YAmQ269wkcvt7irX5JAGSLjIVqGQzVHMLoea0TZv1yosmWRnDq30t3xOShoqgI/dYkFuS5fVwCKT9prlXOuV66+nX0AuyHgw9FFASd0AUL3o2NGwLqDVlWmHI8rAEj0UcRX6IOTAg0ouS9FmMvIMpHEGwPUChzBtyaF3kj4i7BEp3LAmh7AkAdKv1FLe5tf8ARlHcF+4zKp/lWmADOeSMLEmmU2ewri4oqRRUGnVSL8wskinuArrOKRkg0PS5tSGh6i9dT6xgMWKUE70ii0m2yFcj2LE17Gvase9dVqDIvRcEdKIuAzqhYLRYsVPQAVcUwq7ihkuKx5OYtzr93pewWiOljVzRBFOTYg0CSclcuSVyC3FbZgs4NXAFyaYCgBXEV+nt6fbQK1GtlprCrdbG3qQCGW4dQVFMFAtyoKASDewJtQBKhSKXkQDY+5ANAn0Dm3PpcMfYF/vMhLM4NF/vkYNTSui8iDA/KpCVBcGga6hrXHQVJ9tPJYl0FKwEn2BbFalBEsiBqIIp40auK04Kij7seLEXI5hscFFV7lT9oBPqlf8AC/oauRRIosBQyFC5DspJusUiwjPyDPJ1AuBTyfdclFYVE6qoa4RuJikugJY8jdmW3Jibm6Nx9F+x7qaNwSbGNirIwcA39L0oAHtR9Xo3IPpKSK5kHKN6V1Y+1e5HWrD0X3osavS8+cMjCgbi625gkG/oPX2ogimjoLxW1vQG44khUvVgoT9lXHIhlrldb9fR2U0AAVdQDxoGxNzS3sQUSRCB7CEfykjlZeQBr9SenuSQa4C7ktQ4NWIiYrlRUyEqpLAI1Mpam6FgBXA0UueIFMhYQ4qIsEgCopQxy2HPkApPonUfrVz6cjyZr+hdDV70ZYY2zNh31X7pnbgDynqN0iBymlpnyCAJDQd1qOW1RTJFWvlhzY5k7LtZqa5NrUo6xj7z20ogX7T27ZpUZqx3KECluBQNjXtR9luA5NEkiwtepLWZy75C8l6UPcFQWuAB9oNBbFwbkEVawXrV6hLhwbVdK52I6Ek2j5SLRBFN+0i9NZaK/cUonjXEKLVkrI0WEJgvQV0oFVpbEdL9R6Ek+g6+nsAbEC5VTZkYV2luABRvf9ARxJvVrUQDQW5HUSoGURklEcmROSr/ADq0AIZCvoy3Nr0wsaEHcCQKgYXqBbsGtQNjHJQIAodBRt6FrepIFSc8dZs+ZqWSXIf8dVWVlRYYI5guvQhsHiJcZ46VVsAKPoBzTx7FyNfjSyM71cXvSe8Q/jPSnvxjFl9L1G91v1YuBX6ejC9dCb17U/7HIB+4iW7Bo7jooCiiL1a9WNAWo9asBVgABcAg1Hfmfdsn+RAb1Y1+2ri59zTdKPUkX9LA+lulXoBTXWmDCkNMbLHIz+hC39OQFXvQHQgqV6lhyHtUksUKRTJKgFhxtXUUb0etACltawFNGhpFKUFIIVY6eUR0yKRJCLSQMtNHItcHJXGNLEBR6U6hhAACvSiLNeon5AKpPr9xpv3Che7tyLJjzJP4/g5JyNEdfUxJDoGdVNLLxCzyFgySCeAwySMyhwoMdcDWGxK/8mYXBodaRRZVKn7zES4r7o6AJHpC/wBtga6UDRN/Qm1Eki16SVHluBUjkFxc487ZEbo/IRhDJDdQGQoXEvFmpbXFGwJUight0FEWqFCTxAPZRmrrVunT0JJFPVjXtXt6hQJP1uPTjc262FdKIANAWF7URXRBcehNA8Sxl7KkkbTDfOxtNhy4cYuQbPSu3E9VVqBHImw5Eh73bq5dmq0pWL7ze1EinUvXAMwhBPAgdKb9zI7VF0CCw/Sousg6U3uvU10aiADYGnBIZStRwu1PFGiPHHk4+1iaKRmtSN07lgjAFH4JMFyYweJvyYWsxsMY8K/U0tDqFBJMVSzRQI0YiYAS1J+0e9zUHUg2oUKNrg9PcJ1C2ubgytxU3dnpv2tcGwo0UVjJH0VWICMaEbECFy9hewNWpVLBelAkt9H6+snt1NWoEuPX9b9Awagb1cX/AFrqQCKIFlFgAL119PcXUrEbN1Wh7n2ANSXLpGA46jrcuq126ugZUKysHWv+KkgxXDXJq4o+xf8AjjThTspoi1N9tMAAnQFuVWIA6GIff9JBBHpJ+7IUwSHIbiZisu1xUljmjIZFsOPUDhXcaVgeLZMYU9RXOozyIJUdxLEghVNRxk1FV6ZQ1KTYfRCoAAvSihZa61bqL8rGvYAnjJ7v0pRavcyqQo9DyqwIt6LbkchvyZIkNCImggU+gP2i9FgPqJAA/ZYrTHpQqPlf0sxPH7bUvGr0Tc8hXv6jpXX06+nQBELUo4Lc03cKFAVZlKKLLa1CWw//AJbUDW6kzI9nAZDr7MtMeVRoOVe9SlrqeKPJyos1pOJBJNEcgVIBFizciDY45vJer9PX9y+jKWI5tWXI6VjyOxii7q7LDVZWZRQblTqwWOEgu5BS+Rj2PpApuAxEcdggNBKjFWsK/X0BFfoByKrYWFcV5HqL9PtuABQFvQ9Fk92vb0lK3SSN/SxI61boa6UouL/QOnoGIpowzXb09qFqJ40TyPK1FiQwDATMKQkg3rpckH1BuL0P2iivUAD0/RmtXJqVrmiWaRWYgniqcwL0P3E1JfksnUnkkillDFSDX6SY8GRRawBkq0jUFKm4vJIFp80Cl2DqUzv5oM7Dy64Xq1qF78yKdggaQBY2BOBdgRYj0Nr0OgphYuSF5GSpoIZKAjhoOCNrDeGVSrjqRjM8nZHJ4I+MGMgllPGcBXdAFVVtEi3pVtQQUBc8BZgeNWBqxPp7VCCW96AFrXo3BBNEX9b2riBUhALm9dL1IvcSCAwUpLN71+tE3ocrX/wWpWJoEGm/aPZWvXufSxLdgEqVUe/pY17UetBQABc+n6+r/voH7uBKmKzqppQCtW9LmioapIInjhURRcyz36npX3WF6FjQ6iNbj3E0giRu45cCmUK6y3llmaCCDLdFiyYcgN9lO5Y3IVLW5cqgi7Mfpckr70Rej+9v3P7Rh2CwtPX40Qrsm+bAXhyNe4aPW9upIzGVcJQcMRISTeRoV4mM3Ye8QFWoKB69bEAjhQWxYUi8yiBQB1LFRNscqbMVzJiegJuQaAo3JnAFcjYersAOYBodR70HIKm5/Wvb0INvX9F53Z2uhr77uOpo9DZi3rcii6qbk/QjhipuFC8QeVfqDYnoZByoq3JVNcm5KwSmAYCygVYULA2JqyU3tCJ78wiH3Vbn3rpdTxDBuKkCiyqJJA7EhiQC0yOEJ7ZaSYEyKFDlDjZKOJV4UAtlgkesfGWEeo+gfav7mqGIsFPbqcyc/wDnmyOY4YxzJQRyY0c0OZEIg00ahslyioBSoEpT1W1D2W9+2goxVY0oYV2hdlILRtyWMWVAtcQCL3AvSaXAXJJLensJcvEhmIKn0mQMCLF/2m9uoJYX52a7F+Q5PJSAS1a6gC/WuJo9JAOlH1FJKpdHVySSa9/Q/SYkeT1JuViXuCwq6WCkD39CgLe30R/uutHp6Doej0ptS2FWqzim6gRMKANKCSyqXUGQqgFD2yGXinEqoK0TxpTFI8uMrU8DqxLhma1MStQZCSxx47S1gKYRlM6JjyrPh+o96IvTEGrEeg6ekxvVmJz5m5o7hVf+OSYIMlzKsw4vEBK0dljjtLFEA5FyYvdbgxftK11rhc2agoNcVrj1sK/W1qB60Df0/TK1ePlZRVmlIt6zRCxDoF+1na9IlqWwq9XszM/DDDFlBCijcgcrsTf0Jq/qAoYKoPU+tr0QGAAQXN1fpV7Cr3BICmYUuVIHRlaOiSEAA9bULV71YiipAFiQetICq0LisvJaFIHMkR6AXq4BaPkelRqRQAFD3/XKIY3FE9V7hriiluoeFGD4wcPgAk6/ph4oQnGV4414s7c2+pv2kgV1NL1r8igbiVizNIyo0HOjF/J27BpvskNm2MNkT7AGWygmogBQXjUZIoW58FkUDqRYcQat6e9fpYCgDX3EGgLV+vW9Egn6JYkmSSLnU8faXk1cmAuCKWJmKxoh6qK+1q60bejLYD6AxA6fSD1puPH2puNkvaQXjiVgtTf+uxYJiyM6IEHO7KStMAK4GzKBViAR1A6ljbqaBt69KHWpG4AKkiIAtXuW6re46VfiaFXcsbCpmJelUNQYml+0hiQCBQBFFQQirYIooWON1t9b3BIvX2+nA8o5DGvb6vZqZQyugIdVKjHN5+1jVm7A5OVGqsqoK9hCBwC3Ma00TRAHpf7V/b9Fh9Ht6ix/wdaeIun4hLHFVguOooRC6hQ0kasrdR1r9Kvb09z9A/f70v7fTkL+gNvToi9wXrmOHNLWDAY4FIgX6Paudgt7J7AElmUNx6sbH3pWvRAFW9QbU9L7+nuAAPUAU1+MpHMGkKghFU//AMl+RZqABK2jriHoOrCCxiPv9JoAsXUimW9BTfiaj5FJ81YwdlM1YuaJCGLVdL5UsaGfYkHNnlZLjnGwq4IhAYxr0lPbiXIYlJlMImUnuoSGvVxQtR9rGnLKiA5GKP20Sa43NA1Y2+sKQWFwVtVjVrH0Iu1EXA+4lww96WVXa1DiqyE8n6C6Wonia+7mXMdCkQL9HFfSQcaUBaubn29QbmrmrkVyJJAT0Ny/6jhSc7+g6n9QnVTRv626gA1+htc9KPtKqrKehTijc2uLilua/wCI6iwdlDlmBFY1yG9/qM4hEM8WQZY+2xAPpPtGYnOvQk5uj3WLIkjpp3dpJeaTLJzYcgyhZg1gjkGA2eIizNcJGO53Hrm9K8tLkSoYsxSEcMOhFdbCgvGibmioo2UODxjDKP8ACxsL39ASPR+XowvTKAFQqbevIF1Ra6io+q2KlT0f2tVm5pJcEcQSpaiwX04/f6G1xa/UURXS7X5evSw/jrl0YEN1QkF6j6imN6BIIUhm5XCgUerW6J79L2FC1iAfXIjHML/JxRqHIVdrKxFKBRILJyul+S2Q4zExD68nIYz48rrNkcSlWo/uW5KclqKc2MpozMEifpOqkTR8EdB3EvSi5x04I0vASSlqgQGgbHo1HpUs8WOjRqVi7kLROJBXQk3sbBfQGXvf5DYg2AZSPU3A9D1riPoPEsyXPtI5kWu9UX2qTGaUXWFGWiFWvv5kEkEGiAfQ8rUDYk3NXpSooFr8ftF7enJrlTal5UejXsy+w96XoOhr9KK3KjrYg+5F7/crXBpT1rJjDBCxoKDXDkbXA6EG1KpckEHjxETcqVe3j/Xk4olOPhK75EvJqvRj5PFAUpY+YELLSRhVCIR2mWv5OGdIvfQtI8KG4Qmi4SMvzKIzUigLS9AjXPbR16396hcI/QjiCSSaA+0nr/lDAki4P21ewVuRrpR6evE8iDf063PSulOekgPNQWWVe9HDGYEmtVyrU/7Qtj6XF6AsPRSLBiCvGjewN/oUXHbvVwCpa6qUoD0JAUHiHbgR7fqRcFQBY39mvYkm/W4IvVgamQK5tRANKLjpcCyM47bCTihPCNLnIYf4QxHp09I44pCEDCOEle06BrIe6lCQNTkoubyllWMrSIFW3QsOIVWMAs1C9A9OtJIHoCvajWO5cHlf0NWIP+QIb09PZlCkFrhuhAHJytvRvYsTQuCQwpyWUuq0GCByXUgqQDeQJVr17v0Nc15Hp6EC1cVoACmNheiegF6ePnR+6ltYWB9DYBXHG7irofQGr0A/NkVwP22JYN1r9LdAtqN7i1H2UEULes8PdDXU9oXFzUiF44yII+gCuVofamKAIySx+u/06/YDEjw5Y8mNVBAB4fjCpIoUUI9sjJ4Iqh3jH8q9WccUaO5qKThQIIFITdQC0riGuL9uupEDFZAbi/rZhR6/SP8ACSy0/UXNrcq4Gv8A+MdPST26XPufRX5sxjcIyoBauBSiJq//AI+Kih0rhauppT9zC0pu8apZKZXdvVP3fcKSj++pJEiUoZBGoVVFgnC4vcL0rqxK2NKSfpf2BJoDrR5A2+iaBZKjWwk4KD9tBgT15G4EEJmDuG/xj3o+3F4Trc0wx6/NjnURrxdEFZWdjxDI2bSoWaRokWoIVao0Vhki0buQ6ODS9aiNqjlDHDyu5KSWfcYGTsYMQGHCND2Buy9V+rpb6QCPoBNwSaZqcdPTmeRJo+/S7nqTY+hAYf8AqruNVh2qQstRtxDSfaB3I0MhLX4191+IsFUD0BB+gG3oenp1u8aSBCALU7hVRi9e1WoWuqsDYXsKsfpIN6AsLdPW/rIgkQQOhIDG92XrUOOzF35D/MUBqWIx1jbCeCk2+SwTMyJBK/I48YY2PcVeKQRBYwLVk/tkN3pG5KCGoMUpWDBWF1JBmzxBkEDiGqIAyXsCaHrYUONSxRzoTf6yLg3r2o9acg0bhj1Po/sbmhdzRHUggg3FuvB7/qWPGiTSJxAWi3Fr+pJP+K4oEgEXI60QQVC2AAJRWoALV7VEjRMknKRVsLEn0Fz9Pt62odD9PvRRTRgQ1HHHErMWP1+9W+jr6tPwkk5c4Ii5x8Qgpi8YUgRzmvFjxhrDDiaZgPSf9ki2ahIVpGFC90fqpsUYXMSSODyALGsaMFiV5Wrp63FfoCG9et/V+5zDWHMV93Ekn0LE+htbpZybAg0ZVMxBtRcKeXUEKx//AK4pleOo2QejIrgROaZ1T6OXJvQ35UFJ9LXW/E0LilqRZDQFAcmomw6Xr2oDkQTcEmj9IIPpah09D0P/AItr/VlQRzVFIcY40SSiGKSAxxg1k7PBxCTlTvj69nqOAIAoFMFUSC6ZFlcG4j/aFAUPYLe0ZHFTUbkFGoe8ICoIkXIub+hPSpVZ4tfFNEfpPKhY0wrpckn1/X0UU/3MFC0Y15EGzWu68WTgR99LwFBPv5AU3/ujBeTn1ZA4SKrKT6Ag0OtA3X6OhHSuDURYjoAb0OtDkQA9W6gXNX6GxPsUN1rp9f6fRb/Of8HS1ZWjkWpsXJLQazYRknfIw1ewyqg8fC1DrEjXtJCJcdlj+2mAY2uc3DLKquSoLUG5BHvSsaB40hvV70OlYyl2II9RV6HtVrfR0oEEE2Fl4lWZQetD7iRehe3SrA+lxSrYm9EXB+1WvemYqWEgqMkK9cQC3NKEbAFgtdFkDEUPamswXgoHU+woGxjPcFCjyPoOpBv6k2Nun0L7te/+U+wteuv1H/D7f4eCGuKmvcj0vWfiNkQLeHCIPoq8q7YYZmBeivbJBVke9I/EBuNLJekBqNGc48YjUm/p1ubeisWPT0ufQ2ogEKlixApONAVy+3q1AWBvZiwoXPoLX4gGxZj1rrUrqqLkgm5tcCh/7CgJs0bMbGPuAXF2UkgtZVCip2sF4ghitKbgniAWJ6eoNj95r+Sl9/QEg9GCktXswNvUWVfrt09BUTu1H0sOIF//ABrf4vcMlEEVxX0AJPtWThRzLNhzQEBSRyJFwUilYwYjFocZI/p6Vk7HDw5ZEKH063+hv2j7FJJYs1vQgH0YkV1s9qT90gJNWNTESARNyA6MA4Ik4AM44OioK+1AbFY/2esy3UKbjq55W9wfeuQvQHVf2oSBzFD3uFNBxb29PaurH3r99XJFX6/V+hve/T0RizFW7x6GuJtVvqX93+L9P8P6v7We7LZDa/VG6+jRiQT6yKUDVlDFrRyiw4YwFVa/T6ZtHHlZzuXPpcW+jkCzAlpLqFYlf16mhkxCQ037QDb9WegxAJN+gHRa6GrWA6B0NinVeddtBXHiyq4H0G1GFCQqj6HVrEcV/Lh5I4da63vauTAyQcpCL0CCC7ELfj+p6il+0cmIH+W/X9RV/Q/V0/8AEvV6/Ui4Y2Bk5F3DUa/R+FRfvsBQCiltYD7rhlJr9PWw/wAINjFAkDWJNrimB5NcjF1865Jk5UzV+6iLVc2oi9MxuTc+hvV6DEH2ocSS16F7fSLij0P0Z0jBPasVisntS9RVzQNq/eDYspF/S5FD3bhQux/w3q4NdLj0BFfqKtZb/Rf0t/k9vQdfpsKvaia5AUXFNc0R1CAt+voHAockY0vQWsSRY/TeupPsfUfQWtXIUTc+nsGNHiCzG8bgOy8WNE2AJK3NqvUjcBHJyUdVo3Roj9xAjPT6rOX+ge+TGJYwAtY44u8lyJAQGB9FUmi1lkynkePIdHiIdfRfcm9AmgRxo2+pupdwK/S9FuIL/arhhf7rmhYADiTX6enWxFj6EX/wk39LfSQ1NcCubUbkEOtC8jMpQgkEMwNdadmVvUWribe5r9P8RYg9aPpyUEFQCxNF2NMSxI6KBVxbkTTC9MAKcBz7UCCH+4WuR/HXN6/5gFnRRb/CCRXvUkqsDJdSbn1V2WlkVq5XEoDRLcCsZeEfqL0t7i/+CRuJuWF14dwGr0AxUnjVzcP16UvuRYEW9bEKT0BseRt0q5r2rqTarD06/wCK4FXPM2uQRVugWzmivGrUqqo4G5t6AkH0LXriL/X09elAAVxFW6GwapDQNq6+nv6EA0oCBiQELNMxufQUTemAUOBdehANRkmh0H1AX+h3C1wJP/8AH9INjGwkFlqXEDNDh2Zf3j9369L9DRAoG/8AgmsRcrQPEcxXIEFmJDGjKARKK5XC9S30DovI1cGuPS1A2NzX22JsOZoNdrdPS/qCQP0q4sf/AG03uXHp0pZOpsaHQkmv0/5eiEmvb0BsWriQbUPXr9DNagzVz6MVIZgQ7WHW9G972H6N9tAAehIFWXlyNqv93cpr39/Rm4gG4BsVZW9D7/SBf0ZuILFih+2S9E/ZY3+hWKsjBvQUvQgnkjBqbkAtrOX4BjZW5egF/UWvTrcT80PdApX5FXUi9q53FzbqKXkwX7abofUXqGWU5H/Ekg8momwDdWl402UFJyr0uYS0UyyLarVa9WPpe/oTc9DVrVyokEBiKBIP6seq243J9LVehRoMRXsfQXvTe/oDav0rgaPQFrsB1tXWrjkwuGJEgvRUs7KVYKSQOlWIp72rndeS0W+72JJJ9Ceh5kxi5H7qv09D7+rydtHnclXJP7wHALH0v6/qFJEDi4Nwn7utcwaXgRSnr9voLXLBT9PvWVAWplKEvag1CQ2WQrXNgyEyNDAqnk1dLfTYehcCsjLVKbPZg+YSBMTXIEiRucM3GsfM5FWDC9e1W9A1q96Y/XKOsQBNC5DEiiOpBHoOnoLH0v05GinSy10uB1/W1xcCpJFUtKL9/iFnF1lBpjdmdmot9zdRy407g1f0AvRApl5Bxam/cjAFnLV3JD6Xq/IkhSF+5BYRji3S302NM3FZpHNGlDULcQSfqFqDcaiFnCkEhFou/AgcFHKv1UXoW5c2FWAoqrfUqIpspEmMkgm17CjBKgLkUruzQYcj1FFHECwP1La59ywoyBanyiFnmLE9aJAEZhkUqyFSXkBeFw/MYuUVpGDj0JAruCi9xRIA7gpGD0enrcVbrRsaVwx4iutKLlxV6PsBYenI0ouelcrVyY07cRLNzrugEsWIsKL2ImIoT9UlQgOK5cqBq1iRY9adW7lcut+VSL09R7HitFr1ZmES+jIHC3tTtZ/UWoC5mjDDiykLaja6mx+rpaD9w9kBLWIUfaCov991/bYn0Uj0Fv8ADYUYI2pYY1HUfR7g39AK9qJtUrgmSWxnlJYtcyy8KUHkkQJX71BYSe4H20r81w5+YBBHKnkruUJTd5gBLnqK/PU0M5KGcpKZQYCW9K/Kl/c4uFW9BLGiL1YUw+2gL0rE1f0X9360DaibVPKXpmVKsxJot05mhy5XNBipjk5UDauVAigOVX5G9vS4pHD0js7MgJaJlB5AjmKWItSw9QgBHEVcent6NGrn6T1Mq2f9f1+ken/8cA+5RyPSuYgXHzYJ2C2oXq3UEilJ5XAA60bf4LEfQa9xb16XsaFyCakNqZr1O3EueVEArExlaKEho4rLOoCTJwYOWVW5C/FozxyVN67tE2oy2qTIRaytgwppi47hoSE0srmvy5FqDZOrYuT3gByNfb6gW9GBNcSaWwPqBeutvTJm4hpGUAsa5Wp2vXtQ6UhNyFtZrxk3VwQPc+97+l/TiweKFIRxUGwoqCXRQ3Ecit6H21yLBgB6BSQwA9At6HG7DrQBJuwVjcz+/wDh/wCEFdeJJ5ZETzxYWveGUnrVz6C9DoPpLoCssbEi3pjpLC3QEixrp6H0J6hiPS/R/aVuRclRI3WzyHLUR4+At4VCqQyscoq0WQFBS1RHowJCXMie3tTyCpJSBkZZkckmmYCg9K1cgDkMAjMQNTs+3LjTCRPW3T1YUBQBNcQADxJr/jRNhIVMhuWuKZiKNjX68QaChaFAWAqI8aC8SrBqVr0PWwv6XJLnov7SLegtXED0K8SCDXE3nyBE35TXQq6k3PVj0tX/AAyDFYi3qOfOgbE9Vq/VLs0S2FzRN65G6sCT7i3Ouppa4yd9fb0JuZX7cZYAsedY8glxqJJqwNXNvS3UjjRW3oKvRN6uxDfa2QGoxWAWwy1LQYcxiVG5Be2izOskmQ4eZVsIVNiCKhB7ii5dzZzZc7JJIuC7gCYmxb+NZOkz8S0t5ZZGBMDNLpMoilPIent6BSa9hXM1cVyq5q9e9EWo9RN0YAkM1iR9w9iOnVaBv6BSaItSm4Qcgh+9Pb04krwai12Juav9F6dQVItS+9XJOSp/ICrbGBWCgBQNAXJ5EiNi86XHqfQUTcqrMYorUVFEWNqtelUoetIoApwxY9DQYW9qVwfTKUkZMUskXFkTCUx446H0A+gDlXS3sa/Sr9OytPGtnW44gUR0zYhh5EchVUkeVwBjxjqeJFRoVFjfHBMqiwrIk+xi7yk2qRuR5KA8tqF2JLF1xmlQa1yuPrgA8YiXGkEkJq/oKvV6P0X617Vcn0kX7jemFlYEqGoAiul72CrcAAVxBoRmyKQSvWNw6i9W5sTwqxWiFvcV7+nW/uBY+kzNyjLFgtcK4VNHHLX4oWlsaub2v6D3lc8RcqTenjWQvGyE9aFwKAuUjLGOILRUgCuAv2q4laVaFrCxP2kfpy6MVDfrahyHpKCyv0KQmSgAF+qy1yP1e1CiL0ws0qkFiCJIo5ki18MZ5LEhvQRjSIEpelBDyxkCkezNxGWT2o7E3ssnsWCnrUOMFMeFYrjgGPDdYnw2jqHBWRNQT+N1q1W+q30/8elTgXEa3dQDxvVutvRV5V1DAE0I1AsRSp1dOFCMlrCgAoZeRYMAwDFlJHRQA4Y9fS3W5uUUkLxr29L0LkymRKVVSh0b3riRRtT9QLkHrR4ija8qKtLHzP49JCBQVVqSUxlWLG1q/QniLKzXPcLWe4oAVyIPcZW7j0jNeJxIFLH0BsZnlSV+PL6Gsq6/OxNjKff0v9Stam61IOsqXDA1wINiKPQlFNcEoCo4g1Y8JZljVQAPTMv2kbqzCiSSkUhqKIgY6B2giVhFhI1CJXabGEUmKkax6pf4v8IYgegoexqdAat1mBrEaWbFterLRCiuporah3BKn7gCCIyqsvKReXH0UFjRtVutWH0T54BxstZiwIMjdpIpDMhHGudcj6D3var9RMrSEMSXspa1MxBcuEbqvRQWJCtXJhTAMIY0SrXQMGJvxBYD7iDc+h5KSTxvQNqmLvXGjeutgaFvqsLYmFj4b/4r9CL04qRRcqRQBNFOIrhUUTMYsVSUjCAm9fZTkGsoMyF/5lJaog14Yi8eNDyGHiKskUKCseBykOOi0+P02zLg6nEiEOL/AJI+6tAE0R0spEkLcnFjxLUyMKtRAsFAP6hS1WsIwoBuXCiw97UTarDiz2FiQRej7C/p+nElp4jC+FEzzAWNwaAAp7n6CbD0WNFlHvblXWjY1yNXZavWXkyB8FpXRKJsLgVdSCVB96R7MTcmienL7eVmDJfvLYMb8zdZOVDpQ9vS4v8ApXvX6/4/b0kiD1NC1mRhVgCYmYmICkx3cRQKi29ParGrXqRbrOO1sBBGjY+ODWLFUOLwaFbtjQmWseOUmJWLLFdd5KMrbH/MtA3rrRF1mi6PESpEgqRO5T3dIiwiVWUqHVwARZSp+2gpNFehUVej0Drdea8ZLCowsaAXJ9ZI1kpERRXRaL9GYtXT6OQJ6eityAvcWI4jjVz6SY8cjLZEU8gBxoG9e7K6k9WJ4imvyF6a9pTN3SzE/qoVavSkgiQFo250Lk26k3N/pufo/T/AKIBpkXl+OhIx6XHWrAC4t0t6XNGigNbjBLNhSF3xYJEfETgY0dphH1hiMUGPEOIRIzPlJrsDXxuU/wAwpBark+nQ00YapILMVJIQ0FuQKiQsVQIAC1MvUCwpgG9LESNKSeBooOfANRJNXv6lSKPSr1KCwFfpx5KfRntXM0G4gsDQdbXt6BlFG93mCV+QwpMgUACealrmlY0T06IPf1vdmc0AzUyOSo4r+goEmlBAjLcfckdfavah7V1/wdLfX71wFBKCkirentXt68CKuBUkSOmxwpIZtftYpmYOBhy8qxVDl0MlFZIo5s3E10WVscjyPLNr/wCS1qPX06XBtXVj6WBoSQ/lmFTQheOcoGCAcQfSwvTXtf7n95GBWOJI4yWszNSEcX/ey2pVYD/i1EXAUCpPb3HQn2pjxVmPD2j9BeyuRQPoQCZ3ar/atx6Y8v3dplk5Ch0NwtNfgAa5XBNOerkXCqKsat160eqrSJyoWI/QdKvf1t09Af8AMfW5vb0FXFi16vyCnoycgQRR7hp4BKudpZBIuw2GLWr22JNWLmYsaZXlWuwUy/K9jmGDX5ewkiiSGP8AyC9ca429Onr/AMf0oCrG3FiRFQ7gFdAQLevG9EXDAuz9HA4NJJzVFkARKlqxseNEAV7170TY/rXWrMSI663FufoKVgB6Sk9wD7rg0BYxgGR/3XW4tcm5HVgLDrQAVWs1OVRlDKCSaA+6xpRYWqNARboDb0sLetun/ie9MeNM9l7rmjMLGZyR7P8AcxXjUYaiiyLPr45qm8ZLzDx2Z6xPH8WGosWKJegH+IinmjQhuh/lDOWom1XHEnoOg9Pf0tRFxRANcRYqOKG6etrk8hSnmzRjnYMVQKKblci5Rqe6VxFcTfqK4qGa5odak+xL3U34n2NfoKPQC9A3FSqQ1qNySbVjJZieRT7mW5BIBQdf09qJpgwLKrG96XqOjV0BApSQVXiAAaA+r3/8aRyWUF3ZqduIeZgXUqETiFjuVAWkQNWxyXwNfpsxNvqbD1/X/FkS9mKGZmK5JIEpFd00JbhpbBJGBWRblr0lIW5dPrsLqbj6SQaKCgpNEW9D7VYAAWWyWKkUo5FmWj0LKrA2C9K4/ePtAZjQNvQAtSXC/o68laJ+XblFIlze6sCaiisTwdm5WpTRN6IXlIzcU5Wrme4OJax5D2SNiBfj70AaA6egBNcf/Gmv24zdJJgAcgNRcPTOOTmh7BTxsDUfSgKRe2hZj6jjXT/FtpO3iY8zdhZDwjlYKJVVmmPITXpJBSlWqM9Bagwv0Ar2q9e49e2O+fQq5PoRehcg3tfnXK8xFz9rU/7LlRJ7XNBHIFgZI2ka1dbyL9vVWrjZmVmIF6RelXNieIUqQ6q6RqscYYir9xT0VypApSwBvZCFBJYXIq/o4tLRvXbplub0PS59Ot1BuQQbC/plTHGhcKB9Njb/ABEcgshRi5FNIOPdp5S7MeKqeXrCDxQW9B0Dft9G+m3071uOLFkNwjcvSTuT3UZY5QVUEgMVpZSKEl6Mn2k2hWwj9f0q/qwa2DlJlTDr6X9Awt1NGJpV4Ki8Xr7l9CL0QK5C0TO0c3JAsytRKTAobe1EAKqyfkWQspsUBBAtQvd6YDjIPtXk5JRSbXDOCCRXsAqD0uQCByFiALVxNEXEoBQISkas5sb2NWvQFq9vWNTGbiok4PRFv8HfiiZXV3mUK/8AhPts2GNOzsiySvwkeyrJZXtxjPQHpzvUQJVf209Br0oIq5JFy1dPoBt9HkQBwMWUdhXvUb9tu6AVdQkM7sO8AQ9ijkEs4piWkJIFH6rV0pYo42oW9ZGWJlsQyAUaHKw9vtFA9HJFAUHAr9D7TBAsZYJR9mUNXR1C8aBvQuaXoSt6FhRAaiCCSy0xugBKdQCen6e9fuCnqP3+9dKRA4lPTHZXqNTQtQFdasCQbD0FXvXsKv0P15MNzgO7SyPzf/FtsUZGMshkSf7nJPIluQccQesbF6VeRChAvszG9e9Amr2qMEKhK17f4NvGZMPBBJ7oFA2AY0pVXVvv5MwR1Kq7mNGPHVkzN+vp7U/Lt4TZH4n+EqD6dK4irDkeKnrXWgOVcRzeMXBsGXiXUWHRQSA3Wrca4mrcgyig1j99BmK/r7+jryUx/Y5YlFsEAjY11JVTe1jZr0FYvj9ZGDyMkaoiftsKHvVhcWb0IIpfZq/X/DZTV7L/AI2UMu2x3wp+RJRuRNxTA0EpAQIlagDam6+lj6N9zey2q1WrrVqA+iaITx7DDytXmoY5VDMzh+JBBpGa8bOJP+cBUNIWUYcK4+N/g9z/AIibHiA9+g9mZVFujcbMEp2+xui/8Te6iwuAbEULAHIJc2YKWpVLUwtXQeg96tegbVIlybsADcXFNYMFuQOUbYvKli7YhIdCvI9ALC/p1FWsvqtg1fp+nopB/wDDnx4shMvx4FpsPNx3PuuWDSzqaUrIyhQoIApxcMvS5rrZECA2qWYLSzyk99xXfUV+SgIdWPt9GTiw5SbLRZOFMORJB4KLIpZVUEliwmaRFk0+PJPIev8Ak9qv9JF6ACij1oqxHbtRj7kikV9/Ii73F5SOESXTrazD0Pt1sI0Vr9LBibrXuCLH9elyKv16rS8TVgCsQBCDkI1BWNQNu+XDi6x8r/XsVVVBK1ah1NXN/t9b/wDmsitUuBizCOMmo4ytRSFTGxqMg+pFwFAodKJsHZ5KHQdaaVhTyUYixDyIceYyD6CqsM/x+HJM+DkwMqre8ZKB2eLV5mTJi6WCAqqqPX2/wirVf09vpYEmrLyt1jRFYs9wgKKEVLGhyKgAkgg8P41DGnBBYKlMTYCwIuCpFBgaP7rn0IBKqxAjtRjU0Ca61YmgoFACrCiisPU9R70P2hSaDMK9/rH/AJPQFWsYxcq3Gon5LV6N7hjRIFEtJShQGXiWIsfe1qJekA4KTE4bkv0squsmnwJTHpsKMx42PF/m6fT+v1G4q3KiCaJNygBBa7LemuFV+NAgNzPJFFiKezkxNxcDjR4tRrhwoqCeA5KA7cQQsaxhhdQetyH6kDp6n0NGuppnvXsL11+sdR6AE/8Akf/aAAgBAQABBQDS/HO6myNJ4VgeKVscYzNrtV08q8TyNTNcrWvmnx3xM7I7nyD4tqNzqPONDNiTZGOuCvwl8x5fhPkfwn8zeI+UanwnRbDcZ2k0Gw18DYwxBlT9/XeOeJ5OTL8g/Jnx18Waz+5P/aNj7XU+aeXTeV7Mo5PEGshRbKCnFzkk5yR9JU40y8abmaPKl48tZpcjPhy8fsB1YNGoWQ45kX4+8f8ADtrLnYuixsqPW5WfUWHk4s+HHPC+twZ5k8X8WzsyvCvjnG1KZGHmrDFr8gnV4yqmHAskeViIItp49g7SPyHxiLCimikUsgRz0qElIMiS1ZuNBIZsNJsyecIciKASiACPWYq5VY+rHa1+qeaBtfjIIsN3XV/6rBz8tJNnLsMUtLPivKs+Ll42XnY0uZNsdfHjNJgt3I4vyptp4z5BoWkiVZdjtdrs8U6+Yya7wryXyCm1M+uK4XeSHHmmb/a7rEnmzs3Jp4znQcMftTyJEdfm9qB5DLJE/wCUJH/jycmLGbY7WfIlx5Gkl8O1ni8IJx5Gi51ijoHOPGHKnFRJpvjDxKCI6x0lhw4gJcUfg48riGPc5UufAYGuMaKWjq4oY8XVzSzea/Eet821Xyh8bZvi212mnKVsNPaDJ1xgObBapYr1KhBljJqwpoQtCKxx8e1RYgBjw3as/wDoBo9dqvOf6Q+S4GR5D8JZPjNYfx/kF/Kvjj/a+PeS6CfVbDCvX48QrBk7M/zT4VBlxbbVLC/+rzPyPjP5M8s8K2P9Vf8AsB1v4Hgn9hfhve4flv8Aab+v3iUfy5/2WfFWmX5L/wC3Dex4vzF/dD5J+SZtluc7KyY5b1LLkTCUTXyY/ukjYSZEDfkDX8xk6yMxavw/fbnFn1MuDk5apHQXpg7bK14eSXIlhkx+KRBUgxYNliRQLIdZr8L8PX4riTGwGghw9FCT4t4rm58niXgus8VwG5mJye7wyZW1kC5w1WmjkrYapFGc0QrP1uNn4+400mJDkRZCSqYjIsKxK+LjiN1m7+S3ebNjMCSD+DXRyZ2fL4Rsda+FrVkyMOKGGDFx4p48jWyAP4xlZeC+K8YmhheH4wy/EtB5j8peQ+O+TeSR4TDJ3mADkNDLAmZrs3AOdkZ23yxDkQlIcpmzb9jxL5oxfEvF93nZG3mxo8Bc3a5GGMu5lgTFhKTxN2TF/CxgyYXZjAGjFPHH3Z4j28qb8uPIMUjwK+afCtX+XJiTanGObt8aQYcncdX78ZEYHi+pfYZes10eq0mnjCjHSCDI5/lJ4v4J5X8l7D5A+E/kbxNJ0mwYMbG78r4Z/D1SS4mN45gk5H9tvB9aZdlh9rIzsVoqnhxp622HJA0iSWEa1JjXH45qPFa8eFykxcUGgoAxNXanxcv8mbC1G1i+X/69+OeS6rzn40m8azY9TiLJ/YPxmfxvfQyic/lSwTxZffyJMSPa4fyN4HFhyxwpy0v9VvljYfEmBkZPjux1/wAq+d6o7v5P8s3MW7ytlMNm2bNTR12Uv+KRUuOTXYnqSAkS68A5mueIywNWVrhk4/kP/Yd4Ttv6f7ySfbZ2Vh00LoFRzXDhUiq0OPFGJceJBWPFlw1kabw7XaiPCxsWPW685cnj/jsmTN4P8f4Hietk1/cjwsTDkfGydVjGMyTDXrLijWbXGONtNujrmRcIpZRDDt9Yu4i2sLYk2LlR4lY0hc5SI0vCbuMkUKbN4Rjzs7todrPpzFstjv8AP1OsmrETQ42ngijjbIwOZzcLK7OVHaaXGP4gwIHxmwcONsvGhttsSKSBceWMZ4ys+Z8WODJ2ByIsQxPGJniighdlErFxpPB9r5Bi7P4o2eFiZOvz9XlyRZgbgJC2uBycnDlu2HETGE7k2KoI7tTpBGdLok3GyGnGBJpTIYo1yBKkEgkxZexWFmxBMTbiavhzXQzvFPLLla+Ul4sgiLXA5Uv/AFvaPS6rxDzTwTwHzrxn+y3xfF4H8k4eOMZ4ta2RImpIyNlAddr/AOzGvkyPEN/hsmRtIA9Sx8DlQrlVsdMYK/GFS41duSuyal/ZhKeOJCSMZP40jwi2xw4LhZMCv7AfHcWfDvWzMHyb+488GxzHiBOdOjnVz5JjwIciCb5N8Dm2sOboY8HLm2fnp8YhhmNQY/KpcWNIsrVmds/UE1laWaI/65u5DjZNvwHu2BACdW9SYIhxc/GvTwSfkyYPKsjCSngx75EfSSBJZWiM0ohp4RI4wCIMTEzIxo8E5FRqsR1+MeGrx1D/AAf4tE+328WJnY8sM0qpi/jxzQYpSM8Y/HtJLmTb/X4WkU/jvHIp7uwaKOsTZz67VeVa84uXDjHIbJJ5tJkyKrOZpMyGU7RIXhkeK0WqycZvHJHx1j2xyMWKMXx3eCVJMeNdjhT3OLKIDjScuIxRPE/cmWCLHzI4Zc2aFhK+A+ZLneO5i5mZrJcRs6KBVMASGeOGRcaEDYac/wD+NRzin5E1f5ZhbhKIO5CcFRWVi3hmw4TI+E/cg67PZ5Iz9hjamd5sfTY2KvhXxfnefbP8TA1WQz42UcaLFzANRhPHl4A7mKC0/wARSw4+sXYGfIwZrxR5LCvG2x83F/rB897T4kycb+6Px3F458wyz+f+TN8X5SKdVPgyxxTfl5yT5UP9m8yAeC52k2PkW88u8H3njiyRfzSY3Gn1wy483RGAyJLHLJGDXbFdt56w+UQwEvBjR8zlzZImmzJcdRLNkPsfH4PJNJ578Mw4Hlf9p8CbJ8xyvHNxKdd8a73amP4u2eDWB4Vsoq8x0M0/jG8wGi2AimnhTWQrNHp4FGZren+nkNDRd6DfaYwE4MvfTWzGmiY1Fg3EeFBbZqCczBsP9eLTwVJA7zZurz8Vs2zRCNS/BO5CsOVHjYpSCbByMMa3Tzd/VaZ4oJ8J5YtQA1YcQDfCOIIoY5ZFbMgs0+BzEsPMrh9lsXa7JRnZu22kkgbsmVTUzPkV97DyeBRiCWLuZc+P3ZpMiRmiaGSYpbJ7jtJ2YnxWYtqWcJhMoj/+iBy/drXY3ZOSpab8Ylc/EULLBzGU1Okxx5VyIzMjiPW50+sm8f266/aeY+RYnkmfkDIGOYkhrtxQNkRCZfB/JseTHk2WEU8v3cGZBDEyyqCVn1zmGSNlfMxSamRBDKuP2dRiTOEw8SAsWkjjQ5MeucfmPBPOIY0lKzwa+OPPaXHGujEfxvv+zkf7frhbmaWtNqsnNOkyMHS5GPvp80TbSSGsLPyIKbeS5c230+LPi5eomwp81vz5v7dTwanQ+M/IO7+OfPvkT5h8y+UvLMgQTP8A6+HjgwGFvI8SPs5UMQlkxY7fimuytY0f82PGb4ZrMxI84wY2LDNlsgTGmFvmzUxa7wjz3wPZeZea4Xxj4F4zhYml8fJxPG9DnVm+F+KzD5P+L9RN475n8HbGLL2fi+VrJIscwZEkZY/jrU+uDV+J9+d4221XE+IoAD8V6xC3xRgXl+H4hW4+N8/FTb+PZmLJnY6xLMhvkpyHw55v8Y+Da7zPbYe12GTcU0ZuuO0hgjEUuFjd2bw6T45h8U/HmvBNsJMZ1xnbEyIu9ixIw+FG/wDkbKJWQMJY8UzriePDJkPjkUEkuiijV9Y8YlxpwO4I8vLnkesiY/j7uNHwMxUdpb8c3IRBFn6DH0k085TIUGFYmaSDvQpqsoyPo9kcXIRsjMycePhFHDI0jpjsZEi/Kz8hnWR1GPO5rOiMaZedlNHlMsGPBgrsawdRoMLU5eO8TSw8o5YX77wwLPFBLPM7RJDEVhryXV+N6jIQg4+NG+RFBiKHRLnOCCjDNnTyx9zIxI54FnBE87RxxczJDDmdqXUbDLlwpnLYWFBkiMJC8EWRzxtWxi2WuP5MWkw+E2DlDlgu2RHj5TQx42c0s8WyyIodLm5oldNhOBqIdliZ3g0+Fm/3HmzcjPy8Fycsxw06/d2LTXDjyQfj4uVMHkrtmanxTWuS9Y8ZrEyB+LCIZ6m7Br8UZssXXN+a86Hba3zyKHB2+PgjFWbA7+PCYsKpwMmb5M2wuSc6b5T+N4sjW52nyMTMbDLiJWx5czJzNscPQy52Xq9Bh6fD3MTmd2+55phWJmWo5GvnrP8AGNTsR8g+BQYg2cBhMkQqbitSY0kq5mDJh0ccWQ5MVa3TQLh40WLkNpoUklMKZBTXwdn4o3fxf4ZhzTjYZoyO5P8ACGWBLlS//RDi5WQ2Fr4YBLkzRrO6zVFMvczdgv5OTLFkVl42H3ZMfNieTV7KZ/KspocnImrlIWZjzeZe6ocPlGKNIJpAY8mHsa/JdBqct1TW5gkhx5pWHc/GhOegOLn4wgycgqJ848DntiZGRsBlRbOePKnkSGRIGihbKyTmyZSqEYD8aSBgzY7FY4JRisY2jeJUSKBngjilFYmJkSRY+OcaLA1EGwyTpNfJh+a6TDxptRBD+SmvyCuSGeSXKxJMfKM4dIVSHxxMzMlTXRCODX5WRJD4duP9VJ4ltUhTi7+B5WFmYkGZJjz42e8owvKThonkGwnGjyGzUwZcTHOuaFo1yp0iwdhi4dJlYk+J/YbaY+38g22ikMG4iEM80xNR/tj/AP7HlNrT9KCGoE/nOP3qhw1AxNcxMWI1R7Mrj7DJkxq7/wDBh5cWpwvlLzOXZ5u/miyNxj6/IzpvF/jffbeth8Jb7Hm2Hx5vMLC8x8Y3GRm7HxmfBm2OFkbDW/I/gwGZPrxgyyY0ZGBgz5s0epi1GPjkibyaON453NoMrRQYv5MnDGYCZckiXb66Pa4Pm/i76/LzMf8AHlnua/8Ap7m3nzMvJSGWgkqTjHyBUOylx68ZOVk5WHjpgTcYcgiNRm4eN1QTyv8AE2JJFnR+MTDXpr/9dHJjur5UmR3BNM8uRkSQyzZev/EUyS1h6PFx6yYhLT7/AFmNo/KNRrNnW11cuPkmOeFZ8TKxAJPxqkuhy8pjL++oshGRXaZsLMwxFr9q2Ig365IGxPBQplbJEMux2McFS7JwkkzSLP3IYZcq1JixTRyJAxjjUyy4Uc8EkTR1LjSkQ4DzUGyghxZBSQz2khyJYYMSI5OwiiwzhIc7NxcvEOYuzjlXy3JC6vXcMZ5zJk4uZkskXdMrQQdmowFhxVaN32vGTw+8ubDHkCH5G2e5841WVjy4UviG+jx8x8nTjEPkcOGse6xZK0uRNmSaDLmMmHtEw6xPJuyqeUT5skWVFrpfO/mVs3J+Q4YszN3BxFi2+iCNn4UeOEmsYe9XlH/rmgDCGG0kcFqxcYGv9efxsSGsfEtX5sCmXKaaps/W4UnnPnZz8bzTKnx8CLU5W12Hxt8PxGHX7vV6eHZeQ5GQnmXnspO22+PONvqfD9y/kHx5DkV538e7HIHyh/1p/wBh/jH4j2Ol/F3GthGtgBWQNPBCN5mT/jZ2TIZY8iQp3pyFyGqacGUTGE+faX/b4W91zQZEii8+KKkxGqGGI4+VDK7w6flWbjwyZGiSSLNaGI1JjSBImtFiQzxHXaXGx9b4Vk/67YafNhbX5GSwCZBasM4cmVusvG7uZjJCs2ZwrxX7qhnglbLabIyd7lfhw5eWhryDXauTXTYjTSSY8swngKnIOSYYER598uvwVxkknyIXWJ9TwkP5JgfWzS5zOZoRBmvHWE4yZ9lKRNPkca+P93p9X5H81/IPhm4xRlyOnfzTCcbNy5MuLMWT+SBHFBCzQY8SzxxmJXxyzQwEyurCGbB7lIpx1ylCTYzxRk7rKjfZ5suZDq41kkkgWKfYY00k8OFECyQSUrWB2ccZycmGPJ8e3WTHn43lBTHyPIoY4J9xgyzZ0W18ejHyTlxDC8xxtqcLNGVWrnXDxvHs1oIdZnSyLi5OVkib5AwPEIfL/mDM22QnkAkPlWUGg2Ld1jCZYN5oxAdpgzxy48163T2mpPeHE71YuLcQ4p7MOMAIsYcNxnS6GDdfJ2fbSZm48nztj4zBjYPl+p0m1l8K+MPE8GovAo56y/BHVvIdTl67H8120+PsMra5+RUcuRxOQuNHsgcPN/vT/ffH+S/i8d/OzXBmqLGmpsQFt3PdsywpP2wuryPmA1FLYLMVlzJop4POdT2s7Lx+BwsXVvktjxyPkY7zzYWAsKnGeOOIjt65XXKZBFK0qiXEjhkh1OufPlg4Yw0DRYuTpPJsjHfE2g2mQVysCTMzQHnzpJZMiaKJ8+UyZOHImLgLtFQQ5yxPuM558nMg7tZ4WDFzFu/j3iMeXieRy4mqlzJ2ll5AmZVmEX5IijQO+GaxmimTDkihibNj7UMzu0uTNCBlTZL/AI+RkL2g0cmPJjpPLlRMwh7Wnz8GGPe5kWTNAFyMzfa7Qa7WxJFJIkcnGVTHTTWZcTIMDN+PJLKFKyQZDTiWOp5GiaZhXj2g8g8z3PyF8D+ffFWRMwefKVpMnMeNwk2N3IyvJ5ssR5wIqGWcHD2+fBWXuJcmPvGQz7DZbBsDxaTeTbSXK0GV4h51l4knhvyWkx1Hnemkhx/PtDgx+QfMDpHtPPcrbrFtxNkQZcsEflE0/wCBkCeaRGY4YxUy8fyfWGKDO2zYS5e2SYpMMgx2DYHZqEEx4/SKMEtjRCsnUaHcR7X4F8P38uw+Kz4VBu5F7aaUZu11sLQz/wC0QDWeQZrTPjazfYnz58ZyeM5+sXE3exGx7suZ0RsmIV886e5y4JhPrtfk3lhs+c5ig2+fMJskmafvR48sSwNQWOesmbtUJJSkQtL8iYAlTIgVGkgVSmLHbExpMZ8mWMTNBCiyYpEOMCJF8U2CaHDT8ptVroZ21cyYsfl/jHiviuFqJQ0E2/fJg8e8rfXZLeW67cYHd8fh8fcLEJclpseZismFibGfBTZQQz5u+imyIMlciNchWyfL9nh4UTZmZJUfkuy1uJLkvkvMMbsMCxysyFijdcdFQQ8Gx9aY5EjnRlfirLEpqXGiWRUHcly5jqlRFjVO07R8aymvV0C5E7Rwl3x0ilnKY5VG7cXZaO0YdPx4RmZkswyFkDyxiKNry4v5UelTQJu/JMrX5mV/XL5W1nwx8hf25/trofnmKSLHklxIjHWVpmMIx8fGyp9cUJwFkTC1QjaLCxsRtXE2G0DjuGCI0Apl3z5MeJm4wbJxucMvjrSQJjb7OxIl8nzEkk8inmmxDI8OoYYz4ZL15DOZoXV58xYR380mHX+XuINDts+afKi/fjR3MUXI4h7FQBu1jurwQyG0cxFYuFOTPiY2PBtNbBvtX8na6XV7SLIlEkWbyhOfj8cViphzvxsHzrxnX+d+N/Kvx9LpNq4GHj5U85OF2jL8u5AzqlxQs7pyXKdue9y7HZZdy06CvHfGvIvO9hkYUMYkZEqQqazftq/3/IOQExZgec8b8UhkWLDaK+b21eId1s6HFikynSM4G0ilOhxe7LgwQ4EMXbVMZDJJpeUoyXeR2ysiBtfuZ8aHXeV9mSfyGFjkbvEjGR5BBBlR/Jeki0C7LuNDlKE+6RdvtsXArcZz58k0cUMGZjsqwStG+RI7FYisZimkWJGccG4wHDWPXcS/PHxqwzJkiPtwY75MYZHZi0vHHx1vF3YuORAIcXNhBV4J8cqWYlJJmi4w5rxkiB/5/wAp5nd1EMCxnJyFRSEWeJWOJMHn724gZYpQcip0yYFwm4zxiCSDFeLGi2mxmXX5cZE+NJkRLhYWdC+KEkLYLcNfLtd1gTYOVh7FE/JkmjjraDF/12fh40p/GNaxe2vbDDJkEzYyywnD7uYcbDlORDFL3fJMiSY4eAsCrInc2jGLF81WH/8AO7G/dTqMKW1YvUr7Qy3qKXHgx8c2aP22IGunm3JEEe4cZnyj4zFuMTN1k8E2DCIIodfjrNCIcKDHzZdlNjZH42V/ZH45hzsTN1vakyNMmQdpEddB5rmd/PzcCdp5DDgxbnyGA15D5BNJU+fyE2Uaw8jJglTL/jaYyVK0pUSBJOqnzzZTT5Ms7Rvm5r5GOFm/HlfJamkhZpElkDNCmPLJPlSyQ42PmeLZLxNhZAMWSpy5J0mRNPkQxLOnKGcvNBG2AJZMqSHL/KkmdM2a+U7SweJ+AeKSfHuNuNhjND5XIlZnkmdMct5ZXNryuslNHHdMCbMc4YLOtnMDWSLHhSEH8uCPvNGrJKoiyK1sBgA4o05ETZkuoi1WK3IrkhoY9jDHC0kc7Z/N48zuyGfHjxGii6Y+IWE0j68K8EbI03cbMSZlMUeOwjWPHRA3EgEgDKyVbIzJHenXHCxRanH2s+8TMzY3kM+VOYpQZp5n0BjEkbiDGx3jrKxYVi/6w9h8IYfxh/bDK8HzfmySdDJBLNjDybPMOMPcYis+nxl72dj5BnxNTPWNA+S2j/2mLWAHhhfZjXQTboZ2W2a0+Njw/wAMmBPkQfJkXY8VzsoHMxxJWumrGMgqKa9ROb94ViTWqKUse3JPXkWznin1EuVMMTXf7DF848Viwc4nChr7Mg7WPMCaLCy7TZXCt9gR+X+D+f6yTQ7mTP7snnO71sOJ5HPiGXf+St3t3u1lrO3kcMeXsQGmz5JWWbGyqxY4gH7dmntUuTaPu/fk5seHjbzI7+QZGu20ljxGn79SyNA02dkRQz5X8mXsZJabJmYYCvlZfiCxxthGGKScRLLKndXQQzxPuvAPJMDC2EEzIZIVmliecAB2R+yjRqonlaIwqCRHEVk7gmIuJYhK/cVQ8HeqLKy8fGeCNg+InbVWz5SvdpUE74kDxwrjyFcTHUNAF5ajxXDycPyXT42LlIoBkeyxqGaIKzFmLT4WVC+ZBGW2zyPlhUhmi2BxcXIyzlNN22WFyJNTqGysp8DVvW61z4oWVGfVa+OPC3Ohh/AbHObkbSXWRwnNhjX8+EQiZTleLRRZNbPVPBjZ+n2mpl1B7NQQRuuOjJEv86aPzDzDxNspp8t2KJLkPHHPs9nHliMFj4T4JufJ8rxf+uGuxg39XPEsrV5X9X/DxoPOP6g+a+IRZ/x1utQyYPah3YM+PDrLviYMphxtZLPk7ZI7f2LkTR6aV4hJBOWOD/7Ipb1F7CUQwxTyAYknJYGsxnfJG20euzTDDhacRZNj8p6iSbWSYv4x14WSfD0s+XknQwGXN0OH2tXo4cXK/sr4/GPIM85uqh8y8hl2GRnbDlP5n5CceXa7+XIO13YQT7NhE21JlgzP5sLLuBl3qfMDTpP3pY25N5dsniizZ7UwE1QLlZUkmNLhSmRAFysg1kRsjzyEzL+x93sDXhbnLTHxqODNFB3JSNXsYtPsvIvl6TyLUiCDCjlxzFJIrySjHEiRYziTOSIomG92flXcjQt0qOR3qMOysqow7cdSxotHFgQZWH3Y8GE3EDiRsRomjVkpEDUI0gLrKsev80zNbi7I5ezeJYoZJoQhEoQKwYi0Bys382PJUdubKf8AKeZWaJP/AJsi3KKBwO9avF2xZsCZkhjkOMcfJkSXJ0fk0SY+X5XFkR7LNVsjJyXV8mOSUyEYiPFIY9Rtpdamn8w2mo3HkPkex8m2uPE+PFEqJFEYVmjfW/7DJjxMcZjTM5EUUXkmaMcZOQ0r/F/h+b5VuvHYNN4pgah8yM+IbSXaa1sIxYXj2jx/J/M/PPjbw/bH5O+EMnSR73xjPxxja3DirFMInyp4oAyRa6b5z+RcjyneHIMj48n24eSVGNO81d56STvGL9uPWD+3XtkTAag51f8A5qCv9fevLdMcvV5fgk5n1nhi4NZeLNBN/sO0kGcuYX2fZh+W/Jof978g+XQ5reWYsKncydlvJtgOfkGdIZ8jad8O/erjOGTJKT4+d+PT7vrLsDkLjZNZ2wTFxtrsWy5ZcuBIHSXOz/6yf12+FPDv6+f2U1mn03yor8RCoEIAWNpojLLNi0jRRyfHM/c2BxIMdst5XgMTJD+HJbChmDQoghmw4g0kTS5OQjY6x4JjfMhk5vIpEgDVHI1BZXqGLuzdmzJjfxhGZRCkskr6uLBwsLViHMiSA9uB1gKyY8cSxpG8crRZMMuOsrLJIZVQhpIxHDK2u0uy3kmRA+HNFdaVDGg7c6z6WSbB3KsmQ6PzGNk4gknjaN5HnaCCWStPlthZMG6ikx9pvIIwHks0gMKSLDNMXeTIeWSlEkUMkrwiaZWr8iUrrs042Ts9x4Ymqx1nmfHkTHVHjjTH7shxMPYZSzJMJMTNyMHJ8nzZs3IwMLPzdp8WeKx6TSYaZ+JiSz8K+NPIsfXbLEysPyHH1mo8fYY2ujzcvJ0zZkvyr8NqtbXxafBl0vj2Rnt5dr8fwjF+bPnfJ2uXm7WTJmSa1QyN24cyKEYmxK1jP31xoKxoiTjxBRB/CmBrwVg5QVm/kfkd7+XyTMnWLWQWmkECYux0WJn4HkmtiwVyNpiYZ+YPkubxrwzznzTM2ez2eacld/OBP5lHW6FeTzWhypJklizDcZC0Z4axsqsOfGKfnJyn3sMZyd2+Ysud9xkhAyolRcX+9fz7qPCdhm5GwyckJk0tgvxX8C/LnzJj7jTZepygTNSyrkQeKbmXCfS7eDZYmPI0ZKSSsIopIMfVArDjxtAqRxwKndPZU1tMPM1GDJkSNO80gSR0MizLM+pGPla0qqT438conlkLRjj+MwUY0bPF4aE0+20Gdq8dYE4JDwBjWGRlikGPBcxwIUSAVaPk6pw1vk290uplRp5QOUjSSPGr9psnyXYYmu2Ukk+UzZONPLm5OTL2WmTsuXwN3LgYTRDImnC8pI/vEXGKZbGLGedciGKUZ0MsMblIWCSRIYWnGUe5G8qduHMBl0+XklU3gkj/ACoXhaR2SDaZ2HqcnZYuKNjupclsqSOTN+KfHZMva4mHJjyGZcqs0y5aw6rf6fReMfJuyxJPFvlHWbHH1ed47l67UamEZmLr4Jpfl74mnwdnm+YeLeBH+xnkOb5djYGh8e33nny94h4B4T5Max8kocfIlc66W8mq/br4WJxIpFOEl2ljN7CKO4BzZCT91eRZ075kWVIIosqUwZez7aeQL+ZjbpmGw/tT5vj5MuyzbbLyXT7bxubyuaDHOzlglHlKQQVvoYrbaIu2ScjCMecYqbZxAvu8Nnn3hp9uZX/JIp8gKGyf45HNMTKHgDjIhsJcV5Klfty/EP8Aa75N+GPBsrzXZZWvVTC8MaRDAzLSeI+WtrcjU5+PlOHaRfwqy0mjSHBllqXFQBsd3iwMDXQ53yn5HpcjXPkYmRkj7hCeLTLCoxipgjxuUa9FgiaQxIsbyGJ5SgWspsnIxMvMnyo4u1FGoZViaOMl44VxJbrJJCWXtI7YAyCYVgowmEyRykCERrCJmkwvBnyTrviHxGHQ/JHiM2h3UqydmZndW2uXmnHaJ55Jp3EjESkw8VaW7ZUUgDIpzH/HheUdgSsBuspdjPJByePhI3wv4JqfM938u+M6Xx3d4gilmReUuHjCUQ5bYwgyZ7bDMP47ys0zyJE00cM03wtqMqDGwIMzLhxvye40cbPPs894lyoBWu8p2GE+B8qbXV1pP7D7fCOt/s7NgH5I+Z8nyTE8r+RM/Rbny/5dXM1vkuXJlZfrjTcDq5DfTJZddFWNj2HbY09qOyjNL1TNnmZ8rNbHgl1wnX8C4aBcVJcnvwTFO/8AO8uP4lovkjyObc7XYY8pl2G1Ik8122QV2WxYN5QYJYfJesWduNhptllZkjl8m9SZFNNKD+UlLMFMOT90xmjgjm7hneNagCyVPCJAsSiHsQFJ1jBmhxY6/IeNZphwSTviKPr4v5Pu/G9xoPLcvCf458oxvI82XH0k+Pn6tBJPgz9g5evw49l5vgYlbPy3N2eQ+ZkyTwdxypmgSCUPNGrqvZSJYG4RpDG8qpxlWGSZALPLHBFJLblLHGqLHxAjCwhX7P46DHxu0GhDLL9jLzyUTJAeolU5W0y8dohaUaGbhuMLIhw3z/mvD0mu848r2Hluw1+m/LxjBykEfAT5MrtjbF0H5EkkkcqlJpfujJ7nNYZcztyI0H3zJKQMGZVVDAPHMHH32RsJMjx3K2GRNsXwMdYF1aLBmnK4xLI0wskqSRvWTLlSzOdTjYvdUZPxfjww+Oa4yY8efsRh48q//PNF3oWxgMl4Vko5EiRRbF462mVPIk+xyJJf7BnY/wD6DJ2cwaWUz/RGwWtTLetP/wCrTyK0eNkwEFoLZcgt+HP+TBKsEHavWSRM0sadnKx+Qy8W8MeumvtZtfqD/Yby0eWarzo5mPtN7lvKMjJmhby3Oy5djstjxDeNbLc43nmJNqq3UhmkyOqZPWpfaWT8Qyy3TGjm7D5Is2bK0RxcyMk/fF2C/Zh7M8a2yozDFmAd2Z5e5lE1j58iwHJlEUA7bQCNsdModzSeVx67YQfMkWJrm+XdjKdl8i7XKTN8l2Eok2pymwN3l63JDPNPAzxlIQy4iu1CSSR48UpEsXAOqzoIMmFMeB5FRjKUhaSEyCJpwTKFkJGKvKHDAjOMa59YpUaTmjVH/NSRuWaOMsMazR4+VIuRnDHaPz3YYsXkPkOdukZSag7yLMlo5JJgDFZ5o1iZpLxLIcesXHmyGLvFUZnvMO0cmFuMbyWEkCRtLIUKKjzsmYI0ljLRcKViRzgSTFliJnypHlyWaSpJlvNPL3ME/wD3fGmOf9K2S0OPNBLLBkTz5EEXHHSKDtJjwzCspMz8aTu59Y4CUNVl4i/2Mw+5NtRGux+hV5VrHIOgL5wjhzMN9fsAlHP+yTKqGaY4+y38ELT+VZmSdNvop6sZa54Jm22ZgwTbfyyS3m+2zcnCz4vyD8p6i2522AxrysS4sm/zZjN4vi4mz8m0Px3roNR87+ETnc7DwvarLl+F7OKPY+LZscWbrZkrIxZsekUSkzzYraGLFz99vs7Q+C+S7GTP2MoINa90hpcjFjly5bRyC0WxmxOWbeKWRftA6sjRZbxtA3cZxDHIlZO6/Kw8fIx4mx9gskOVlxSRzZMmamK2WRGnJ8ZWhWHvzPjZBhKERYseilhiKSxtJ4lNgaS0uSJJJslsSDGNdo91JghaEVDC0jooDIsXCCJJowhkjyWs0sZx5Ao4pL/KJwgadnGteOas7IISQKRhrK7SBXadJEkEHKsvGX8WVey2S+JHFJBLbtlkmV6WRzAVisekjuRWa3KNnx1kklDTS5kcOPjRcqly+Mg73CGBHqWC8M0J4wZvblyZSuL+RNJNBCsqvEAP9jDhT/FW3kz9HrThNPutrs9lhuMiHGghxS8szd6Muc6TFjiPXEjyWiWFZAsv9g8YDD3f/wDsQLnpx9cXJaKT+v8A8J5fl2p+RP66bLxXTbqFdZm4uy4N/sTW38+UK/lhnVc5MrIhlVaxdvkYx/2k0s2xy+/BnDN/JyYTPB5DjNhQfIIgydlt8DEMXyTiQw4/k3fycvSeN5mRlajzzPwPGvM95pMiTIxPFMmLK1PiE0Gx8H8T2NeUfCQevLfBtlo62ONFHKMuLurLIUE0ktZO7fPyEkdYWFwM2S8ExlTV7eHH2PlGXrdmZZey7NE1cudT3acMrVNG3FMx5lgiPOCMFMJWnqMsY+yIES88cKLG6CKWTFlMTYmVDjy4k3/0xbLH/HykCZZyHkdJGWsTHyZkM85THkBSWYBpXYI6qJoyOCjiChXElVgZC7Cf8hTJFCIcZZ5G7cgps148SN25S8VpzMUyAWDwM8ZjWNVChYFjEGXiyxyjmKITjLGAzIgkiikaMTSBe8sjSTyJWUZJAZ4hkRxTmswd6svJmigxPxjAc+ZU1E2MMabJJnysh+w2Q+VRy5EaWQRuubkQrkZEzQT7CU7L4T8ik/1mNklMEO15eLlnx5GmtkGTKfBgix5Y9bm5OEgkyeECyHZL/ZCGKLI2UhfYV1+jGHLI/qN4rqm8C8j0On2Gi+ZRjazcY24PGPOIrLD/AJMJlnrGaeBdftRxmzshqObP+Ng5Fm3GIk0O3iGvwvlTHbX+NecPC+VlbJMevlLdzZuXpfCZto+k8Lw9bH5zuoMODdZa50mVk5cEpdcmLxTxfdeb7/d4Ox0OVuF1W8w/kvwptVk7FJQMXS7jYYGPJNjyYUqyShhCk2SZTFJ4rF4pPkduXI2IIy8jHkfJnkdDIkVRdIz3RjFTKuIkowlnue5Ozxq4fDy5VBdslcSRXmCokmLwkjjJZcZljk74MmPKIFx9xPFBJkI8kKr2048o5pVSJw4VJLqLyJHFyy3gcY6SvJnaXZYEO48mwszEa05cRJGOSCbnFUcgik7KwHhDeMmKKaJGWdJUmmUSOElkhkmnmWYxPFBOJJs2KIOwiMJX7po4qDSxu0oUPKwcFFHCVV2EghinUyJwxWeRVZpXJJZVDhiMXL7VIFtxTJpr8eB44mTrMvCyI6zYsjJiii/Kf4s8iydDm6/Kh2GIJ8mIvlyY2Phu8kpnbhJOZ1mzlwI4phwjyRLWYtov7I+S42Z5BNJ3ZPpBIr+o/wDZmTx/XeX/ANlm1Xj/AMheZZm52mLkWpMxlrIx8jKkw9cuM2NiPlVj62WOuBMXDEMH4WREZTMIPK9xKdr83+f99PPt122zt7PKINbBtdxovE4o8LyffwYaeUbg7SbMVuOVkxzvNl/hrhbbZ6h2y5pqlkk/J8u0cXkGq8g1mRq8hdll4+PHlfc+TFiusiyBp5OOTsGwZcrOEUoySSpkWRZ8WKk5OI3lVsVsYCIMRjmHGxDFI2RE05Z/H8qKC34i4ySGDGhkd208WJCVnWaKSRMfHLqpxZMVPycgLi5PGGJByxJFFTM/KCWNliYpIUc1iL2KihvkZuOYptFspNNsvLPOtj5dl468AwjylMZkrHUBpXV1RHnMk4UPznWWQcsmXmMlGJ7dllinRIoJNg2Tyilx/vyNvGceWV2eTknbeB6KhShZFkWSepIldp86bIj2UzIgYRxY3fmyd3q5NbneNahNodggizZUUNDx5R5C5U8MuOtI0LjJhlMOLFEJv4o5M3E2EGveN8WtRu5NRnfFvlUu60+vzJmMZaSSN+7K2XPK2Zj5mPOkGQmbjyQd3JkxIdjs9ria3XfJfkB2uxNCnVlP0QTywS5XnPkGfimLJypEE91mkhOHg489RYnfjixb40OFNjGRRjV3oK74mpxNBB8y+U4/jeN5L5jLmZvmu8hyMlNhFktrNDOWlH4OF5/mQ5kGzjYy508EwzcSLvy4qCp8bsNsfyEkSSQrg9mSb5i8NgFbCKTGcZKxJCZjHFsicLKXJjhyZGx8t9pPImKHmELYseXOADjjIEheTNOAqosCfbHIcdshlEutCYuW2/xRroZZAMdZFGucYmR/tIciOOHGmcQRKoYOiZc8wPOOPEcK6wNBj40t0GbfDwYsZZpFedsXEnzcjP1OTpMiCeSCXMyBnSrHNG83couBCql5e08iMzKZGIKimXi6y5BQyrPUEMbzTYrTTLjqkmTMltB5LL4yc/ImmyZpjfKkcwd+HGiSMSPrkmkk2OLlRPkQ8kdmsXVRKOaZGXIakzNWuvw9lm6XY93mXmXHxTHI8ZMUjRSjutz7z5LyBODHObnjKfx5JdjrZTu9hPjLkTSAK+Mj/GPymPG87S+QjaCPyDIMb5MmKNPs49Xt99tcjyvbBZLx4UkkkuJOcv8AsZ5uml120zpdjmfSsUjmLXSGo9XFX4KR1+MTUkbxj8funwTzfFx8PUy4Wfhx40JORAwhk1zKZcPAhhbFm7XlXl+FqdZ87fKB8g2/kO4C6vaMckQ7bHn3ni+1nxcXbTTzz+RaiOaPdameObY4Ul87BhtscHOaPxzx3yHy/deTeH7TxzKaPGeNocfHl8s1v+50HmmuOBP3IxHjyZeYdZnyYEzbTx2JdoJMjLnxnIycScIqStIYFdcLFXnDIyjHnxec5IqV2aSNciaSPF7uPDCsYxiOevWJ6w+WOCiO2CBDEczEmSMJIuMxE0cCTJjgtSo3YiRQYHkBUGOseNY11+Xl4GynnbPkJU1JkFnSVLKpMhnnZXuSZ2DDIxXqWVWXFbgpLQNmZM2RGI1Da/MwcTGd0anxIUqZZO7k92IhMaQ5PYAfuDGaOQvpPHdn5Vt9is3hOVn5oyJJEdadD2wwWPK2iRTWvX346pNHMjxyzvmJgYz/AM8aPJErygqYUaSXDhILKkNTbMvGZhONdHq8+TfSR52NLkdupEihgyM8zP8AD/zNJ4xlv5+M/F8dyPIMiTGzo8mVjIXxVWBdZk4EbfKXyvpPj7E8y8yzvJdh9HtWPjmcwI4jSOW3codUiF5CUtJ+3xDzlsg+G+ftgY3jHkWHtYIcGFIpsTCY7/y7T6qDyb5GzZsL+wnlOX4x4b5TvcrPm+QvJMjWa3zj5EafH+Pc8z7bwnCDYMuotW71bYrbfXwB87RoF3HxX4hheNZ2nGJnf1A+efE/6+fKX9i/l/V/LnyPNKkbSnHkJY4+r+XI4jm5mVp8dcSY5GZmYgxpseJ8dMtnR01sIx2wuc+20WZ49sMfEikORrI4oAkhgjRo62E3+yDxY7TQwuHhW8v4WO0GRjR4suMiudd+JDO38hj5BsXXxLhxqKgxJA2DEphw4SYMWLvVjxxc1kDCNzyaWMquMoUvkY5S80siQtI8YycjF1zz5myxsPDyTNgoqfvbtLEzqytLwp58h5Hj5GN5I3l/jBlZZpF5Uw+3PdRS8JGla4ZVoxq8ev3m40K5+VkbCYda1uFmbXKz9fLiNkZTNTqZomXIlhny1GEssrzJkSBfvMfAcklV4ZOXYx3rDlkZGUSQZEqh5TC1TGBBkdiKPOlEMmbNOTJ+633eBfKW98H23i/9iPDPL0xN1kxwQyqsc+JNOvyx85eJeBR+Z+d7XyrYfQOtdh+UK2jxIooYhzNPIYKQ3q/W9XWtX+bhTeF+Z5prxT5KzJKxfkrbzUvlW4zoNiBktpNRBl5P9uPN/wAjc7rdQZU3yp5vm5m8y8qfJHxzb/b+A4s3+vzIem6xJgM7UF5H16Trs9S8WRuNNkrDmaqCRfib4DT5A03nWqwtTtsvGlEu7yJMXx35P2shyYZQta546SVzKGkxsfJfHaoJUjh8d8p3/huU7S5jRxOSsckC5EbGpsGI1jhoIYcLLmyNe8mBk4zRpBjXzWxofxpsOGJHhjxzHiLLGscf8hchcXm0mJ2XmjjXXss0fYwJDGmDxlVZOyVmSIRdpGwZGkeWcO8rvwiVeU0rhuaMIokkSdQGaUqySB1tIzmJgSkMQkSNF7kSiJqQuYOQ7kchCTWaVI56mRC+HMuNDlhsd4iyRschnkyZlkj2uRhyf7glmQ5Emf50c/StpMY6XKZsiTIyIgkjshaSKKlSJY5MkNOsMKtDJEMhObjNzbSAyANkiPFx9pDFW03rZMOwSaVslSGfjSY7ywzKvecKjaL5Y888fyNT/bjy/GPmf9ofN/Khm7DKzpGQh/oReVYuLEI/Y92ud6i5VevyBXcFAua8MbV+ZavR+CZGFheOaE/i+PeL5GPg4+nGNg4ukx5k+YvM9J8a+I+fZ+x8z8i+e/MNR4Nptpszn7KHL758Al7O5+LMqabV55hFZ8eNkrucGySww5B2Xj8kybqKeJd5gJNDh+ceSeIYm12PebMEPe+UfIVwdTs9NvvJM6PAysWXU6ScapFaV3yoRAOjYcc8k2Z475BjQ4zzRohiefHkgjwuIKz43cMALR+LpgR4W+wMWfOTWzFNfFiB8rDjjfHxDK2Ph8URHSgP4SrdzXiV8yVZ8eXUeG5P/wCcLr3IeN9ZrsjNafFeNY7TKOEU6wnJiiyIHqWGV6hYKjTSUX/kMRkXIlcsZ5jGS+QEgx4dfFxZ0LKqiJIUDO6ZMDLFkR27wXI7U2XCYyWcyPWQgVNXn6fBztzmPmSyFo1LJxhiaess2H5DqmRL/HJmJiUJsXjOkclTAKrycDDPyVuru7xB5dgGgYOzT86zSzJC0qFjKVML8c3ILvLMJJJCpa1y1uXMmnHKRVRq+4KWJE3b5gSFaVC3riY8tzHJAjJFJH/6qjmXt9wioZLt3LTdzv1kXK/DPlm18Mr4/wDknQ7jXaLWLkHWYGRrawsQzN5n8q+KeCYfzb87ePbHN+Xf7g+P6yvNflTO8r3E29bNkw53yh4tnjE2vwntI8zT7GBQcyAdzKhGU2VrX7uZALbLDtJt8ZivkGqgEuzwAyT44SL5r8m7mWPlTzKDwXFzJi2s22auHizJjPt54I3gdO54ps8PXeUfM3y14dv/ABgy4wyGggEkbpIsURv2OdQpjil7+OcWcuqpfHwZuxPEqZuK2NLdcaMRMonqJZElEgMOrZde+duGzjHvszHghfvjBhkkTx3bY+Hi5OVFkvjtAsc6Txt+a5x0x5Lys/ZyA0eO0UQXFn7AycvHIaKUwRvK0N7Vm48sSfkEAx4kccTsIjJKszPH3VRUkeJ4WM08CrKCHadsbI7pkyScVSZnMxiej2AjTRxHIsUkUO0qL24MdmMY/IO2xIcR8dpWbMQlceX8VZJljgLFWfLikMQBknEIeXFEcgwsWIKYrHOw6cTyZexiZjkxPwZCyECwdqFqIr9sfKFlcSVitFHJkyQzSRTcXXjR/wDZgdVk/bJJwlnjHbikAqOS9I4IgQ1JI1+Zr+vf/ZfhRQ/HP9xvhXN1mu/7YvgnwDEk/wC6b4byU+VP+6Xxuavk3/ta8m31eff238p8vzT5Z5R5NlYvh+0wMOCGfvxMsMMe07NfC3zW2ly9P51r/INbOkV5MZmGTjdM3Xm25wllTe66PGXa4QxoM7XcT8l7HE8f0PyVvZNpsgfvx+864ExjgaZSMIGQO8EYglcw4uTJCoOOS04lyJWM+WdJm4q46tlvkR5T5GvzIdbn5Am2MkYSYvA+JWrOMmRnxwE85u68kUSFZRLFDLK44omIgMuJk/jyCV9hkYQZYwjtK+O71ixJNJusdY5sISuYu6TjvEuTPM+SywSmmbvKMcBcsjuqizLrMfYnI2ePl5DfxwSO0haeIymYLMc3FxsKLouRlBS07RQTSWKyyduKSyK7FUyUk4uY2JEbiaRojmLEsEk7QDhG65qRxug5ySJCalyMvFi70Id5plkaOSKSOJ3WRTMl7yO8lBpw64fckSBeORiLdfx45c8YmbhbDFVzJiSXdJFrtrQUrRuFB/jRWLyNxqwPov2OJLVE3F8WXrLYI8g590iN3rHktUcnKjOeDZgqXJ642XlYUkXnnlUAk+QPJ5jJ515VMzeY+QNUflOfO2l8gdn+AvlnG+OfM/kb501/yns8XYR1DnhkzdiMev8A9JkYmV8L/wBhMzV5/iXnGm8lwl7E5lx++2ZiFZd1rYnj2mqsd9iMJfJsvXaOL50+TMXOfYZmRk5N256HD0U2K7pMwmENbLWY2l10P4RbCEEsCv0WbvNHlw2wo5Fmyd9LPiYkkkwyY8lI8+0CR4ds0drCly5pM9Nb+OggWKaWRI3oIspANo5HQIWQmB0GAmMx8e1GRnbUfF0OHgZGHjYcscaEBEsss3c7bZNBQHkWF3W3NjCBOmLGolklnW8Z8YwI8zLkjyZk2OBjz1so4sWR8WDIoY8Yjkw8jm0XGGJE7bQdxZViSQRYT1kB/wAaWFzE2OY4pFlQhVWpoe0MhYcnHypompsZQl1ZNgBNPwjCl4CfuDOs6LMvGbXzugaQ98ZwcrPFGGyYbRbKF33cXjuDioS5yh25HJcKHhWZ475UGPirk41gYnUsvGuAoF6YSJH2yY+PKu1Mofj648nWaSTszSWWSQrQdhStxrurX5E/pDEZT9WHnS47eNbrinjW8Eog3LIv+3ehse/NkZnGsTLmik+NfmffeJ5HxX/ZrxjyGPA8i1m5iyQe3sliK+V+WeO6aH5R/sLp8SD5Q+ddtvDu9tk7SaLGWTImWCN4w08sUcgr+uH9KPnL+zleZeL5Hie0GaJHimhyH+6OnEsq40kQy4iiKjCSTVEpmsH2+yx8XG/DwsfHVy1nxM1GXHUqpsXiVVZVhJBRKZR+PCxLtGkdRxRGLxvGydW7/IOANVPkjOyiUJKOZZkixXV0afKXjHyimaKMEytLeaSDsKeddogeO5LY2UMkyw7eXDxcKVMTNyBNAJC8ZE/dV/xYzHIV72TK6Qywur5UGPkucJS8+PG7Q6zM2ceRqXKSRPGzuAMpQxyQ8VRuuOxkE8sziGRoGTJmWRpUgxUx8o/cZoHBki78HWPs48ytLGcKJO62rXTqMmAwMMRJknVuW51nj2FqNTvsHA8cfFizqzNeMZNhgOqMiqz6bZLA8TB0WMMrKF7cTiJIxIfaX9vpiSRATS9JR9rtyT1ij/lTF7tY2P8AWv7vHp3DeK59p0lK1C5mKSFauMmG094pRDWHvszWZHgv9ivLPF58P+5eymwN7/avdbJvNPmjybbr5Nt8zYzbBzaWIimxu+JcGRGxIlVfEtfq8vP+NP7/AG6/rt8P7XLydtkJHHHkCYCbBgzdnI6NE0EJWSASBkMzTweH+SnxzFzHxoNJHDn521i0aZaxrE2IFDaP4a+R/JfEDjzYMwDOvbIHH7YizBVlmOvxi8ILTshneSCRBLjzL3OYWWJonyGlVpZpI2jaZCZpYpFaaG6C5aNOccfJuRFK/EY/kOySDM2WfnSZEsBVWp55Eiw5teMjIL7DJ0/wP5W+L5F8eZukmdmM8CwwxvHEYDidPHfLZdTpsmeRpcvFApYMSHJzsiMyZMseLF3kjTFxIwmbGs9FsaYZsYMkgVhndtVnhlcNFk46hGBhvEiubYTNk1hYggqSNAuRjyyUYU5YuvYTnX2XGyzgwZM5yjup4vws2ONRDuBj4eRP3W/jtHcBmNdw2WQsk6pyCSOVx2Ywa+dqyNdLDE3OpWvD6KvKo4b1j4wNYsI4/QIJpaTXyvQ1OQa00UkQ8fkOMmrk/KhbGONUUVQ/vSFS8Pdqf2yA0JlznQNkTQ4cksWPqPIRDC2wcEubmO/dmjhkjhP34kHOWWFrjFlkE2LlxlIn7EEDmITsiY6G2PLNy/Gx1j2nyV5d5ZpTPBh1jZsmPmY7z9zX7GLCjxstJcvcf2v8T1vxPm8szJ/DMbGGaCSV7NCGLY8SrNiFootamCuPHjqZIY7y35yxhywbhH+MnanxzAoaSJcSGGB2+9o8eUU6T4TdsvFIyxYsczu0rYwXlGIJgXheaM1ctMXgWX4I0uJn+TFia8+1EOw0Oyx+zmyIyNOv3CCV4wFJjZMapI8jJXM1e0ixZ4bSZTLHGJYHmyPxMfHRXUStFE2Q1hJOs0mQqlY0HEqs07PAREq9nrk1qcSS8WD9h1UVNhzRVNrchg2ErPPrMqGs2MmLIx+7HlQmWDMxzOmYnCY2DIpasTWmQw6tVTH0+JMuD41iCPP8cEVfj8aRrUe4ldxJ0l1aTVmdJl/cn7oo6gj6wX5Y0R5eiqWOq08mZLrPEsGBE0utan8Z1+QYfD4zLpvGZ4hg6/Jwlwn70M0S41R98BLdmRUrtjuZEJlWbHvU7oafYmAbdoeMkAuYnowNHR/crWGO4uWmkyUw/wAmTLxTDAuOZBPMQNd3GXFHF4cjicaLKyKw8NmEWK4o4ckOPFjRZEcEGMVeGQVDihBiTZCtoYYezsoITjyOprV8TPixjJRoxBLFjx9yXGbEqLHTHj1OLDk5u3wMXGLKxOOVV5GGTLlRtHCyLO6xiWVrvIrIKVpVikJYuUmGFJ49rcGVR3uQNBWIIKqYHL/He8bxbea/yHXbLG+RvJ4pdVJ45lzk+LZSJsdWURnk7WSiY1QwNLN8dfE+m0um3/hHj+1wfkDxqPQ7PIlkdmjORJmdtJdZgFU2UOPAZm/+iMRtiI3cdnMsxus2QAajSTuYKq8uhhPYwNaGLatlSDHONCushnmGl5z7LS9l21b5KZWEqPmpBG+6yMqXDyMWWNwqnIjeI0mPJWvxhkrg6cxRS/8A0U8oFZev7pyI0gkmeo5O6smaBUmAZ1kFii8qji+yGMALnRQl9zL6IhZtXr5J8jXrBjRxGseJajjNvxRw10/48uFlYO0hkviyxzRTUqRX4cW4GpeHCaW1ZcsVZwscqV1XcRyy1lQg0uKOUsSBHqSMFRwVMbZzYyIydqTsgwYz5WVmTJiBkxpsb+USQwssmv1kAwXyEx1hYGLClyWyMWLv0MB5UkwsMI2NDFHj42OtQN+BPl5+bno2LJGkMBgTXxz8cWXvnXZGRqVLHJX8Dg0aymh21ZVkMJEKrEhiEkS9vIkftN2wLRckGPaMcppS8bSTwwgSKXFpgSFMjzSvGgmXTaOSVtd4tiiTBTBwYVlgVQ6RgGMnb+M4ezi3vi0+K80DRHT5aQ7rR7bHztXmZEOTJ8y7fA3HkkkcqQy9pceYnHkingxYdjKYxlzcIJYHxA0rx48uFAI5vyFnzVufuDwuZR4fBBsEjwEGRLrJ4Zf9bGxnwO1IMMcm1gIbT4/Z2mhjghydSfytpqUEe014hllEiPH0bFms/j+MeZeCKHLX+HJwDKSjQPs9IcqsvTRRZP4nMR+O/wAeNoSsOw8biiQRwR1Gsd8idI6kkeeuKmo4SH1munlmgwkirGijhTFhnWsVZK94IT92PPjmsHaCo8n8mOfJmx5cTYHsf7aWpssLTZ6cZ5LVk/vysMEZGPWfjiVxjdPxyXyIzjtkRl6kbgqholaR8lIckpM+eTjxLrZIHw+5MF/FSDLn/O5TZbYmdk8Xye7PjvkPFA8k41OvxohkTTS1ixfxR4kmY82SuNSStPUWTLjTbTKl2+RqseOfLSPXY/jZiiiyoFkkEcUcUSRhFRLDgpMWMQ0cCCNC6ybMIcfLEZlLoyII5GgWPHGNFFAJ1Ti4imWyxlke7MokjEjvrdTNm5OBEMTHx5H5RswAu1K45MEkUyyK2ZhY+zx/LPHsjXyzklvEfl7Z+MQeWfPu522ry+5NjLlRpizxytUheBnxZMaOGWWp8Y3mENNDOzyO7v8AfxZ8icqphqBvt8Amlhk0+HHkYTaySapvGGCnVJHUenknP+tEdNq5eeThRyDYaIyzeS6rt15H0aRXJITt4/OGaTyLb7WaHaZMJ/25kjk2MrVj5vcJkhrK1nfnxtPC1YunlqPx9p2k8beXX7zSdmf8UCpMdHMmvBo4VYuP0w5hh4GDEwGLjlREjgYnPj0rEvf8CSo/xaxHMAzsdcmGDvLS5XBXlOSYfZLhDEt3humdCGqaI1mwqalj5VLEeLxVPEe2sCyTYYUvJiYhHcIXBMpbG/GyJWTDaXU61s4prIjHLp4smSHX5GJNrsR1fCxpXkUmWcdvljoIIY48uSeWIiTDXJy1U8XIkx312NLO2PNmnBhwDNJFjsssSxpUEDch2kgHGMxCy6rXxZk82KS7gF9xC+PP++sVmWGSQyIrEQx3YNxJcyvSlsaNVL1rsdmbW6+TExTMkYS/ciaLmr/xpICqSKCY+6jM6PtsFNji+V6p9dNkDpLIRU0UksLQRKkyLFHhY2B397NH+TpsLUy7jd/6zIzM/X48ZnWBJJSO9jIe+OWPWa0Ha15zGfUZsUU/xll42yxF0eXkLl6xQmR4+kUh0BEuTpThmbRSTsmreMbLXY8GL8g7jBSbfZWQ+QInWV45AIu5IcO0aHW/EmJ8dYeFH2IsWWYx4QrA1DSl9ABDpvAcrIGs+I8vKgwPh6WFX+FeWL598W7LBzdl4/NjSz4UsEkeIsok12RBWDARIkDsUxRWNHZvxHrExK/HjrFiGOZ8c3/CknXXpeXX4suQNnHIkkTlZf8AiiCmkUrFcl/bIxpZqyIwayI+VZkfENGKyUl4zrdmjPMZrldL2v8AZZcOnknzNJ2ZJYOupwZcifV6r8bETD6DCMqtg4ndXUrLAQ+LNEUXGEzxvHlTxFJi0ZjihEIWCSVXLsz8tRGkpxXsYYY1qSFQMeGV6SNqEcZIEayoq1jQ8o4oMRcfbssbZvdTEPd5PEFaVhIXiIRMYSRzYTc5IXSKEM9aHTZW82HjPgGpxYtp43j8czEkxZBC7LDAKRftKC9rukicZCGGRlyRS+ba1cjB2OtywZY+CKy8Zo3DZMEbq8TYx2EXLDlE9AgCbIylXVaHL3ebn48uFOzKjYaKc2SPhJG1osbGz4o/h3zuDX5HiHlWm32Nj+Nayc5Pi2Q0s3jccJyvHFy5MfQ44wtxgajxuD5Y+ZcUx4e3jz9h5GMfJlljluIOCoI4hiFGODg9oQ4VpMXW5Mkmv8XzZpvjj4Oz95Wk/rNHkJqfgXU6xk8B0GrRNNrIGfQ6nJg858Hi5ebfCEeQnk/hU2nlbF/HpMVZ2wcYGTEx3ECYtYuJcRQxGKKIAfiHtRY0xqWGCFi1jFFWlzxDW9yo5Zf/AJ+ccUYDRoKn6OcohRMPx2vzlaC2XrjFHlKLQtNr8vKDyxyYoFSw44EGkm2Crqy79mPExsPKkxkGqjza8b8NysuTA8KiGJL4H/JmeFy/j5vj2VFWNrDE6a1qOK0ePGsbieOQxYyyEvCqnkyZMczMVdi+FO0EmqyTFWI8LxtAAsWKoMeKxdcNy/4B4pCUTGxHePZ5ceNh7XLeadTNnY2RHIr8CtPk86AjVUkMTDMbkmZh5DRY2O0nx5q9Tjy4QWLHynR49s6/kKkSrApCoKeSRisbOqsOckchrIiLHyWPvajZ7DHMKl5qxkxZsjKfHaZQQJ2itslZ41gnCiKFhlyzSx42dkalMx8rJLqeUuK+TEmK7yRl2jzd/uMpNZk52JL4t8tbfQSfH39o8uGXx75+8P3S6rdeG7YbEfHeBi/Jv9h/CvEYPk3582PlC7HZT5r4eRKuTKwjPdUyZkYkqOEyjUY8Zk1uEs1a7xzlWp8ftN8afGBzMnwbwPV67Fj1UcC+J/G+98yyPJv6y7/T4flvx5NpZ5cQQY8/4m2g3njUOvX5Z+J8XcYvk3iebpZkjMNYGs6YuuneotJLUWvlhMWO4GNjWpMRzU2L2Rl4wNY2LAaihJiMora5Q442RYQ5ANZGR2IZtkeUWVDNWVlJjrhZF1FgMyAgyRx1l9m0y2qWJamgx7wZ2whdMUYwGPzk0usjz8jwr46kwYdHoe1WLqdfhY2VjLKq6aHIizPCsTLOR8cRNW/8EyYcjO0OYZG1WZh1NCyR8EjWeJO21ml1O0xcTCDNlTQ67spOyY9aLbKX12ThZMK4ZZVxL0mKTJDhswTWpwyNjga5/KN3hzGZUeXCzmxJsplB/NnetHrUy8fPxVx5JHSNXVFgcSqgmZE8e3M2Bm6ryLA2OLnbzHEJEs8hxF4QqsDcWZJk4pE5YY7RxDuTrUzSs3lh46rddoZGQVNMpWWK5qSV1V+XZ2Bj45cghLF2XJxpFaPlM+SLy5UkEMM8uKMQzwQZEbh8iWQmSFWxZJ4DFm4oyQuv8lzsOLB+YPIsaLa/Lflc8O73+dsILGJXd+3E6RNHr/x1aOhGJAmI9ajXrNNpdUe341qTNN4t4tEs3xx43FiQaTXQwt8UfGGx+T/KfAvj/V6LCTw/WbzU/wBiPg4+B7XzLwiLXwZmvyMaaGyjdePw61fm/wCNlmj2uIYcqHSr3NXrIVi/15pMIz1rfE8rOm8H/rlut9B//wAtSxYuf/WXY1uP657+Btj8L+Taus7w3dYVNiSQDOJ5wSEPkZ8xi/2FoppuBxc4wiXOM0mFkEZEEYkrJgUJlwWabFYTTY8lp1akTuPiRr3cnBArG1LZMvx18dx4EeDqcvJMZh10Wuj4xYfj3dh/0MEdSY8FTY/8+51sGTjeSeNiN8/AyoqbXGWfMwJpmnJx4eBhqHUvPAZ5RLLg5hi2Ph+3xdNsNfrcHTa7fjAl0/mGO74uz1OWsmdpMc53mWBiybLz9SM7yOXJglyZckJEwgeIvUk0c6OY+7j7bNx4JWbIM8XRkGQO3EYzGFrHkbGfwvNGVDLDwOMJUdWklp4+NLMVWOdHaFcYJKBzaQmsy0snmc6w67bzs0zPPMTFm+SZHkH9ZfNvDdBnZcmDIciVZZMsRwZbvsMqcuQ2LkR1l480FMFMM8c+VHPGjKw79RIcqiEcQquU+VithMmPNPU2UiJj46yUcrItmSNkiENIkkEkYkFq8cyVeHI17U2GJ6xoISuiwY5q0uAZ28c0aYWP8d6U5WR47BDg1riz5fwD8cY/jPh2k8eeKsHXJj4/9ifBoPJ/jbzfGTLy/JvHzjz7Bfx51yEzsPyrGM/i3m2KINrHrIYDpdUcisXxV8mvFPiHO2svw7/VpHn1Xx9iaU//AJXKqXxRsdc7xnVTVifDvi+4ry7+n2q2ut+fvgPP+P8AM3itDkA08pcTZVy838cmwDiKV2TTZQFNsVFT5zTDIyTUs84lmzCDl5JkZWEckT/f0kf4p8Ix9hNqdfHsmy4OGNBro5m8d06IhjTsZeUQcxmEUUs7TTHHA8kx8eYbfTRLPscFY17cvCTCeCsjHMZSfLZECl2zzLgb7zDyHySvy8iZu/L28TMlMg2cgZNzlV/suQdosxgCi40wWeRT3TJGhhP3lZVZZQYfvkihkuitdJMtcVI4kcQHgfBsuXCy8p0mfgq0OpkV2Uxla43SKZgxzeaNPDfKljEvyLmdvXyxlmaIRnwnfp4r5F8nf2ni8m8GnnSWVF4JInOCOUqnEtUxy0Z4EE8kLQDJUdqS9cVjk8d8B8i8hjzviPyLXYObrcjTySQvEvmPyHod544upyp3mdTlEEyNgTGma4nMkTWYDBy2w8jHzcHKx3x55ax4mtoI7DxmC9aDEmnyPB8HHhx22mNpY/iPbReR/I/xXiBtSIseEY08VvkNY8rxzzjK+3yLv9zyfFhFYc4hz/OGONjeeS32Sa3lNofHp5pvC/EBtcv4Z+B8XC1uq02vx612kjmrH8ZHY3HjzTUniMZg8R8Zmyd5rNVHkZP9pP6v6nzvwX5/+INh4J5Pk9ZpMy1SZDWklHbzJhy19R5JhOLsYhUmwIqfMZq7lTZHGjOqASd3IC9uLWQR5E/hGGcfx7HV0w5Ptj8Z8cTb1Drxj1BkyDHySWObO05fJhgDZUWTPnhGbfY0ksU0cxOxxpeexh/imiWJcaYqhL88vJAwA6tMckcDCnZ1cONkDKKSTrld55WkCMr2WWaQd6RFinOQHlVqDRpN8YfGMXm4yvhfxyTE8w8cfxnMfHfFxmkggjMcoZIWFRgvP4mmwXI12zhy6k5GizJUX+kfUZOJLUkU8aR2jlYwuTixW3EkWLj+Zb9c/Mkx5UjjTIdhiIwnhPbzsiGV1xBi4c0gmXHWLsTGIx6zyPx7E8Wyf5GEck6S69iuTj8W8H8b/wB/v8LUQYuFgYLYEnzzqW1vkaCScY2HjZUzbptfWYYO+yMqyZHcePBOTIvj+Vl1l+NZWKBBGowttNhR/wC8TKrW5OFOMHV4MNaKfsReCZ0EMuB5xE0+NuJst/i3yGDV+cfDXyDr5tFqNkc+HXyYmvxv7PfKWu8D+PN3s4MttznQlfI7WmnhyK872zNrvMH/AP8AI63QkZOn1ZyZv60/DkewDRI+u0ermlOm10P5mRiXyP8A8+8o1HjuRPnxeC4WBrPDtAj5ON4ombmf9qv9UDi4XlWBNqNrkbDr+Y5qXPL1G5lmgnFa+ObY5eXPDi1Jnrb/AGMtpMumyZpq5NWI8oYZKvFp3tleBt/scbKlkRdXixRtqZRHhZD8qaaTnk7bFzhnutsmaLsttBhPiZ6Zkm2URS5wljJjaWHNaOVkl7UxiuGnfFmfJ7omjlhjVWiSGWTibzVJH25uf5DfZRHakwskiY9zIaVpEkMkhSM/b8J7fBfxjJmEUHzZn4s3kLMoGRlKscrK1SzyjHwFgkkfeR4Gl8W3S4r4Wxx8lUU9zHjREF1qVg65CmNoccCtlucPWx+Y+Z/nM+ZO9NnvKvLIJhUIu3yVyYJ4YMiXa52xyxPjORrctNC8rybNJMV1LYrCMkGptHn4yzpDK/xFOkGZ8aeX+M6byfb+T43k+5/shvMSTfT5WQIceKL8fIdCj7MxDYy9t4sRpGwmxcZJtjkyLntL3c7Y4Bx5bmV24SY+ZJHWo862yYup8/2hTQeW5LZmm8h5Vqt1+VrdXMIpP6VfNcO08e0PkeRBiecfM/i3x7o/7Df2RzPmDypdu64202008/k25BIyX7Pyxso8HT7jLM+X2Mcr8e6APtfjHxiHReA4mMSNVjLAuFp8krhaKEY+J4sJ60PiuPijC8TGdBrvi1tdFrfFIVh/tf8AD+r+Tvhv+5Hxpl/HnyflTjvplx49T5a8MOe9clr8mps1Jakyqh2DB/zIAIpxGY5CZUkPPGlAj1bSX+PcwR4uAypjarMU5ePliPISQrHJl8UyGLxTQCWthmSYUmxzu5Mu0aJsvyCdhstiBDh5kbv5Jr31mfnyYaJLmHFxjMcs4ssUxjeV6mwyIpIuCzcgsTRO4VYisfaVpY1bw1dauLtM7S4eLPlLJNDI0SDOZX8c8i3HjE0Xzl5VmQbabNz5IyjIwVZJI4VrIDcvHMHCzM3OaB85VfEEO5y9YNF5imVlYm2wsmMtBOWj+3MXGxG3fmODix73yzIzzky9x5OKKs8Qc5CxVDkdyKVU5NHLxkxJ0iOGYaOGj5f+uEgTVzDEOsgAbBSN8rXRVsYchV8Wzzqdhr8j8yHd+fafxODyrezeRbGONrP+NGXmx+cnEN2xCMHtxgmE1LkWrMmC0XYF3swlBDE31cqtk4chFa7YfgyaDdd7A8K25mbSwT93w/zHdeEbTB/vh8oYvjvmHzJ5l5/l424l7X+6g7ex2InryrIPfyPIRFqflffd07GS02DiWr4gxLbrxSM43jOPggHTae74+v8Au8e1eRkR6jx1cZdT4uYah0ad3/STpgTaT8d8TxeLcYv/AHjfHWo8H+Yc3MY5hzWtJsAoxM+9HKanziKkzUumUJK/JNJLeommAbNnvBktx1uUI4sRskx/HOeRDjPJx0uaO6+3iGRDtJQjZILLP+RLn7CHGknWHYYu0H4zZEoxUy9jLJlbTZZrzajZ7DLlyNjlENlMWk2GTm5WExYRIZpcDLGMceSJxySeWbKwMbDhkWNYpDCZHJgDxLHj7fOxRPuJdg6yhGSUR0sRjqRYEXxvB8b2uTutpBsJ1xg+O8MsEmNPdZAHrTY98zNmx3zZWjYrKzywZJQ+O72eRs/yqXV03ybIib7zHI2K5uyyZ38V0X++yfINBrsSEM91K92MrLWQssdTugx/xVeg0RjjxrR4+u76rhNMgxFLTYcSndePt4+ZVxnrYwpjtt4BNN8UYHhOVg7ebTyZzQdxhFHyyFeN+80Y1uG2zm+Sf6X+c/FHxpkyLGz5Tyo2X2qnmeVmBqY3c/dSxyvJiM0WRrcz7NdP/N4hsop4vF9nLr8nQ7rHkwot1E8OFucasbbrl0dm8IXyFQufv4yfJfKcmebzLzePWavyfy2bZ5EkgnpP/Z8QTY0HkHhuGuf4pqNETj6bSd/GwtD2q0uktWoxDlT63BiJw/HYSYMPHmlzdVDh5GmgjXH/AO+75K1e9+ec3JLS981zPJZWWmYtXNq5NSzFaSYio37rRm1MTKdbmfg7AbWXPkw2N/AN1Jiyafad3E8dydfz+RsPwXx3YY22X8dtjlRjvzSjnjqrZYJx5dHHgeRmPtZWXDxys+fIkwttLiarOzYI2bJd6wooBIhiAidZpIVY5MkyNA2TEFMkX4kMfERus4iDLJ8U/wBb8Xcaf5X+BYdDrXWXEfSYkm92/lfj+m8dkgliyjHiMpWCKdkiW0sb47y4auDjOsWh+OdhstBLLi4cJjmTKkEs5x8NmrEgwpsuTKx2ycv8jMbGwHV9lq5cUTa/EddbmTa3K8g8izNkXVxPKsscePkt+QeOTKI4eZvyVY+3gBJKxkCloMhcifHXt+OQ6/DydrLjT5eUXpIcGVtvjoU2Ud6Mjxh3PFUlAyLO0kHdjwMvM1Ww+Qf7JfMfyr4OXEjSZDFJGsk7dXfisrcjG6OYp3hjiaSKTAy1SbGzlJ0WbJg5fjOxTJPje37SYm2LVk5/41JuZWWTaJE8vkbCt/5Vi4cPmXyjHjp5R5jlbKbvdyrJWPrjNN8bYkMO3+DsM53hWDqyMbxfC7L67Td7E0Wn/wDn8d0kGMuPr4i2BrZzh4mvx4FfB4H5v8nxfjb4W/7JPl9vkr58Ykn6xJesVuqwySPIksce123iWRqMWPm8UtYW3ycWXxLzE5uD49ue9Kmbiqq7tY4xseZTImhMm0SHH/OJhlz+m3z/AMnM8hnmSbJzmibLzI8dTHaPGRiddj5M+OmYmJlwLk9zIyTBNr+MuMuHkYiZnABGvKmUMQ4e7bBx/h3zzUbzxf5n8q1Ol8LzssTZ0eNNirk5GTMurD3ix4oo4o05tBHJFBjuInw4pm/E4tL5PvJ9Pm4wsxmgpe07oxhLwxGP8aGdExoS/wDX3478dzV/sJieM6lsmIq+FgmU5ONYpCyh8fIeaONcMnBdI4cHvx5EMjJhJIJcHG4zQamSVE0GdKj+EuX3mg18VPrl7WVixRS57SI+THD3czF7mHldn86LXpma+Z+aTO8s6TOJJWRWkXIw8TImeQpwKyzBVQs4jRpmki7UkgIpiQe45McjR1qdika4O6kWvCvN59VXiHyNizjE8mEsku6n/Ei8rTCgn8ybKbefJmDoo/MvlHK2GRsfIMvNebL7748nFp5JpagzOxH4psBjbb+lu8j3/iePrcGdvGPGoraTWitdq48eXXwc59PhnLjwoMoY+LDOZkwwIv8AvG/tTqfhH+vnyX5TP5X5Z/gU8TiqKjzAlIWNJJesBlpGuL9utX5B+PkeHeZlM7X+VfyYWfhTwajfSa19Zl4eBsfIs7SZ2XNmRPJk5sMOBmZ8kORmZUoyY8vIUbDY4/JMvlk4GS0bjc3ljn7uZiZP/wBJTvjWY+S8253XkvkOVIZCozy7LztHxiGh3mZpX3e22G22B7nLElyJWxNTNA8WHHEMdENTwHEVEVhKs/dWGeFFSYF4WZMzWmJZlTiY5DKZ1SfBxHmZGiUSgV435t5f4zibHZbPb7bIHYyI5HcSYYQch29jgS6vGg70UgbKycfUZPDEzIEy5cCBZa+PZfHsDx6RMSRlky4lzp4bZPGVctMfnLpcrt7zHhxY8tJI0lyIcjF2hMRMhFSBjC8dsnusVZ+WN+S7CRSKUsCyqAGEhHEVzHGVpTShmrk3okpWsLZyQnTbKZ31GXlY9azyjOhQfJGygik+R0vuflTsR7jzXY57y5ndXpJWLgTzVj6yGE9mCiLVj7WTCk/pr/ZKLw+b4y8i1vlOr8V1udjR6MjHh10E82XFjdMLFfCwMCELB2caCvIvJdd4N4V/3jf3o2vz/wDNU08ssn+GJuLQzBkSRphJG98cvxx4ZEGTI60udk4j6zcsmVieV5usyvHfPYMyPD30WOF8kkeo9js+3Lsa33kOPhYmdvJdjJkZckjQZ8mM2TlDKmhn4yYc2TiViFuGPlrg4GN4tkQ6obyCNY97mrS+R9ip8fFFfhiArHJinJkYMpimqVGNDByeXjrLFnzzS5c8cmPWPnQwZURSeRYUEWJiCVYdSoWfWTSVLrHhXMx3SVo4izJ26EeTKI44Yk0Xx/leRiP4y1UUW3+OUhO61sulTB0Wfm4mTgjCyZoLY8EERyJEbZzTqInWTulITwhACanSxzlgcOL8uFZJ8zuLncXObPNKZ1gQZmRE0e2lxSJXl7BlaFtzkLLPPMyrs9nivjvyvDzieaZSOYIVpKZOTkHuEmzr2isiqWeQSL9lMPtK/YqdxosSNW1ezx8Ua/ylXiwfJHrP8mxJYd1NI1Z2XMF/LklqA9dVg9+fBxec34C3yYeykGzgmM2IciTxvyLcanYf06/tZ/qG+N/k/U+aa6VciCDx/MKvpwuQ345yBKZseLZbvTeKa/8A7tv+23x3wv47+RfNth515V9SoxpopEPoPfXauSWocKDHjkMIOBkAZIjYxSQx3yNY4Ep7dbDPxo8fG38kD+LaPc7DwiHzyXGkwvlFv/zmXn5aLttlmZD5TP3TnQ9hc7JkidjCddaQw8jDrXaVdQ8MORvPKNx5RvYYMV2wYdK0u5SJs/x8pj4uHM0g3GfrWkhMoWAd5cX8uGDJzsnJg0CJLkFiJ5o5I6jSBRiz8mhjWYRR8xDPwPKTts6tWx1yrUmM1pIrNhBoE+PNJibHKx8aNVneCJckdweb+MJnYeP5DHq8WZpZ5sodyWOOaVoShkyRPHk9lI5ouAk18DzyaWEQLnZEgE2djR1LnN2IJ3lEsOSk+Q8EaZkhhTPSKJ5i0mXmxRyjyPBkjWZ1jkHJzscVsKQNLT8UODiyZeXIPxxe9GSW7Sk0WJaSTuR8ojTNxH21dmPb4U0n3iQyNrs0msHexJHmzNKYsv8AizcSGQSJJHJqte88us1Zhi1+ikEo00cOPvdfn1jb78d9fs/zpcUa3CxtT8iZXjuz/rH/ANgOX4jn/E/95vEvOIvj35B03keLrd3pIsLyj538B8Lwfn3/ALV/h/44x/74/wDdd5d5rg/NfzH5V8t+Tn3+rGy8nHi77yySQqVWM8vH/E5shDilRkYjwV+KlRQxGbAMc1R4FbDGSM7PFYxnHxjr5G7WThZEkTaXLzMik3OuxYP/ANIOGRtMKdc/Nmypl1xyothnvLJHOhZFmRjmzJjRbBYZ9NJiJFqWmkh2U0ktYusw9Rk7TfazL2mfupMpxKpCSyGaOSd6jMgSWWTGiWeHvYLcdTC0EpZg0kqO6YjCKLGe6u3VX7qxZCiMuWaUODk4aX2kePEYHSOH4+xIv9FgZv8A8+RjOseTkY8SbZ5Rp80RiWAv25sJpFOMkcM6qonMH5IUI4mPc0uH2pNFpdnvYtu7RtLKAVeXimSYYpHgyHlyJXgzzEWz8ornTK8FNeJvIFjlly1kglTO/mxsH8/M3fj82lkMgAaSUG54yHuRm5DqkZPvICwrqrEknXY2I52vYTI9MSVVyMR+3HFncakyJoKwpoppcjWxS14F4rJPWDqTJNHg48FYmgmzTi+L4clLk92TxmBsHGXZd6byTJhSGLcSayTwX+wXk/g0nxp/2veX/G2Fuv8Au386ysT5m/7Tfmj5FPmPzd5n5TPuvIMnYxbGF4J/8OtxXy5fjn4M3e7xdj4gIZsLWN4ydrqJsmR9HNK+R41lNJq9HnwTT6iIRZ2ptU2uFtxqsrAhVckT4jrENRvVizZcnvSrnxKH374s8Xks2RtN52sKRMhJnhVEx4DPPkwbaPGxYOy82Ww1mFq/IYdbiRbbFglbbbDa5CNIWaSE087xMsS9tTjx02XkGR8mLISDHiMhzJnwMeeLGQMcODU4+VuNjmY76vKwe3bCxlmEuLPAcfIVD3hjti5EuQ+Y+KcbZQQxNH+ImP4DuIRE/bIw1+3FxWkrz3ajD1v4PakytZLBiSY8EcOPAvHLSNBk3/PUhBEpI000OS2Bl5OFF3Vhi2EUgkx41gaTKnyElyYicmGGQbNhJWxiZJtnL25JpnjXNmm7WSpmaS0cME2Riz5WXsNo5gdS7OlOpL/8ObVAVdpAiSvJz+hZQq/c5lIJ9IpnjMexIo5EUmOmRWhMmVk+OePPrdKwlji0njM+adV47lZlabwSZhqT+Rmz7pWiydyAs8s2dFsJpoZvgj47w/nL5q/vt/Wjwv8ArH8iPl5JGXl5solJELwdmbyHVMP8PaevhTxH/wDTeT5Hx7ieM+JbP4ri7248KxYBleCLUni0Rlg8OJyMvxzGhSXQXin1pBztWYo/MtbHJoJNLBjiWeCKoMiSSnvJSTDIabLkKwvxXBmEeLmakvPBiDLLSSw0MvHlOJHmc2zUlrWnjBHs8lUGbJjY+FOuZA0qwCNiskciGomkyVeTEBEjTGPIIrJIx8XF18uQoXLnMcmw1uTjs+VUDJI0MkiH8xdhOICTHCXfHlNppyDt3WdMTFjrDyooG0HyPhx40HyD4vkV5Z5RLptfl5OVmZMUUvPYeQLmRZRE8ePicJdshiO1jPfQ4+NCmRPNFotJHBk5cGpxpppYJcGEF8LYa3tCWKBddNwRsrYRwSZxKzzALLk5mP8AjbXYzzTZYTIEveKw4UmcW05hGThzMrNJZ1cxs38jX7bNxo9ql/c/G68P8SzPHD3X5fFGXHL5Rnam6avwzvzabwB8ybTeBjXVpvG4hHqbfkbKxefMhEpz2gm2k10yZ5MM7LyfyHPr8c1+GalgjepMSpNVHmR7fWvhZH0D3l7JZV+8Gv6PeLzbz5K8u+OtTBHvvFMbKzvMPjjEdo/jUZsZ+O/xDnfG5gfa+DzZFbfxnLw02WiSGBfyDFl6vIyIvNDt8TNmlkSHEy9eIhnghspZqEwaPvhqjzbVrvNNtrfGtfxfLGJLkZOu2Op1eLm7LMznUhjjFog7JjThTkD8Q63H1+Jj4vi+vE6xQpPaJoYVjlhna8ajD7ck+Vt8CWaWQ5sXi3k+JooM/PXOyZITgwYshWbvRvWNHjqF2Uo1vj+0wtNLkZkeRJsssq2wltHjsySYsk8k8mCVGtyMzT7HbeQbfyPKTHxRU+K8DrEUlxEeUwtjYuRuVGXWRFF3dyJ8o6zDh18kEmOjzN+OHnElaPKD4uTLFWwk+6bNEk8+cgDraXPllnrKz5DFnwzySToMbH1+vmmyTF+KqYhgxMzDWXIlaZakiYj4z+PsH5N+RvJ8HS4GVyavuB+7kO6KCm8Wlz8kSxtFRFj9V/TwHL/C8k8S18O+8V8U8TxxrNL4pNBNjeMmKHTeDDFh0eox8jZbzXdms2NklN+75TKA20ywtfiioYzOZMWGGKSM37YnrAxzBH5DKJ9g0V6ZeNRoVpl4+sXM1CTy/wCufWfnfIuy+NhLrvIfFMbU15L4DjjEyPDcqCfyLwucQT+PziDb6ONotp4m+TW48Hixmm8YM2dBqzN5H8z5MeLv1naRpMl44PvhKEDFtPAPyVLyyyyRQyz9nXyYK5nyP8IbXx74ux8jsNFPh5RhxJpcXBXJjkGpmys3GyMXRnX+VQaWZ9nuvI9pIy66M5jTLOJVyopWiOPlQu+DjZk+V5Ni6TX7bxTLhysvK8c1YfC02TqZsvZSTZaTTrBD0Go8p0+u8ffIlMmdhiWKXMjNZWYzLmmKZMIVr2yvyNdlZUMveVI45FnhwjLkU+Lq54tlrTLIkrl5dpJJjy5gLZTBXxYjLFsezHNJnSJHFlpEmTlQR5XjGzdNnnZ2PBl7rMhhXJ2KTSyzmbNjycow5UkoGVNm5Tzpj49NlQxDW+Rz7Dx7Ixoooth5fsMvShs9aysDIkpg0ByUgKRciZF4swZQzcvT4A/rPn+d6X5E+CX8b0nlMKYm2/w4E740/wDSHJi+Q9Uvhuux9vofGdY2x1/jOZt9i3jKTTaz+LLz8O2Jl4t6GsSCXyTKGPkZa/d2e9Wui/glxLibGE7xYh57uAabxKeNZZ5MbpHhEE41fj/ZLCYzwb0X3/609muH8v7LRjZ6HyjxRBNt/EcjdYmy8Igvn+CGbY+Q+B6fS6zybxHHzpM/xYRp5L4tLdNLrQV1OHq8X5OzTmeUxy8qHc5TSMyxy93FXKlU9wuBJlduJwY/9hzhy/KNzm61Hy2gxT+TPhy/j5cGTJIPDcObyaHyaPD0rxb7bZs+LHsJjsJknRWGLOspyIJDPHUED5MyrJFixabJmx1xnhmisJvFpM7KzPJcOHX7F5m78Usq5MOUTjvuFxWfZnOYxG+Q0TCV2lxcfKYZLx5OVNrJMiJIsgSPjdhk1WIcfa7DZab858+I5O0yHSZGeXJDRwjLk/GkxI5IddJH3McLZMTX7XPi3OJl62tZYZPmOuydbh7rMihxJc83kzGzkmyfv/Ly4K3ewtmCaQvmHuHR5+vx4TI8Qy0SOVebYhzJLzhmrMZ5T+1GYt6AAFTY/wBYPmPUaPxX+w+/0XjXxf5HnQ7Pb/4v6T/LuR4H5xooNZsdL4Tid+DRRw/ieOajVjG/1M8OZgQyy4OdgR49Z20xMLXbfczZmXPKhOBhD8fExC0X+uECSaqv9eJsz5UyTEc3aaCXCgx2mEuPaPtcDLGA+diV/rqkx+JgxT3P6SbCbQfJ/wANvgb/AOMdn4+uflZ8DYTZuqhnyc7xyXJCa0iHK8cwxl7zxfMnytvoMUz+Q6vXxV/bLH13xt4Fs8mTPyZI2V4RelR8l/D38Z//AE/9g8/4KfbK7Y4jzeWPj5BTHLI5yJ0YQMaklZMuPKAIyjkxQ5s+IitkEytkDOfcbFWgyXlxtWMrYtkPBEI8iKJsTKmMq5gVtJ5PnYeNkRw5WRj5Rkk12dJjzSzcsvOP5GTjBgkmxleGTLx+5+a0SafYWlyYUy8YJrzi58WH3yghhxIJoGmcZM2DltgyDy4SZQzXetnnckji/wD0GuyITFQPbrZSYsr4WaZceWaPtRzwOuoyVgwPMJIm0epy8DQYmb5LsN1keT5aS0s08uRyijbKkd55tlkxafNwJ3xpMGTjmYmPWrVYqz8xQxdgzTvkJL+NJWTOy1OzSv8AcT+1nXixe7XrxP5Q8p8Mi8m848q8wzj7/wCEV41t8jR7b/r5+cPGvPvH10WnxddldnA1OiyoDrIpSJ8Xcy4dbeQ5mL5vmvitl9/8iPIM4wHtH+WYB+cO1jSLOCRr9f5NljN2B1InqLWSwU+snYy4MpZNdLLX+q5Y+QvYMjhZIskiT4m86y/FvIv+uf8Au94v5R4DmazB2OujTVxtssbX5k3kmGdZDudZBgYuXha8ajOg4Y3lODLk4mFpcbZbH+8nzBL5t50rlmZnlYEMxU2w3wuGNkmGVjGY8WPLEkOWXJn7FQyyYewjnMlSNcyXjjmlgy1hkyCBPlcIWc5AYz1hxP2hnNFqkVIsmfCmJ0+FmbHMztfPq8xfvmDsh1mDNi7PUK2w2+yM42KuJYpc58kwzysDmw8E7staHwTA/wBLkYhwczLj12XHmzYOHHi/ugyZsmVYzLmZKdpUfIvjZ0TJto+2NTuHSszIiErbKMw5WVFNHr8tkj2uwkEc2aMfJ1nygmKux85yt0/lMj4uwXbfjY+yyv8AYNJLmY0OWjRGObFQS5yHAysmQnOy0laZI7QZ41uUiptUy0ZDLN3IJJVAyJHdQr9nI1fjuFrmuz/+D8b/ACx5V8Y7T+v3/a/5B49i/E395/hn5B1Wg838dysPY/B+bBW0+N9vBW5xZPHsfyMSy5GTDPfrfUS2aGa1RQsIcWKGGHzjyvL2bw6jO2eT4j8Z84sn4+8PhE/x/oJpNh8RRTtP8JeQQYWz8D2+sxNthyQyZXt/LWueSGX4o+ePJ/jnc/0a/wC0DSbfSaLzfx/5Cxdlt1/32/zhPk7/AC9RtazMyDC1mDJhw46aTO3sX94vm340+FfBfJPIcjyHbe5xdWZtczBHVTzA6KvfkhuMyzRzQZsORHh5GLkPlQywMswWKX/6zC5Y6jGWTM22FG5RXiqBZEx8ndSZ+VeZIYQ2A67bFwcseR86wt7r/HNLh6PJmwccY2Nj4GQNRjZeBkST6OBjsvLJseLIbMSYz/gJRQxUkiZCgd3Ix9nt8zXHFynnny5cZY2xNgp5Y9YeTeKELLBOZZp42kjfExVIypYs+bYCXXK2Zk5WNJtp2gfPfITI2T4qTbUSj+sGp+LvJvkz+5Xk3wfufk7VRbB9r5Ruv9Rstl5Q7vr96cjHz2zvxMPGLsMbGxpcrt4Qny5Jo8MwnF2mZHBJLkSOY8mWKmyJGSRpHkQycjaSQvxcBpGrif8Aw9T5ZvtK3hv9tfmHwt975SMOfybziHPh8p1WLtI/KdFBgzeQrHFjyf8AuwclIaXaNDPL5SSV3ueG1Goytnl6PT6XxeHKK59fhuFxPHM2eTUaXW4Ef/6ZNZi5ubrNprvlz4v0mLLtfHEgkyNc0NdyaM/kyLXj3mW48byv6x/9lPmXxivw5/ez4589w8bzn/8ARIuu2+TW48u8W0+N57/er+vvxXrfnj/tM8086h80+QPJ/OtjVupYk3BUm7chxQPyjJxMcvPkhJAuNj5MyquY3bnj12LCMFcVWAkEH5aGKZcvHnnmOZi8siKA4kcePH+ONbnKzMsUiQZeRDj485ix8nd7HKxNfj434r5fb2eZs87aZkTJFOsyB0MmNjo+DyTbSzSbPIxVTVbJexiS5eVDg8IhkzySSw8osqDY4k4TBkjxdTkCKLIXEyhK2O5jne+zyI8OTM2EOTUmxnxZ9k0Qikm7UbbKDs5+4kllz/JJ4sUeYZmPBB5h5BhnKydjlExsBFmzxVgbnPKttcjXz521GflZiSTHKz8JJM3d5DnIyObl2lqQcZJG5SMCrQKk02R2+1zd6vJV+v8A4HBrfR5BCMvG2Kdmts4J2Gv/ADh5xrIYV8iy5cOXF3GUsuTtcoyQ5x7mg1kmym1ra7xfFxM/vT42ZiwHDSUzmzYeNlAyrFr5x5P5Fm5KzzR7TF+SdBk4OxfuQyZ6x29IpWRtH8geT+PT+Ff30+avEovIv+xj5322H5N/YL5U8sbL2efnOv7uTMKVeXpixtMZcaWE8VcKycWz5mIV2lVrK0spEI5GfKkxMsZOJLQgaSXCldc5szMkefLjp9fJ24cYK8Mqq0HSTDfEna5wsiNuKRFMp/zMlchBiQww5khlhkndmwcd1ggtEkEUeNmTrgvBnzTHE2Dwtj7tMiTWZgjzCZ5XiaRDi978nE3TZh/Nkxo5dtN/rZMHZx4p3U+MdluMjZTS5MGMmU5yYcIY+RqtlmLrkyNr3JJ9jJIkhxcuTPl4tk/l4mDkZEWJTRRLGJM2VvG/EfxE3e7m3O0OW9m3GQ57srseIEgTucl59ssZW5PtvGtto1mwsvGEoufamZpCff8A8X//2gAIAQICBj8ArXkJt4JRKR8zJnQTjkS5Pkd5J+BbdpPBbfiH9P8AX1mk+uSr7f8AJ9PGPVCVloStR/6h2u8it3P46Rz1kaosfiy9+5Xrt+ZEcJLCJepqYeeC14S3gaSEmVwbmsQLc8P3OCPpfmOsa25+4VqrKefXmS2piPaPg7b4Ym/hO+1XHroJvQXdfsNRwjZ3K4IqsjS8Rt8jbfUS7dCbIaZNtRqNTXA1zktu5fmLeba9TJS1/UVuUEV7irZMordmm1US6fzKvtP18xUquRn4Ta3gwL/VJu8x9+rT7E8L9qlui2q9fEgdKOCLqGZ0I8RSnBO58U66cJNvI2zlswRIsYOx3HsfZVsrmNdnp7C1JRjUjlwiupLXsE+RDUKDLM6m1ao0qaZJ5ih+X+Qux3c+H9zTBoQYZBgTnjlcJaIjPDbZxPOBW7XcVl6wP59ORKHRpx/UhvJlmpli7feS+emJpcJaxyHfsX6fAb7yrXuPm1Pqjr+sol/tk20bbXjzEu1ZI6rMW5yxEtmDOnDeq5GQXf0vZdqV1fJevIt2+7KshQiDbTU62WxL8zpf6jtV7YRtVm6WKfNT+VOEtfb94/Dg3bCE6vBvSH1YI3fcJWqKUY/4oMPBD5kp5/QdqDUlaPQhuOEHloVfIRZyfNlQzcV/1+Qp0fd9fcbr2xyK/TptW18vX2lktRN/FInVdR9L2r9n+Wi5LmQ9CNERHR65E2lstafcWqrdKFtrnh5FO9tnJuhz+hCZX/8Ac5mvCDBL5iJ5m5PDK2rMknlwnkJVvi3idvtOkOr18RqcQQOdBbdEj5vM09WTbher+q6FzPmfSfU9nu08vA+T9T9M+2YQvEl8sk8xwuqSIHwwYNDPDQ3ELUUrPDbVm/tdzqK/Sf8AodyasV1ntPRlIWT50FYL2kVpHf3FrNR7CqqsF/8AzqfV17V+3Te/Bw1p7n959R2qdzf26X27vHkYaLS3tITz9hoIhkSnU+t7qvv7XeSmns5+5wd36rZm5jAjmOyJRMZGo6Y+4Tef6eJ313K2t3f2Z09vkKdeCkd7rAqLQ2aspZJQSaCrVSK1Vj9eCPlxy/AdEKB56mhV2i2zJKeSGiGVt2/iRevnL94rNajXd7bVV7595HafSKeDfiJPQU+JmfcNr4SBp1yLt74quQsfx+wsoxAknjhtXvFH7fxkT5+Aq7obFuEnqMxoVsxxqeRp0krRDPM7Nu3bde1epf6RrX15jTUMS3dPgNEkJmzlIqrQhLQUIS5H1dKqHW6/LmU+p+i+odXV5Sl0f/yzB9D/AOkqx9Teqce1Jx7soWZTJiYF7Byjvexi9grPR8d1deOnGfAhLg3VG6xDP+l3LcnBDZt7+n4mSHlDfInVjpykqkdy30zdbW6bfqak8+EMiclUk+OpFjXBH7dSCeGW4FseCzjAm1kjkTXDFb19vsR1PI5eEJLRIWSe4sMx8J5D7UikbX7vwKR4m3wK2T1N8cYos+slO9R5/MV1+4jmVq11odm9Bbng28jzIXI3GpsxZGamNRQuXDTAm9B3xBv0O5/qg+MWSXoU+auh6G51mortZHWMm22g09S0f8kkl67ZcCfgTvPjwNOp/tPmJ4K1RTtrXxGm8FLLX11Oymtq7l9r/r7y3ar3qd2p8tsU68yb9twYNBPmPsrmJ2PhUFrLwPnUrKsL5l60pq50+7mdv6T6b6jpaj7jGnCGaYPrFGiLd2ye3B9P9VR/M+n7se6fMeefGYyTyJjHG2PQcL+P7i1e3qdr6mjydnuWjfefaQ/D8DCZmuCdupmh1YG5yhk7eobSz6DTH08H0kcz4h3fPEHTLJ4KtdZgnvUgeJNsZ4S+29y/IiMMa3Tn8PA8jUdUh+Y2mun8Sm4UPEDSYlI3MGR2RsTM68dMjmJEf7janhiojqeeCvGvrJNmWdeQjDiSd2VwwXbK3jUbWh5ESPGgqNcxVtoJLRG2cEdxjcas9hJX5lXtNlcIdm5TG0hJxDQk/jRserRGzHrlCrOROrKurwhWlQb1oJJ4/qbaL1YpQ3d4It/yk3U3kVX2sT6v3DulhOfxOp8h9vkSJt9TMsbUMSnJEuD+XUs+fkNan1Hd0TO5Szjt3bPpv/Or3l8jtPpx7fv1O5ZEN44P2mVg+ExY+P8AAu/GOCM9SPPkYeRWteTt/TT0VXrBZR0EtTc0QunA84MIdkyGj/4oh4I2oW1PPrrzMJwQjdbUc14S6n8eDfOn3DtJPPh2O/T46v3FO5RdcuWx7HkdxpV3P7hLJ5Fbd3tb+3GR2ooqJbvM8huPi9fcTXU7Ms73caxwXidalmp5G7kLZlGGxVQ6OBTp/UW14PMhaE2XMljU4G0jGhKcCX7vA27sIbkSayYUPh7iFq4PIfdeouuJEmjJ2vmZ7cSzuWrGzkaYKw5NsdOpjUvWzl/kaaid62/7W7R6Jf1GbZlk8yLEmk2RWqUsajJVJZkhuX+RK0Lz8TZNnDNk6Gg8wfFkdYxHuNpug1HR6M1wZZucSS0VeNolGD5vloJYhlfAafL0LehHHZ8rP+rwNMlMkV7fWjff4yv1VM3taBwjUw+GEWzyFOGiW8r9BvyGzzOx9Au//wDx6P1yOZ3M8xJMls+JQOOCirglkWqxvlweMCfiJz4mHiDb3GlXx1I4UdTPx5Ppu/Wk9mt07zzXND7/AGvp/ldt4G9vVy/qeUi5jdeRVtZMaRw6hEISQm2P5eg2baoq14GNPRRZLSSVqKFgXLhDTHNcEtRVGg6uxtXxCrb49faTGHA5IklpcIImEWTWCFXpglPDUGfiEpyiXgl8EoFS7juf0HuZtq4uJN4k7t3pAndp5gnuZZ0yT243E/sZO+ej8B91dlPteXL2+AlumeQ+15DnUU6wROTUU8J5kEtny3zNMJGFkW3Ejzpxb57ivGeOB3sx+CQnzKdii6T6eadUGWRV5/MdrNKk8yV3F7mOHMe82w8CcajVphjaXSjGhG00HdrqGkNQLHMXd7v0+/6f15ajhaiSNRjQmmNmpLzwX+rxHiPAgrqdZW6eRFklWCypCXroPxN1tTCzw04Q9S27qrwndjgqxkbsuZvpXDMvkTbQ3GvB8XMyV82/xF2nyHuWR1g2wRCMRJNtR2ddSVk2fuIb4RwzY+Ir4DrV9MjbXSKdSU+kV1fJL6nzKrtL/wCU6+47N/3I7e1GCVPtHgSnJucySZHPMysDTeX+R3/p+3P/AF+8uvWfL3eQ9iH3Wdzf/wAsCc4gRgTkqnqzEGuT5TcZn1Z8utnEEG1DWGjrq+CnQovbwz6DUcI7lsnORV7Xbhrmdu92t0+0p208wKNSqSnuvRf5C/7X1D3P9i9cfebd9oE9z+ZyUnmL5mR4TIlzM/qX/wDPv/6q/wC667q1h4WmsbdcNao+o/8AOpXq+/y/IwJbsmqGpGlUT1Zl4IVnJ5cMmuePmZMajgVbPLFpJR3eCaan8hbZodx2toT4m2cyZNMiVTtR/wAo1EoiMSZ+ISoiT5m3JBs7len8DuKOYo1JbJ5cLzqJLj06jZFtTzMvBPM1FajeWX32afga4K7dOYvAUm5LI07GpnVGyupHPjA8YXHRbB5Uodm+pkpKW9DzJTTp4jbtvkiwrvuL5a+8eB+DMaCcmf8AL+x3vqe26/J7XT7Zf4idVgwpQn23zETI3ZlcZbNvetLn1yOXgXhA8sva3xMRPIlLAiOSXoY4OFJ0v2kK5W3ce5G3t0Q32q4LX7iwx17HajlMZFh7+b8zrwykS/AnOvBeHB9ru1yju/8Ao/Vxf/0FWO3hJJTLjxbPqfq+7/y9wnRk2E+DT8CxPMTaMPhoK5KWRNLpRNdCEeY2l1CqkZxY2Ry5mmpN31kWcWJnDKUgUaETmSU8CUsUCgc6wSzUwNNYL5/sUVvhLxobdg1ifQwYtIiTetSZ42kdK/Esjf7jddja0N/OBytdCtbCxkbtRHSb9ENsRK4KdRkW1JURwqq9LZT6hWVu2/DVE0bz6+47dbkx7DOosQKzXuGr4f3evsItqJ1tgiMiTHtp0ilZf4Ffld318BPcOeGpjkYYk9T5nKDDxJoQNclwa5jng+NvYJoUrJ/F3snyu826jrvyRT4B1p8RldZhVJtbBS/Z7mEZf89V1DaXP8OZP0n1G/sl/Yja2xquW/0E/IzqOXzFBHIXiaYJehDNCzfFrlJt5GGZ1MaEti5Wkdk8nd7Ne9Wt1XG42R0o0JtqfUdy6dPq+3aEvLkPH7fvO4l3vjNyWZI7jwd/53Z/jdMMlPghRoQya6jqxumTtsb8SZydTHPBRrJL4f7pJjA68iEa4Opm1m+OQ2xs2mPgN6Ru250Op5LbB1suR04XmbsyQ1kmMFM8Mm16Fn24jH3FH2e1sSj/ADE6X/kpdf8A4s/gX7ff7Nq91vSfcZWRRXH3jaWIJu8yOVg+Z3PiIa35N3MlLB8xLQW0tL6uQlZdQlYdcbRNxrA/aO2kkN6jFzZGz8RrlkUC0H4Fo5D8Svs9F5giixw36s230O3ftzsf9RNtQaZGvMl1OvudI1H8clXM0vK8jt93tr+No0FVMxqYeSsI3TlijUnnwxXIvm16uR8ju99dx9zt7+WNMC24Rk0ZtJfIUvLG4wLhHIaTwVX7kNJZQrR1ewlLHF1bljseMnbMCsnFuXh7Dq1M2MD+YzfS6g3JyO65ihjV/u4Rwjg1wl6G4QmmJD3aEasXtOrUc6SOyeqE/mHkiZwRW5HMvNspm1kRgS5MuzMG58M8PIbO64wVbJszatRbnEDv3NBizgX82UJzk7tfo5tfufF6+0Xa780c6CoviZ8u3b0L1ghM0FCLOOGFgXZT/wCT1wLtd7195WNNCIyJp6kcmRzLT4Flz4P0NDuLmOWRyEm8Mn90nyrPok3KvJMdkok2zgfbrlQYeDazu/Qd2/VqiHgXiNkNEi3LUf8ApFZvA9zwYydPxfgO/c0/EjbHHU01X5jf7R9umWRX1/oUh4k8zqiI9feMwoJS6/y/uVQ1y4dRL0YsYk7kdzQxqeGz8TcNsUj7H1D6Eju07V1sktRvIlB5EvJadYKs2LU2xkzqRJlwZY+HSoQ/E+MxJ3K9yvs4Oo624OSWSLe5I0Oo+AhMVPAqiDt6EMgSnJZxng1RfyeuClnR1vTU3J5knl5jU5O0lbrc+rIT6RIas8n1FO79Qu33bYq3O2f8j6D6m+fqM4+4t3VqdqzfWKEWfmZ0IblmNPeOXDHDyjHxir3GoEO1mJeBg0LQsjqjq9CVwmc8IF3O6mzB279tla2gehDYt+aeRd1wRPV4nY7n7WVsnNGp9/8AYxhDzliSWg/EXgY+IhaPhLOrQXetpw6nk3PUTgdNuvD5lHDklOLMUELU8KmFgg0IRDEjqYp+Ad+3Z/L/ACNmRZweQnzNzJJrwWu5cM8cpyK3Mh68I8zOvBMyRzI5jVkNrjEZMYfmKUPuLQ0gUGTBMilD3aCr58Ev3HUn0jvOEdTTaZldI67pP5HmSzTyytRKB17iFfupPt3c7vyIjBHIWMMdGT3JspJu5tX1/wAzdyITFOg61csWOkat2si7fc+nyR3Pof4lznX+5332l8nv08fWBXq/mJMe62UTyNYSLeRXxQqxk3zqdOhtYuD441IaydL1Pl1Q795r2HUtOZs8iVoO0HRPzCduP1IvMrJ2+5+6vcPprWw1JZzgwuRLYlOB8M8Nc8MamWojg68ja/hyTI4F2+x2XZm36jsWr7/yOrVDvXQqm+RD1Nclknhm2cGC1k/gfDbOS1HpY7ncdvh//MQ3OBJIizFCFa2pEqEdI93pboPIgyLwNcPIrD8RJvBtXMlambSePoYk6hWG+ErjnQyyRtvJueo/ASfjgtPxF8ZWPvFttpkafxIjRCrJ3O1fS33Hb+ndt3Zpp5D8SE23JpqQ9eDOzTllE3iRKMI/j5iRtsTy0K21UneaU2lZOxetoWnvHbt/T/L73j+ouyl/G/IhsbJWglXRDr9wkljhEcuGnop1MamFM+Q+nBvb1KpOBVr3EK1dBVWh0KV56n0/a2a3R2u2qw1XQ24Y+FrDzKNRy8myo41QuC46FbRhHcu17jud63cSu+7GJle78z6W1rfyT+mfcO37mWTFKxwzw8ythqjI1NDCybTDMatCXMasvYOqsk/H9B1ayec8LNLUlalc8iVwW0a2NMUrBaNeGGS+XBzWZKx8J5kkvQ29tdbf4DrdQ16D2qWODEwK37WNNZHkhI3RDIg3MdmPesGKyyz5v8DPc9pSyHseDbHvE55jg79O52U+5d+cL2eZhZJXdi0DcZgjufEfLo/5BKzgVVMeIu3+ymuI/EdUssavqUjkdaJo+lofT1QJJbfPV+yNC3yuxyXs9seIqt+/JbtdxYQ5/wCLyX6m7u169YPnVcdr8j5S1ZuZl8JgcejAlgc6C2rMkY0J7n5E9rt40j9RdPIU6eAowmTOS31V89un5jdXkaWo9eCXIXZeiOrThganJEzYpv1JUfL0HFkYqa9Q03k3N5L97sqNyhrz8faPvfUXdrv3e7h06Hb+j7d0u5ZY9ykv2O7O5LEZn1+4XDJajEo+IULBzJeS7qZeJ/QlaGD5lWnRCv4m6OmSM8KOr9vkW+Xea+ZBDQlGS04MOS9K3e9fdBa1bZr4kj8BZJnJMiql08XLK3XxI3WfU+EQYWRW7UyhprhE4Hh7TyFZYaE2NIzx2UtCFoa5Ld16yTVkN4HTD9fz8i0mpg3Jtsw+sfVj9Tftju8jffLPFz9xPImNBbdCsjxk7iq428jESTucx7hy4Q7UtnBeV5jpe/TqVbUczufMecY8YLuuatOHofR9z6e3cr/6f/2Vemuq4YLRzEuQ+GFk+E57jUiRs2ciYyO0uBOpF1k7XbWuov8A9xrBts+tubFmP/1P+x2/lTp+7GNDQ8CBrh2737WLyam4h/CdKEksn+0exSNNQyzXgNczePlRk+I09TtfWdi23u08OY/qr3/ldY9i8CFpBl8Nxavdplxb3D26Cs0OtHj2EW10L0c7xpI3p8y9XhQRwwLdMmdRsnkTJTB8GTKFakpjXBIcqfQlir+5sh+I4MCm2eDvZvYbquWxd7s/C9eGVg2cnknhpHCENciYxp7TNceAo0FPI2NxDHCipVRk7af+sXcr8cCXMQvA1yPcsChqDXHC203RyO125eBmXk6NB+Jhle1e3MSmBqZXrqNNqBd/tNfLx7juWaaa/b6/eO26fRq1r6HmXxyRrwzyNzWBUo8czRzAoUX/AEH3G3Iu5yQ6Oyda1IjUlYZZrTw9cGFgs+XBz/p/U+W1mrFvfw/jyHBnjKKtcz5i1E2s8xNLED2oUNzw6XgaaMLHDEmhnUyhuz3ciK6EeHI6cMTq1PjBu7dsz4CvRwiRp6PhrgUsxq+E1fUYM6DJ5E8xJczz4bfMlGNSSUjOnoRz41UYYu3aFU+WvhkrLjz8C1d8qug8cdBt6Qb56xxzPGR54wp9oqrQWGijrqKr7j2jTcuDpPMb8jN8nQ8jtYq+6n8qPaN1rFfXkVjmTaj1NDcnJtTWRWlQNOn8Y/l/CiJftIlMltltkqu3T9S9bWbfiO1n1ejWeQ+OW+ENc/VDt2/cNJTYRbwYk30krSRRyK9uizYu2ovaoo0MsfsM+EEW0H3kj6a/e0fhpDHVajxn0KuZRgp4Ix3M+BRur23J8DbOTpwJOsoeyuCWRBIk/ig1N3M1MFejTn4m9TuSMslvJIvAhOUOXjhrkySPy4T+0racIab1F4cNsyjd+JoKVghctfSWXJgzaCd8kmGf7uGEY4pzrwTjLwJvCbITyb1lCesk0a940zdGCTqnaJrUZb2nkNjdp4pzkhvBPIqpyJzJ3XjbU8iB27SMj2Oak/KZ3X+2RPsYRZNx1M7qrpPowh+JWvbXUz+Xt44eZ1Gzt0dlJ1NRJvdMaHRKJJa/AVWbu6slHtGswLwMGpjQru0Pp3VLT8j6eHNkQzRm/MD8DTAtqyj+J/EK1XJXdT+f+/M7bu0+zTTwQrOVP4jO37ROMISpqy1b9t7iP3foRzFuzWPxN3M8hDY1yMMw8fYOUJWRkvuvEL8hpCq8Fauseupj/j46G2iwbYzJHBpPHpynjjCXoqa9XIzqamdCFpxcrmY1iBpya8ISN0GNBu/xi24Q1y4T+0mTt1b+IySZwiKZx/mdxVmLZQlt6T5nM/jR3MzkWcI1xA5/4B/I0O43yt4eR3fa/SlFbdzsNqdSyr2/5IyrCS/47cX0ShRV/mOFBuQnOon4i+YlkpOnMwtDt257V+X9BLmiUsjwJ+BC1F2+/Xq7eg8YRhGpD7LJhQfMVcG62DyNcEVWB9pPoZCWDBMwzyM6EZlstDnH3mdCDJEyzz4amhPj6Pnxlc+XgPGSt51IWhElaN4HPxD8zFRQ8GNBewzqiUsLnxTa9BxzFxU6DafBw/Q1n8B+CF4jE/Alkfu5ET1IVW8LhlEzkRuTyN28B7cG16m2c8OnUgbY6yOsalWtDGJP9p5GHodJEdRdSZyYUWgrdc6nct4v0kx1q8jnU7qqsKw1w6XkmYNMCnBgwsE+Qt3wlsdB3KzpU8TyG4GrZNGSxE20Olv+hPeysHY7jt27/NU9BZftN3bUDXMr2+38T8Tudq7zXBDGoweRR3U0TLOvwyaGpKWP0HnNkLbwsvIT5xwXFZzxyZ4wIxpw2vQd+S4Y1GbXbBD5FUtWb38JbtOuXz4eXpzy4TOfsJfbyONDXIvme4ULmWh7vcZ4RPS9RtW4SuGCx0smM8HuXTBPI29pxI1zO33ZyvXQXcb8PWB0nJ2ofVJtFOpygwiu/wAz4tfeNymh1WqqvxNzXp/LjM/cX7r/AGr+xfsK3Tlv2sxoKVkV9uv58FLJtYbo8ENdH6nUONDcPup55+8eeRkiY8h2+n+H8xpngiOSEqs7vy38ZVdztLdBN9YPIg3nS9Dryx7RWWCZxIs8yTptDQ8YVTMt8vYb1yMsZ5nUsk8FUjhgnbgfBErQla8VOhhyLAzpRMFfaSRJ8hcHbx9PPoZUkKRPht4SjVm0wpuOzUIWS6pbXkS9eCs0V+ZSNylewU6Fdjw1xpK5m/kQ3nh/sNiPCBoWcp6+P9kW3rO0q+22nGSbyXSwpIPmvtT29C1l7veKs9Q7rVG6tqx6tlexWdszxz6KvTFkLtruYQ7PUSFjU225lubKyzEYQm3LQlBDSKLdnUrdvpr+Y+3kg1lHzUuQlJXGgvEaepkghaHUTeDTAq+skP4+Zrg3L8fATolj9RK2kkNpPlzk2uJfuRWa2cai12lcbXMe4hPBkxpwfFN8cit4Di08GLx9GyWjMaCSNSncdpTXDxRjUyNRnjh59N+XCStlaGnI72evFpcNviVaJWDPwicYYmuDd6zVo8TDyaehWNRt8xbl1P34MaExk22fWJpdcfiYtn+pRtv8RusSJpa+Y4J/1M227RXsf/X9542Jeg32m2d3uWX8mfuRfvW/c5+wyzThoZ0F3Eo9fAmz1RlyiE4f3C2Jz951L8TZtnuvxOxV9rLKdlW6arPtLOcFuaOloRr+Q/Ew8SaDU8j5fkJanb7/ANVVRb1Q/Yb+Y8G56sr1RkiG0kTGRPuVVp5ZwVcOZ5chLc4nmh21NIT/AA/uS6vd56jbT3TzJ5C8OGgsDnihcfMkwvQgQueTJCyitXohW5v0Y9HpUG39vCYlGB+PpN8yGdvdZZQ6205ChGuDp09DBC0HCz6MrU3wb66syoKqOeR1pOw8yZ1Ol43GHF2vXyNPyNs4Q0v+TwMifNDcxbx5Hc79ns7T0X+5czbTHZR5ejC1Jq0Z14rhXzRWncpktFcEV+FGKG3t9tQSlyO2+6otP3n1f1VKRWkpe0+oXccNP8lIu4oU/kiP+v8Ayr1kWclX4mEzCh+YyeZ3+19b9LNvD9ZO++z7j6O/a7kuncVvZlHa+lV/mW/X+w93BpaEyWlT32l7Eyabpb9xuTatI3axhZE2uYkkx173bdbeY2aYNDB5GWIefQ0yV6YgcDTtC8Ry+MLTi3I8cJSwQtDy4OReESVvW2XqZ0LP0I5enLefQy8G18ibOY4LIvFeY09Tc/h9DXPpTGBbBVk3Kz2m7kLA2NM8yrjLMWe0+T3b4QlWjXsM4qiXMj731aw/2jrRxSfTr4kenG469B2blkui+46V1/oTVTQdKv8Aku0drs87Vn7i6r/z3/Qq3wS8hLwZhmBzYhkxgxqPdVM7P09yny1mSHqT4G2rhWHV15HQ3HmJW1sZ0PL8jbyiSLTqJ3tLXia8IFwlmdeD+xcinQdVpwVloKyevDpZZbp4MUMjmRy9Dy+xTJSM1hiZaPHhjgzUhSd/tUtPbusz+f8AYvXuWa8/Tng7Jkczynhp0rI7pa8jd5T943YrZaFrVaxH9v7j4JK/SKro/vF8jt7bRq8lu53rt2b09KELxJMLguGvFdjc/nip3rrcNT/EJqvTA3yImO3A/qu9WOzRfln2G2uHPuQndZ/IcuFwr45KeJkhKBtMTjI0uRqZSPmJYN47snmPtdhTePbEndq9EWsnnzxg5DXL2Djnwt3KdtusEEP0NTKkwQln7KvbTyOvJDElqSRJC1NOER1cPhXDVL0Op+mjGvDciTAnWkKDHDXhC5kxgcsUcWeRpgxw+I2ih8H4fqRI9Rp1w0ZRZzoyeOmTQh6GNOOOPkQuK8eOhK4f9rt9zME9xpW8xptezzHNtrHX6ftWvfmV731tvl9mPhK/T9pbKV97t7SzoltG943OBxofcNLRCayieQ2l/kbv28Jgho+ElIQ5H3+w9nfSifJ6lrN5Y918QKGolctFzbFssp/TxNuuDSGW7fceUvw8DCNRehPpY9BNkcieMj/0nkKvIl6nlwc8H6KbWPQl/YNrjjgkYEm8cfPjl54RwUuBJVIMDhwTHUNwQ9CbYbZuZkl6cNBuMSYlGRN6k0pC9B8IjBPMh6cI9Dd2O5KgdfrKOqK7+00kOvd+l7uPMfyPperxeWbfX8CXYlvJ2vrO9VT6/pwloiyarAu9RpufcbLqGtTCJZZRga5EEYwNchKxO4uk86LhiuB7sItD65Jb6m/yHfbNo45PISb09BZwNtLThnh5cNzUqOGmBYJ8eETjipXCs68YklR4elirFV+ju3dXhH4+lK45Mr0cMXHPCEyOLRJ5m62o8ZFkUrpHBpgsl4mRxoe8i2Vw82/Qxw8uHmhWEksEc3w/3eA1wlamoso+Z3O47W8X+RqdTwJW/sU26qyZ/wBbtf8A9i8L7tTFckbTQ3QJ9t9TF9P33/Ye7PbfgfCpJE+TFZPpIoj5tbYpw3LUjnJbdeEOvY08/wCvDqtF3XC8faVrue38CVoiVDMiGY4ZM8MmdODlcxbE0ydGPCbIbzwla8ZesDU8G0Z9DGvpWsn6/wBjFMeI0uL8vSb9DOoo1Is8ehPoaGVwx6Gp3H3FZd5aeHtMmHkj92v9hKMJktkptfqNtFo04fAcyZN0KB2EefoStSXqJtGhj0ML08aCfjwUM8z/AHcG+RjU6lIl2vqvlPz9fcL59sevIQ0x7SKtQNW0ZWbYKbZ1LSRjQ7P0j7iq7eI+xe6utUyNuMewS2zQ21hL82TVdWPRTehDtgcqPRlr3GELaPPoXVWpqNW0LOOmOE8vRzr6OB1KVac/gOPh9DLx6C4TzISUjT5cM6+hLrFvRRHIjhglPImVd1NFyL2l/LGhNPrqd2vdpFyvd7dljl64Hbblt+4StV7i+6uYIjJa6pitZYp55HqKCNWOVJuWq9DOg1OOD1n0dSPsF93DTkWyYeZ4YieD6SINjt0rxG08I/jY+5mBt6cZjHBuNXjzP+7ud7Q0q88/p/Qt9R3rwtF7HkTrMjzFfxknEyLrf4DM6cO53+3257dHkZLKutnuNBJF6UssZLdu66kIyjBk8+CJ8TBt5MYk7aciefo+RjT0J5mXg0441KtVjBvvbbUd+09yGjIjyKXTLXs0iu7QcaFUuGdeOnCR8cjZqeQ2tDbOIIXwHxS4EWdVmGSlnBNlKNtapZ9onOSFmy08h2Ys548+Dh44wJmNPQhcPP0nBhOCReM8FkbIqWPKOEkts6a5JWEbrZZ/uFGp2/Y/zEnoOeE80Wdn/X2Dl9P/AOnwwVh4ZsT5lt2pDT+4wxnkd+nZs617vxefmajngmizbGu88Jz7S/derZWtoHJpAiHwqrPo5lmvhnHDCEv3cOr4eGVn7DPpUXmRyGWXFVT4rGpOySY6jGq4JNwOPR0NTAxwQyDo95KTYtyxnl+BvzA204OpGmCcQiirONRuTTB0zBkbxArTJunI9o6uunoStPQlse7wEdS6fx9DTAk6mETA3B5CT1G2ajVXkzxyKy1HS1pG4E05ZM4kdlVTyHerwTy4Q6yiltuEjTA84/XyMKJFZ6/l7B2bepqY9CFrwjnwyiy3KUJSWnjHMjdkQmzdV4J8ROOsXTGOHSscM+nV9ys9scaeh5istUJXxc329xa1tH46kG1kmLdQpqW7jWOQ1E9sXd7eJIfHzkqkiOY+CjjrgkjnBLHtE+Zt3ZHVKSY6hOeQmu5hPwLqv3DT6atesvxNztPHp5CbXUZ58Y5jXM3LkOzPJkogwIfiQ1k041ZC1M+h5GMjUcMegmzLMLMm1xodWRpPU1xy8vaRyK45jT14KrWv4Ci2R7VNkYK+LZK4Ijhrkg8iduEOdRDfBOMG6cEo6UYk8kJfuIbybVouZrg+IVtUf8fVqIq34faQK2WNrVmvFK9dNCzwzzHAqfcKu7+5TtPVjqnoSY0NvKR1aTRJPMeTPCWf7SORHIlrUj9pNsj6RvnPDThJa27BfGolt5EM3Cs10xqfTz7zpNZRg1F4kQLJkdskNZMKDD9CYengY1JfGOGVwlOGJ2ZjDRlZ4J1Ulc5L6ejJ5HcXgZUM3TmB/wCplVEMqkptZe77yu5dP4T5eJqWfNm16wZZPPjoNvU2RqNOZMMyuFqtG3wIKN29pZVzkgbeeG16IW6zj2GvQRYqqvJLXUR6GfsIO37fRcaCVkN0yhSK9XDOrUdnfI3q+DTTkd+cC8B442XMnmNc0LgmirpozUgwNTgpjJ8xrP4GhCQ1yQ0rdRMHPdInzKUtZ7U9OXvP+RSvyE0+kwacMomM8FgaSwO0Z4Rw+P8AAzqW7WxRJD1M68PM1Z7z4o4WnUcqUzok0gT5CNBtp8FjCJ4oToyW+sUoWFH6DtpT/wDUzarYY4ePL4V5GOCSWSOZMCnTjbZyGmjKGja9DLhFp+Iy88OjUhMqxrkRyJWrGuRgmzJWg39noNValKSqss/mV2aCkjhrnhGR5wVS+EtTyEzQRW1n1eX6jbO2qU018ya6lPl1i0Z4yOeGTyJaGolDVl0s3cjTI01kTSyYu5JaLPkNyYWRvmzLQp1FecHer9f2W+06RVrlfx8558iTbz43SXmJtwh6+46VkhRImlKMMWMMxbJqjWXwxw04fEYFnHDr6UeQts5Mo97HvsiLMftF7TLNMeht26lTpYtJEnpYoq16qrPi34mhz+8nyNy1E24Rc0Oo0wNzkXjwTdBDa8eKnQ8hrkNtGVgpOUiIySZR8QvA7j0/UX2LE4W+RzVEosqvPo85I8yUiLVyYsx13PcOFCj1/sbnqeNpN1dB7rmnHalkhscaGTBEYL37dZrXXyN1Xg1HlqzNdENuNyJSHacHVpqPuJuIJs3DyLb288fIx4Mr4k7hI6TOKmcZ/AhYUHS/aTX4BuDI3GRq2kmDzJepkxwXpLJssuofgNNdPgTI40K5wNb8GyeZGDDUl7X7m2Brh1EslrJVVSRZPMC89TzFVakxFZIMX/AhLAp5E8j+T3CaWBibkyeQtmparWplcMmCe7ryOrX8B8JSzw/3DstR+Rgj08kDI5keJV2+LhpIoWCGh8Em8EzqWsU8jbMlIqTyGkm7SXUc/QQ29eD4Me1tN+v3eRLeSZNeg6vE3WWhyX3jUe8sqPH4Euy3feTbSSW8GmpD4OTBl4G7nT4+AoPFjdqx58kOlPq1bvi7U/eWcM23Sgfe7L9fYbe58RjThn0YHBoQ+COZZTieHVlEqBpvThK46Ic+ivAkTZhE9t5H27LqF4G5v+T9Bsk6tBxlDqxbUK2/Ghr1HTls1ZW1bZWo2l0mOGNRVepunJ0vhBoOzHgn0EjD9CB+I/DjpwmeYuj3kv0I5IbkUPLN3Ie3UapoSQviHPbx6XkeXCOXDTHDPJCcsapj3s2q34lXM2G28il4GpUe0UUeDqWRbmeZEwaKSWNvT9SDsXv00XxHyqNLtzhfqxdxXiythrn66D7d/wD+6sN+cC7Nkpj8DKyvwHecDxoOqrpX34GpNSeRofCxbfwM6ClwzXJnQ+EkjW3HyJ9HzJeg/D0FJnCGiZJZg230GkWvBNq44Iwb08j7X4nmbVrzLeXDHwiVHkvZLC1L97ttba/eOttRwNNSa5NTyMXzxn7NcG4z6GTHwCxngzzHs+I+Foi6Favfi8T/AGLduDDGolM2xgXpYGe40Nytz9WN1Uoz7RWnpIq8+H9yqTSR1vE/2JbRBDiSFZUrPr7hRWbfhA66lciS0glLp5iRE+ZCWRdvSayOb9THNk2djbb+K9oftfM+ev3/AKEp9RBk7fdesPhrnhnQrNoZMwJJanwk7TFZYmdNcD7tHiOeolz4NL0UzdC9HPBEsqq1EohHW8EJRkS7bHRrJqQniRYyNLUyK/NjJnp9dT3nmzJMkrQ7lO031Lq8PdwzqTGBNaccGNeExC+zxqJozp6W3lw2rLOtaI/k0IsxxrBR2r1JF72+J8JElw28+OBCMLofMhdybn8tIMo7tH1LuP7vAyslEq9Q6S48Sq5oqm+X5EWcmBLmxtvEELT2wRu0HGp8xToRYxwhlFH/ANayOmpOW/yOz/rV6/mfQy8Njdo/sbowM7bnI2ZXUZWSFMm61SHWTKyLbkStXJpoQmtUYtgfzF1PEDvZYjX0c8VOnHLMGGY8OEI7l3oPOf7ne7Tb3k+BHMnyMrhPmbeZMGPebWsny+Y63FdIV3w0yefCbSQbVbBHPhzI58PIfBJ5R/w4k+Z2n0ccPPobHoyOFq2RNdRSiHrw3Mb2yNeZabZ4KfhKpThmop0fFo32Saa0LvlxTKpfExdtTglIq2vg5/1NdDJFdDQzqNJ9Ro5FZSnodWo415l4ctTnn7DrJR3bzmuhPc5nxKSafF4m0mJaWTtd+jW3bkskoSZZKsK34HYrZp9rt23Wfj4Iq+z/AMFOQo0Q+9BHM7ZpoTHBu2iITwJIiRNaiKqPD3nw4LbvgzyFbtqLodu1E814P26+Y6R68zHDJu5jJn9Cm2+7BG5EGskVUM5ibXBKTuZ5CzlpG5/F+ZgyxpGig3rXjt5jHtr1eJD+IjwJeg23kTK1T8RvVcPjNztiSFwzoTYhLJKTkUonlwSs+ZW86CV9Hp48I5HkTOeKaeTwfC0DK4wzyIjI3Y7aT9puTEraMtBt5mNTqkVZivCncq9LDukk34Dt+3aS6vz9fAmzyNJ6cKJeIl2+71I7buvhUHcq/wBxhf5ESIlKExts6tCqTcjq8HVoKuxJj288j9o84Pl/ssLOgqpYRtekijwEmP6Xu9zb2+5o/B+R3e2+30wLtdrtWXbfxN/sPqP/ACvobr/s4b7n+4a1fHeO3gWfBJOC/wBV3l0+BqJSQibaHW+pja+I6XCLUa0Em/7Fvpe9aO33F+PItfEP/Mk5i8ja9Gaj6BKqwuNWkO1XLZ/JMjbbbM6mNS7t4Cl6C8h4I5ksqozP3Hgjp1IrUlaiUFfmCvyO33N63QZp1G5ULQuZuWGJC2kbTdB1cM6szoQlKY00bVEGueHmJJyhOeg8uLnlwaWgmSjDwefCecQZRnUk2WT8RT2ya6ilSht6jWz9RuteRSdJMzuFWlRKuqIbyK04IZ8QlqVtGBcmL+Xaitf2ohRsJaxJ5D266ZE3qbo6n4+BjQbktBuWpuM8E7NnTnhsnUjTH4CjUUNSvwFX6ui7lk8TP6HyOxT5S/CCW5Y1xfabTR3LJ5GNwVaR9c+ZRv8AzItmH+Yq1Kt/Ez5jaQ9tsl73viC/c1Q+5OUz6f6mvdiL58T/AMn65rqvRT93qxq2poaEWPjRqLyNeHmZjgmtRNoUaiTagVlqyBY6jLRlEMaWptkkmB7yKvJSsYPFDb14aH8ZbubY9dRbZke47u6uDdBPBuzxwgquS9cizqRzJ2yKENfTXmlq5nj5k2T3CkSHwTqY5itW0sm0kNuDRiSWgnOH+A67jCe4cLBFia2zuHdztFXlJRzoPxKtrqRhcO53X3HKGuFUdl93tu3aTyvIdvpsdprE/kN8hKYbJrG7TUXhAlnc/wBC/wBX81vY4defhqXpChWj3DS1JY1OCsMmBtocaiyRzJNTcS4kyzKKuemDbt5mo6rUxoLud3U/PhECcan1pVRlF7MVVXqgVIyeXtFLybGm2SnhP1R3HMFaKd9rI/8AE+l7mL/KrPtakl6/YdS4LhWzr0eugqWUVT/Pi5b1HXtalm1t/wDSrfK8akOdviSliSUTzGvEo2p7P7ju2ov4BwvcLuJY+5lnZ9SF1Z8B8MajbN1Hgd2zq1G55Exg3coMlrvtzVfiOtaKvdL9uyGb6PL4RzPMl6kjeiEi9O2+tFq21qaC8eNNuHGfaVSsQdtumB2nBNdTxtAtujGZHmBOejUVkO0s2rUe3XjVrSSyS5CaZoYWI/Em2rHCPi95MZ8RJVlkLCHat5g71fppr275cc8Crv2oSTyO8rUU6kxiRQPcyzT8iUVx0jZ5DrGSP3SzLwQuOhLHtRFrHlwx/wAgqyfWfT8mpIK15CW7B8yz6JNMDu1gfcWopNnI/wDO+jnd2vmJvyj1yL6dLFHjwxj7HOeFar4haZeP7nd7d+xXuWuoTelfNeZK5/pwjmTuaN3MmcnUsslNQRd6k9z3Ewc90CXIyi3iTzFKwONCGpR5kftIWrGmsG6q6T4MkVI5Dac1Rfs9xw25XhBW7thF+5W0pohai2vqMG5vMi31OkVlXCKt/EPoyPudu0e0nuaszqf7zB5j36CaeS25qUXtaIroOy0Fh8FWBqMGDLyJTkabOnxJ5kJD34Xka4Zh5JE1oyOR0GeQsttaIaSw/X3F60yKIWI+5iVe5gmcv8ia2bn8DluK4MTuIsdR5esQO0GOO00Ig6eXiZrk3TwhOINccJ5m168NCxMF4xZ1KdxuGVtbUd/mZYlA2bV8P3kM6nCFdOVRH13/AP0v1fT2q1a7ftev4He7retn/b8Ps+nEffwlPI7u0jGJkRzFtqiLKRrOzkdSjB2exbtL5/rqNLkb7NMa3R2xN36iXrwQ3yE1qKyeStuRtlQY0eB9ldzo4dI7NDfIfQvvK1pMydRhYJLowJvQUM6DB16feJ1Ex+06iSs6DdstFpRunR49eZsfws2iSXM8yeUEZg6f2inQW7goN/8A9Rv9YOk16R0iUadC4LboRGTA/EhLqkcfuf3cKulc1PeKkaj8Dqwh+BFmaMa5jifRwOdTPDQ1Js0jc3LNzSx95rg6nnixwLvVfUvyKfUdus0Sz7Sy5RB26xohK2orcjbmRWssVZjOPwPp/wDzfpe3L7tqrH4+5H03/gfQtbO3Wqf/AMoy/vn3E21+0zwfgYFPiPcoPiFnQcrJnVGMr2/kTOfxGn4GWuRt5Eb5qjHCBPmNsl1bxp+or2p/G2SkOi0kz8RpkbHWxTBbzZFsQJpiYlOENld3M2tY4ctp5MheBviGOCUx8zavErDIbxzHWtZLV+XEjtXNR1p8XMvUiDZVYFXyHt0EdMEX/Ah6GyMGpMKfErRrqLvA3aTOo9mGK7+KIFGknmTbW34Hdr8tOefmuEJdUCVVFuft4NNTVG6RYwZ+8RoNZ2jnmLimOprHDUcOCW5yaFcYH4N+hKFtYpeRppur1Q+92r7u2O0uScxI6zBLt1E9yd35nb+n+j7Vnd6/5Iv/AOr/AOgq2/8AVs3sWP46xH3v8DufUX1b9OOZEZ9BamBRbAq7MGhBD0Ib6CW3EG3mV7F/qF2qqrs7vT2e8e1Y/uPv7m5r+EHTYe7SSyjmuEolE8bKMFO1Vz241FWusGKdS8StmLZbqNsdUHdpaidn+BA38zgsFU9BnNM6vAcG6MmeYlwiyyKdDQdUbnodujHajyuLpbQdpcQeRP5mmTdOeDbGqnuIuxNldI5iq4+XzHNmrG43N4N3nwaKVibFocYFVKW392CyShSjq1nkVSjYWddJLJ21Ky9cDMyeZ5jwcxdPGZxwbayyG9CGbaqWJxnw/UVq6GReRCWRibtkW1CexQYZl4Ey/wAtJ1eGraM22/iv/wDl/wAx32t0fNOeR3I+nu0dP018c/0Hf/0fqkn/AKa5f36D7f8A5/Y22jNsbvy/Iiz6fsISJ5mVwmx0o2vUy3B0vhDMMw8orueUxuWqi1af3GUYZ8UDnmJEcJ4t8uEV+IRdq+YKV2KVWBJaDphwTOhobqinThdorKwhbWxLMizgwkkO74Qb3qKWYncNcyXod3bbI54Z0QnzH4wiVnJ5TgnmLxM6EPUi7Jqdr6d9yH3B0t4m62hI3a3WvyE/NFk1wdKaDgaxIoeYPhhVJcupVbcIfdeZ9YJdBYydbZVkW04Mnhrw63KNva/4+PkNGGSVOi2BVjJoQ0ZeDWTzHKT9vDUlMkXcoplZTzPu9g/46J+VUjZ28U/E67jruzoR9k61OiueYqI7XcXLlBXu9ysfd+g00k/AhQbYIS9fEjkLGRpLM+4cfF+HuMppPlJhQhuDGLG1PHMxoUhRfn5j4yydRMklrkPnUdXmpo9Dcl0m6yHWxiuBcHtWTDPjE7LBS9rzZm1OWO11oWTjb+XsPimPy4PORu+oxtsi3wkWWTbHIbeg++3C0Ld1pwVul0IrnhZt/wBkfEPcoNqfWKz1g7dnaXH3DvZcvvJqs6kchUnpPeI1wjLjw4JNYIbx+aJtf8BKo7Jpe422+4zYQ54TzFu0HGgpMcY9L4uEasT5D7jeGaDcjlHw8a+B/vGy91XdVMp9bTs/LVe03WziVZLy8RcfmIfjr9/2TuW77XxDhSKrWTU6a9JLqTBE4NlvhIg7ynqmDbEZ/E6rGGQ9TDxwW5k8yEpb4ZfHGh1KSeZMYNsZRFcmm3I1W2BJon9wo+JcLwueBVLdvto2dyuRbtR+LF5HyrKPxG6LBFtTInVwy9LZQ0bbLJnNSFXJXuvt6lurT1yRbQfgVcQLwb/L+p1V6uRuazJLq4IkU/CblVbjyJajxPmcx1a6jp0EknuY9HwUqENW0F1ZXisFVVzjJpIm0nbxN3MdEsm5al09TdybIWhz4Y+1a8Edq0evr4nwohM1Jnh7uEslcLfS9vvtfT2/Zy+7TjoaDT0I5elhYM6mGNxzPo7Ncp/ExWY9YN23P4ixqOqUmsyRtcQWipujUlrBe/Is1zyWT943XCWDkyjjn+H9x4wNf/XPqisaHb73bvHcTx9xZvVsQmraDbeOE+ZMEJQh3rfJLnbGvn4ErUn5fl6rxN3gN215DLSuoq/3FWjdJ09s3WE1wfcr8XgO7XWzt3q8CgVrLhlk7sE1t1Hy7OEyvZp3ehDdP8x8mNTkceP4Da+Fait21iw+5Y7lJmltDwoKX1krUc2M8yLYbMD7TqiObEyN2Rdu3tMvQdllLzz9xaE9jgtKSRW9FgtaXH4D7j0SE22NrNtf7fqfT/8AT+o+ZNOryb4+ZtNCadvH2bR9X9L+1qfuGuSK92cm5vkV5QL2CjTi58Cfscjh4IfoYKyfRK66YX6D7qrj8hNGE0x9r2s+fSZFnUnxItoJVwLtr44OzSP2ibeCU88HXnIkqrWTFcCXN6iS4fV9yn1FK93s7U0/3Tz9niWV1lOCIxwgs50N9dUfNV4aZeyUJkO8ITcm7lOo5cspVtR+I0lLZ27pv5sZTFZOV4jsu7HlBt7byinbeWoLme5I7NzVG5LK0NSqqS+DL21ZRLurx97JHGovlp7mZ1J5muOY1VePC2ySOXMrtNvI2THtEozw7XdeplNRoNJ55mTbyG3EsaclXL/r7f0Gy7q8WUEvVr3L+p3qdrW6j2jUxGSzOpmLZPLhEmeF/qPqK2t3F8K5e8reihOWvCOaO92+18Kf2Ssdu9f3c/wIepVtZPk9pdPiLsTzKvnBnUlMbq3Jf3ejpwZNn68xZ1H6a8D6JVabqvE6mPtMdTDepbuTn15fkW8RIUr1YozU7Fe3odzt6wP/AF+wfDOGQs8Nz0E+cFYeuhZ0lT+J5HPivA7Vu1zJUkV1FWcIxYe60fqWvC3KF7iYybObEq36UxKx06mfiR2bWtJuob4SpyJgbWou5dZOpqSK5LPlA415HVzMMU6Wfr7C8PAn2Upa9YO1CVO8vEd/AlKVZamFj1ke5uEYN3Iix5DfciCYwP5iO5d2UM1dvM+o24yb+cGkEKqbHV6LBKrnwM9twOdFkdbaNF90QtD4cMsp1JXxDTPNk8MrhS9n17nB9R9T9TZV+nrVKnLdPLP3n1H1FU/lN4+zzqo/yPpb3tP1VW/w8R8qsb8B92cxwdRxoNfuNeE+BhY4YmBFmn1Hdq/p63tem2XrRz8S8xZyRJMk8ieXDOnCL6FO3pF3j+vgO0rb6yLu0bx65M19kFuyrZH4o3NG6FEGqHbwO99ZZ5rj/LxHdy3u4PdojwgU6KpTs976dL66urXPwZC1OUaFW40NyaklvBONvDXAvDipfFpaMXc05GXkXJeJrgT8SjeqOmYFHwiaROSGyZxBjQfOomkVSUWLpLJSFk26jVUNLA09DtdtPHbYml0oddkr1gfYduo2Pkx1cKeCElTP9CeQnMKRbl0HelL5eq5e4s2+plbWsY+DhusVt28ZHZmXC/Ey4FhMWXOfaRY1wVb1RMonn6WylU15r7jb9R32+2tK6KvsX2klbWU/TtZjzH3vorb+x66+8+rq21cjvPqj7vAW0UwkRLb9YNvcr1GRcG5yeXsIkwNMlM1RhnwmNDGWOVwyjY3zHbvVfybWzHl+4r3e3ZWpZQmWTyjCwPvLQXcfNDbH0cj5a1H2r/Czt/TUsNIbdck304M3OYHnrFMSTf8AAdVrI7PQcr1/oRApRl6Chmh5cMotFoFumBtcyqs+eg+13KxuUijQiq0P9oq5O23myS9xd20MKWKrWSXpJZPQe/U8j5botxKZLRNMcHjkQ7YkwWXi/wAsm6r6hdwUvA6ol6nzZMeJt7r/AIzp0IuoLeFR1otGKsFFulnVrI/FSNSeDIqpJbgqm15sl6m6pP7yXrJh9R3rd93+c10RpPmS/wDBOjWDf9J9U6P8J9eQl/6P0i7lWuXqvaW+V9VH4Z1H4mJky1tevgOsyzPHOvDu3qm0oHRaEMyyW8cGTI5QvCRpGhqbbqBdztqey9Vyf9/YR2KxZHyb/EPtN4Yvp9PzIZbuPFY9cDdLbvXJ3fqvqKrczud285XB2teBrguCrqVhuBNqBVPPx8TcnCY0nNt34GhAo19DyPKSWyPiLU+p7W6n7Wi1qU3Ur+XktRz/AMc6Efsf4CbLzl/odi1Hmy+HmeBt+FlfAVa1JZO46XnxMaG1vhpNPA3NSVSWBVSy0S0T4Cv2/cP/AEv8z+R5keDE1HRanYX0yw2nb3M7VV26/OUpeS/Ur3I8p/sb13eodEtv6ia0gnd0sW3mOzTgxlNChQyX8U5IWWRODb+0S3yxtvq4Ruwamv8AhYTM1heWph4g8h1mGWT1IcSvQjxLLt2iSWK1uZEEcFVuEKR1rST5iplaltrhnOeOdCvc7NouLt/U/wAlSfpfrYHZ3UsfZ7vcTUDntqUP5Vsm6zcc/Qh6llz4qTrZu1kafITfwkbtV8PmV7sqTU10K7m45mkEyZ04pV5Ih6j8EWt253PUhvM9QlW6jwKVf7NSXoQtSK2F27rHCIG418RJ5I5CotINsYGhWqycMdVX3/mPtuSyV808dDcnNSH8JuSMoeTU8Sa2mTwr4eviQ0NuYMOXArpYFDlCbcWkr21EItiDVIirxzK+BE4kW0ZLQpxUUEcv8QlzggfUp9fI8h/eJrxQkksiSWPAiMkrU3XPMWDURBJ9P2XpTPuOgtsIepu9BrWouiIIq3DMYHLnglwxw3E2rw6isaiqQYkSprORJrI0mTvY1u6WyKQQ2jC45QnyJrlFUa6CtVz3GhzpJqkZriR1aISN93kj9x1PPkKfA6UJzArIeCLfCJV5E8ztdzt4rz8/E7m2qmr09o6dxRBBNVLHX9w1YVbGWRODXAlXV2grDXmPwFes5FVS8Dcwkvc2Otfh/IUaDatCK2dhWWg9up1aGPh4W7u6u2rWJzkW7CfnP+K//9oACAEDAgY/AG5wNp4E2+ox8RKPMmMjg+X3Hjl4CyRtwN0+Ifb78vtp+vqxuN1fyNU2Y1Iu17jaJdldX3/cU7vf1/GeQliSDFieY/sI9FfK7e633EV09BMbdiKvA59WeRJ5iyPmLPVx28iUsGB+AknwhvHCeQ8EWeRWnBLWCKX2W58yq8oJWpCeTBFdCEsk8iW8Dt24fbf4iHRXbzz9dDatT5e5bkRXUWDHMTtXcyEmeRNlJBVLRcJHHCavBrk7K7Oz5cvfOseXmONBi7dRzrwdoGhJLIiIwVS+Ia5cK+Q4HLHS+hW05PP0J+xnuL3DXco0yHCIq8G126Tc9JI4Q9RVu+vmLwINl6rJa/YvHrobfq/p7Wr5Dp2qW3eeCu9Qo5E2t94oohJcuONPSe0hrP2OVjjglshWe00NDyG+R5EcyUJoVkSWjUmTp1IjI7GDKLWssDsngx8QrN5Q7J8/w4Lt/wD2wSYL/wDWtHeZ26dz40JLUTb/AMhRio84bF2+2ltr4CSWTqy+Fe8n0p5JQ4fUKU93BEt5Jqxbngp4cJPLg40NMktaDhxYSs8jddTGnC8PkPcbnxW/ur8zd2+9W08nj7h1tWEZ0LRoYZjUSb6kJmOGOPgvTfcZHc7a2+wT+lq4WRpxJW3Mo5zg95PKeG7kbqvBNmdz/wAmne//AJla7mo+Fe0tVuVL5C6DpRXbEwNc+GvoSSYfDyO7/wCn/wB3d2btv5fLP4e4do+x7nzO2lVPDnVeL8BpaiG7KGvxJ5ENmHy/Aq1bEfeTb4kPwMR7yY4YEn714rhDWDXIm9TPxEDhGDqePDk/8h9uqisir4CW2Kx9/mYRjUbUbjQl8yIIquoUTPnwdWsCpVQq8vFFrYXDHCIIQ5b3G2zizHGokxtGo7N5NeLTWnBt0bUchQowTyPE04O6E2okdVyPMyNWNPzHTvP+La/vekDvTtTaIT/dPkdnubm+7LrGunMVuRhk+BP7vzO5VvRicYF4Mnh5+khpLXh/I1Aq05jw4P8AsVXS9STL9ckcjSRW5cHR8tDqeTud+tEu7ZQ3za8/YRItryNI0wYZEER08OZlIxoJz6EcjX03jBHB+EGXjkQzbJMD2jiTLG4lis2amLcFZaocvPCf3c+ONRyuENMb3uHyHBrhGGeFTDE4JWpL1K23HcnQ3IoN2eCG+gijipPG0fGNfuE1YXbnTi86EkL4RWLV5iU4XMaKtX0O07PN7bV5vwKw5XMa8X+BKtZozXPBlnGGY1MmmSvKgvqPp7be6j5fcpFtMfnJTtV7kW/M2+HBso6s7rWknzO9dKniV7tbJ9uwuOSV6D4ZZ7BWVusdu58RbtWRekdKZSDKyRuwfFkcPQxaUa8cmOERgadsejqSacc+JlYMelqQnkaSySPyWop1X4m5cMcMsyQtPQiw1BjUb8CFww8GEOHDJZblwl8IWg0q58fQe8ccGnox0tL7fgKqmqaKJrjrlcE0ulmhbuNaFlOgqt6lqxlePMXjwWcCsmLgolIcqSXoY7rlibGmlgSTk27TeRJLJVYY0/8AIgaSyNNYLW/Ey8cNMHd7l3zg7/0v1Ff4b48Ds/R9qz+T21CFbmaCgQzXhqQebKtiehLtkWCUz5jcO1v8yibxBuVoQ2+4TuyTMnW2VUisJJYNSJJ2NG7mTJFZkaaya6EbjLwJxkkyLwOx3O1bal+3+pRv44z/AGJRPodvaq/9eM5yTglfEPkTOGOsdXgVaQ5yLhPM0NDPCYwZ1HL4PwPIzUajpgTayPGOGmBrkKj5EFYfSKHkfCG88dzegs6kMcrpKVVJ7bWX4Cqqez+ottCqbyyHrwtvWv4Da7WI+/yKd21HW7bw+S8/zLPxFb9wl+w2xjaIhGsSOrT9vIX+oyONCpLmZLUawQ1qNPIrNRKHRVyNNE8htaFe2nqTtklrjZRpgmR2bk0yTPGOXCBzxwzz4udS6enMi9+heJ8vt5p+g+w8Vqirtrz9Gzx5ErQ2tZgSWpkaO321d44LOBLwMI1wONRSQk5IklmV08I8RwLhEcEuTJPM+nf0/cS7M9c80uS9ontda10H/uZVxzZ5nTk0FB5mNTwZJLG3YhE8FkTRE+hnQTSLNLMcH4sTTG5yVUYRjXg3GDetUdXxCJSOnQ8+EWItkt1RWDWUbX4E61YkvEViF8Ik6jtOTbZdQ9usmxXW4wWb+EcayZZue7HgQsqMirHSTbuciaV3L8honlBPMh6mVwcEcE41RhQfKpoyXpghwVfivRr4xxmVJg6jAqU0Ieh5Hc7jXVBWj+Fsr4mSEpZ1UaYtTzJTwSmaqRJrQxXBLUM/2oaQ1yYlBN6p9k0IgzJyhlfDjnQiqxPCJzxSNYXCRLkPGJFZvmy/Dp1GacHuU14QiUNq2BbvhJT1MLBAlDjhl+hk6dCrkwSSngnkS9BwheHDbzFkbWqIevFbfAruXSzGBbZ95K1G+ZLeR9xU3eR1Zt6/iK0OZE0swSiXG4T5ExghGWSvEq1XmNv4pGnqvwO5Tt47V3uftFsaY7R1I7itXIrpPaQx4MFiZJkdazkm3xFVGC1k9WVXJEtZJXFjI4bYI5cG6Lg7XtK5otta2+zwMrQbbHLii5mzs9lKqzvYmnVio2kk+Ri8+41idTa1jyN7+HxOz9R21b/rd222l8Q7LVeK0eXqWo31GRJMcLgs51/CDWWP5l88ka/ifH0DhRAt1sicmeErg54Lc8jXIo4MMyJSNc1+I7GhL04PYsib1Gnoxw+kSOnQk3QYF22prA00aENG5ajfMtayiPx4Qx+0c6M3Rkl1HkrNUiEaEdv4i1u9dxykhaCxkcJmNR+I3OOCl8J5cMIkSk3W+CdPEr1Njy4MLI2yWvcJM8mLmfEaqCGsQTzQ6tdYo1Kxy/L+xd9vuJ9uuPeRSvV6yZT4NyLwGhj3rpElVJnkiIwMlCTfT+Q8+go8OG1cdcHTQtstDG7PI/mW9w3X4hPvdzQmcckPa5X4jlChYEkLhfsW+FqPezt9r63vK67dm+3mZenuSWIHd/E+HnwZbGciLbXmNRGnFSQdKTfCeCMs0I4NjcjfIVDzEmSeZBGBD4QVSMaCafDbVdI2+L8ZM6D4UjkiXqZ4ZU8Jxw8iz8DcnknmORslrHBKvxTx1MMSZD1KdXP7iHoJLQ+Z3bpUHbtW3ISFuZK0Fw0EZeCVMDc5LNPDEq1S934icTZijmhJPJC1EZRlfeKdTKN6ceRZciYJ5SSKrISz6D9o+DZ5Ed3sm7sWixvvXEEv45FZixgSbcoWxfiOvd7fWzY1CFC3P1/I6byhnxZNr0gnkYWeDb1FjJNsIS9YOntp6anj2/xJ47Wszx6mRyMmEaZ4X7FLfyVWZ/TxNsDU4PI7t79q1GrQqvmSv8i83UMloyWTr/HH3+HqjMQaQ+Dhk8htiRGgm/iIgdnWTBg1yf7uCT5cKrhpky+O9PMacI58HGgpfLhlYMIkVrakbCeZZt4E54ZZuH8lp3/Qq3hny+38at953l3aOrdtP1FOo6WtlmYkTZDG28HgiSj5SJPkvX38In+o3fNjyMtDaiSsolVkmMcHJrIzI7TmReAs9Io1JM6Lg/AaTwZMGRUN/arKO5XuP+SMGxoTnIrI2NZkxWWPp/kOmsdypZW+JC8DGhh5Ktslc+CwKEJLUXW8CXeeNPe9B5mazPr4C5JDFOnB4Mi8Bs1Mkp5E14GF6CgegqPVi4S65JTyeI3Ax9L4J8yCdEU6sjfL0UY4pCb04OV08vRzoNVy0YeCJyRzGRbBCY50JbHjPF8Jego0ZMHmWcZH3Lt64K1Wg4fTBl4XDI1v/jE2vi+473co3uu8+HuFV/C/vNiWRUfbl+0ulrJFjQslrBVUWVqOzZivvFPMhrI7JQxYNDQTgULC4L0M8HweeoysQOuNgu7XUdXqbFqbmsnzH0/mNb4T/Irar0F3KpqjJTNMFWheIm7ZGq2ySyfItwh1TMxPoytR+Br0muBbdCJ4YG4FZrL/AAF7BPyF0l4YsYNeD2fEJPVcVLwV+ndMeI2nlGbI1l+PGyF/pI5+lLLSpJ2mWaCku7VxOOL3fCbeXDqExv0deONOCqeSHuuKB7IXcK71N1r/AGHd15ChuDU7drLL/I8UYFu0L7e7akfB4eXkfR93vNf9lrPL3/eK71krZLrOrVmOCU9JugUIrXwFKWDJtJ5iTeDyEy06xwXiZ9KUjpXr7zbSyT9ZI5G23vkvYiqhHSsjdfiKbtf0ISUHdqvio/0yaZXCzgSjJP7iIyJsbNOM8M8NRV4b9r3Ev4jJqMjgp9WL2FY4Qhb52+WhHbcpcFXk+H+4T5cJsQnj0G+fB+IrJdRXhkTVRas0IshZIaNvgzJDNcGnopsyRyMLjjUmSXrw+LHgKa5KpWzYsroyPPTwecDV3/Y3q2PEUciO5flhE8EvqO0rlVEbeRzMNL8yTQhNSQ+2mOr7c18PXUW7sL5Reqmt6v8AMmrkyxNa8JZFLTYc8kO1viHxw+G3w41jxEK19YHXsxPiZQu57hiRmNhG/q/QTqXX7HT+53KrSRVQoWSaPLNTBESyDGpnXhlegn4GBCfr7iWmfDAlx8xxzG/IS5HlwvTk0Taygs0+lfjxZhZgUqGOF9hjUzoYGecDfM8+NbToO27pJS6eOnByQiFrx0x6ERiCRExgdl4EtFZpKngsnnwiyL9m7xbBXt1f8VVC/X3C2uK6mPHgtJIepqU7a0H4SRyG4yK98/ojbbUdv3esjUdD08jvd9drd3fXHsKWaiV4/gLpi3i/yFX9sam3RDUuBtHyu3RS2KnP0siHw/kRhcznPsSPiX3f3F2/3QNNDtbt8yGOz+Mm59Q62wqr8B2/cyq5lZ8TCE2OEY4zDjh8RMi6RrmOHIoZaz0WTvfU9zu2jfhaKlZjEcz6buX+N1X5cc4RhibbNvIcewfkaY45WGzaq44JjLK+Giyb9WefBpMSkl6eiphiSrCLW5cHjjNnP5+/i1zRjUStbqM+hNdUJllZ6mOCcDnUe1ZIj3ik3fu/AsrLrYhpLBliaMo2xk1LbdDuPvbZei0ivmV9rHmRrxRBsVlI7W9n9za/hI5GpdWt0nbltJG67r5EpZf4ncotGTTM6rlAku1WSVqLtdx45yKutCbtJePNCp26rYlqS83+wmOOXg1i499lO0lvI/l6nX3cx+I40K/6vxHOqJUla1w7alVA4cifKSeQjBzJqzQU2xGhrgpWV4ewf58h7nkwsm1aDSE2j/sOsxadvIU8Mlex3e8l374Vefr5kcfM8xj2xuMrpI8HoW8JG6rCFaeiI9461G636UxRqP8A08Fg7cJzZFs+lsWqLfLzBL1+xVrPJrxk3vnwatXBCWB8Hac+lCsuCY2N8+EPUbSwYagt0yy+5aGfiMFe46/yIdrMjU0HVuLFpWEK7UoWNfIt2a2btX4v9vs8/YN7JSepupoKaQOWLI6N5Y1aq2vywLcju37Vd90m0tNz8JPpu7fs27f1FlNqvWv+1+z0oIWppwxwSbF3RVTG08SdYvll7N5MfAtfEVv2vT+o3PmfO7dukSYklgorEIeeZpwkydSSIbPIwyP3EpGnDz49n6zuT82kfhoW7u55URyXmvYRxdyzvlyTyNq0JfxHWJIT5kJqS65QKS6FtPMXsEjzJbG+GDdGRwlX0G1oiGjqubEsFd6izn8P68M8FgtLwPp6YLNaSLu1coZl5ZgxxzoStDQVjPbwWPIVbWm8a8Eyipqyt3zMPhHMdpEq3/axuy5GEIgb8ytdueFXKgbouZD0F0llbPgJ7YLJvKE6VwK/bU0a+43Rkbj02ZZLeB+00JJ8yPE+Zdjs4n2foXSfR+psohUshbVttZ+v3ldsSRWZQnHSPzfDGs8PldxTWJQ5XIipnUji02QeZqTYmOGmOE8vRdLqU+CdVky8nxGGSkZwieZC0a4ewVmx1q8cNySleh5n8izJ5+i68Hv0IR1G+zz+g/Emzw+FhV5FV83pgSWiK9uHuf6GBQ5JjIociZBtT6RqcEI2uKmHjjCMcmVfcobVG0yy23Xjs+Uof48arb0+I23ksplSSyG4L9x+yD5ajxJ/b4HwdI9qemhM5N1mo8PH+woR06R9ivYQzC4Tyg23TF3P2CbSNrQ2kOMIecCu8pFe3yQpfUJxjhlc+Cs2brZkS5wSL0Za9Dankzrw1+wxqVd9qtz8PKDfGBqBtVNIInI1BCxtXrBJng5rx8/Qt7DTIp14pc2RwT4aYNzr/H68jBvPiQ6vRnS+kj0cp5MVwIdquJK74gVlXpLVWk8K1SyQtOOVw8+D4RyEkh8PIlF7PxM6SPm1BOWSuaGq6DS1NtU5IvX3j8f0Krs3X9ju0j7BJLLIsiVqRHD5l7qr8zEtyfL+Yk/A64klZNcivODb2uRebZ8iqerZRtErQ8zbJbbqVTXM7VrPqghqFJkTTxw1IknkWtWs2XItTv8AbavdR7vIql8KSS/L9OGgmuEMi2v2HkQPwQyHy42zy4QOVgcePC1a8uDddDttVnBvjKPmesmpRTjh/tHRqWuYsD8X6HwrhTavExVKR7NDbuyNJ54vhDWSOW0r0jjMkHnIzC6vPQzpHFJkCclmzOvFoyaYKpascIeDa/f6/mN1XMvs1v8AERTTxJkarqY8RNk0XI6ULZt1+87mOofpuapfmW7aUXXJjS0M8Id3BlChkwYeB5G+38Ra3Me7mWSWZF7SG8cJbzA1d4j7x7n01f56IrFvhPiZKszdtKtrkJjc9XBeBg+XBPCWhtIw8lk3hv7JsrHxcMcNOngo1MCdliTU04fLgtGR97Xy/AXsN3b0epNGtRqcn8qxy92ugv5OXrgbtbJ/HUbxPPhl8N25xxwZ0PjNyiRT8Qm9PQnc9xlzP5keY2tGI3KuBpLHBNPHDOgtvBmNRkcyFqLw9BpcjbI4u9w1ZravXB5DWZOlajhdP9i3V1fn5kV+EefX2HcbUY+wsq4SK9zm2VaXPi9yPEw3JBrA89REa5Gu3O5iT+IpeHlmEQT4ii3M6dCWTIjJ83uvon1/uUvtq625rB026ROc8FVfERGRJc+HmRt/hj7XyKyjTHGKri8YIbWnoTHVBV6QeTR8UohVyPOjFayeWXVZicF1dzb2lV8vLJfwGdrrP4f1JWhnh0vPFt68PjNqHgjmZ147pyTMvg9pX9z9dDPxRoP2iZ5Fnw6YjhMjXgdLPMyP/SYIejPIV+aL2xLNsLBXyNh5EmMpfh/UjmNTLj1yJczbZ5f2CtRZNtvhqOq0XF13kvUkjzFvIjqJrYe7xHKx/Y3P4VoK0cvxMjSUG3tPr8xL90GFzNRDhKWbe5WrRJkU6ErUW5Z4N+Zp6GvGfT1hkMiOkcvBEZ4ZQ6rTih4464Kw+ZkXy9NXA2OvOZK1na3p7vyITkrMCh/x8LS8je7HGJzwVVpxcvI5tgbrzMHn6GHFj4joZZNZJXcbbf8AmQlw32xVCwVSrliPIgUESQnjh5ESefCBJ1xIoNr0Y40NFA2qYk3aMSnK/Ibb00Eq2fiU7a0S+xhMy+PzKsc6QNqmPuF0tIiyyakLV6Fp15DolmRUSKjtyG6tG7Mk8lwwS+DxBkXCOZnXjEkehj7GXwRDr1Cirj1x7Buek1wNW9xZrRcGIgcOZ/ATrWLSP/UmX7m7pYrq2PA22WWNO6gc/HyPM/4cny3pA6IhjKUu5Z5HwowhsQlA8nbsrw0zXKJXxDT+Izrwl6ENmigzqPLwvvNSZLbv+ODbaGnmPYLajKNrXBkPJ1GdDCGieRnivJkNZN3KBqS1HX2nb7NLfx10R/uHk6cof1F/i0SJtq/tdjUkViHkyYXSN3bHZpiv28Vr7jubLLBbuv4mVcm1PJFS7Tjhpg3cuDTYlZxJbu9zvRVc7R90cyl7fu9Z4TyRVJ4Y2+XoZeft8aFWROCGQn0ijijMwa8NR1S0yKrTjkbXrUwb5lje5ITduWomqWng3TDHPaU+Mlu2tEpKSs4H/JBCe7yNBSls9GvLwGxY4b7uKlLLQh0HVsS5+Y1ModuHmVjXg/H0V7SUSuFdtZkcJx6CtX/kG7qEJURu5kRgbjA8ZJu9vaRVVUVX2tTdXwK/Lvz95b5nxWIkbvbAqrX+hatNPwGrPLLKy0HZcjds6i0GGREDRbHIShnc7Xd7DVVzHs8D6ft9jupWref7+4+n+ntfdZKfMwZ+ErChmfiHK9JeI/QZlz6DlGhCeRJfFHF1SEkh4F4iE5l8YYubZCSH4mrHV0ZZtTR49/8AQs1TKRVzn1+4rPwjj4uGjjd+H9BRaVunH5EJccP0UZ0Oo8hK6mGKsYNxIqt4I0MmammBPgs59GZM8Ijg8+i6PD8VqJbp7aTlsy/cQsGNZPm/UNJYxzFWqii5fb5N9H1GUT2+4/vM26Cu74/6m7ufD2y7bxJLf8lis/FzIH7h+RAma5JTJRE5G1odvtQ90ZZWyY1ZFUJLUn0MGuYFTu1lbvy0J9NowTmRPd0lYPFk8WzGpub4RBBJPOBra5M6m18Pk1+8tmWT3FWPEr261x6GWaY+xj9opQrTj8uEMlkxBVckPaYL7u5M2xPIt21uTXPlPgiWsktxxeMLi41MnlxwN+n8KMSkba16vFwS9ftdXx+V3KKTdarSLtrPIbT6mdT6xuJ7ki7HbX87fVnh868x+gklnh95K9v38M5IZpge7QTE0K91kmuhaDdzK03Tbkh+XoYWeD2uePl6FmmPOTRkPQz6GdB+CFHhw+QtSkst/qEnqJQLt11ctlarWf1JLPkJNZ8eCtVkW7jaFPoWrt+F/fxrGmZ4YXCqWskc+CZ01OhpMXiQ9eEwZ0I4PJWdDWamfRxxTnhH+GwvSb3LcOveTt2m/u9ov+mprOvmxfxto3dy9aULdr6Nz3vHlI+7an8rx5D+bIklyMI0yMcPCRPBVmUiIMkTkg3RkizFAnGiP+1Vfzbds+R58PIjnw7lKPqaO782V6Sa0NyrkVq6nUTxXGyeo44bmsiSSgzMm5Lp5k1bgbe2PEut5vTyJVS3WO3OcDs2fLfa5i6ohjt3K5nmS1nhlkrgrePotNSiefBL9phY4Y1G0TaIEyOEHTI48CWo4efp6f4zz4W7n076V+Ral/plt8G9f7Dv2kqq3lH6jo+3SPGBvv3e1+GBO1RSlKE2ltkV9KnmYeUNJM+YtR1eo0mNcza9TLwY0FYhPAoKwsT6WeGfQyYJYp0Jr3I6vVEPD4KXgakU6mmSGpXB7Y3D8RSiJMameC6Zp+p1aMTSk+OBNVUwbXeUyPmMUsc6NT7x37bdqP7xTrwVd2fXU6XgV08eAktOEjcRr+HHK4W3chQ9ONLKdg1W3o4tBXP2yUCl4/xWUvuPhX3EtGOGSvZ7docyL6bfNp1/MzwcjrZ9JurCtOviPt95OBeHIc5TRFljgk0OdBOq0EyeCMacLJ1iPxNeE8MaEPQbT1MkQPctCGjC0EmsowVyfDwvjpJdMDlkTgWCSLKEKGhti2yqkO3sRplDqn/G2VUdDNk5grZPKHZ06yFpwrCyXckrQTZL0LKznP4GNOKNWSWfnxlMbnA/9LEowZXGYz9gn6F/mUdYcLzXiLM8PMifS1/wGv2UEMyjThC1IZiotqcez8CNzoPfG0xqViqE7amdfS7Pa+p7u299P7+BHiuHkYNPQeBQxNvEjxjjrpwwsGoluFgXB5wWpXVDoyjGlbPlktW3wkTheP8AUt1f1Hvr94kOfhKqNPQT4KsYOis2Gt3VHHbz4KdB9UMTu8mhuqOba8OrUSjj58PBjjXhD19OReBjTjbdSIF3V3Xtj4eQ+E8H6S+z1+zXtMNQYWSFoefGI3JGVmRqPxFZr8DTIoR5+jhZK/W/Ud1uq0qJ24Mnka+g0stIjkYTbIeDA0mW7SurW9cP+hlljoZuvp68iERIqr4meQ3t6mZI8uFmdtte0muz8RY/GR9y1nC08myk30/H0XjAnGTC9BbHD8zc8YHXcbquVwekErgrpuTLwNydC6iqevBtt7lwbsNqplfaSTwyZrgjl/jmh4EmoqQljitjPLhFaokb5DbXpanl9gnODvdztpq3ctL9eRKsyzfxEFVW0ZLbInIu53Omqc//ACJjBRNyba/CLqlkcuHmKrUrxJevF9Mo/wCRR7yU3Hhwdq6i2vO6BTr6Vnayjl6VacmcxVVsW4Kz1a4TJJ4Cmony44NCOY4ePs8GuRPhMShToYN37jI/Qn/C/CS8DMZIaIQ1u0RHCBUS8pF7eCXMq+Zjn6eg19i1E1J4eY34DbNrqZQ3yWCJ4NkcyOS4xV5JtqjuQjBCehZFrPmY09HyEnHyn6T8i0UyvxN1ljkf7BGHwfiiWOLRSvrqZtNBdxWbT4obIRqpngo19KEJsnlw3M05FeREGo50LNOJ9GTy9COf2yFJjhqQviMLKIbhHkSmSnk8zR/cbU+lcdTJp6UfYPwJYk1whsc3H4GpLOquRpan+4y8ETkwzLwvxPIlPAu2vif6Eb/4408xrVsncRtkl6I3L4vtNlXk2xiCeOo+rAotkn93iWzmCHqNM7as3va9ZGua4wiDXH2DcTJFmR+6TwM9zBN3IoWRN6kvg3BPia8W2uliRPMg8zDh8PP7ZSeRgUkijQzzM6cJM3bU8GTxRMjjT09fQwTGRKRyuXBIla+jkiug4WSbMcr0Nf5JNy1kw9RSsDaZ1CS09Pz9DzExeT9KYJqaDtS0MT7l5eo29R4NDyFFSvIhrP2GfAa8zNp4ONRNvqKzbEihHwk1sI2x6G2XwlVJ4SZPMlmgsYJ9KI4vGRezjpnhkxwb8RR48K8XI3wnhj7GOZqeYkxJHmdc6GBp6kkRkyVs9OGTdGRxz4Z8MGg59BCZh8Maelr1cNMvQsnmwk3kRUj0U0Va0JNcEN9TLKcE80Wj4is/FBZ9us3KzqacI4qdODlZ5MbXiQ/iPhwbvM3TgUI1RnUVU9WJ+A/Qk7/a7/Y//jKqdLrnZ6p+w95rg1JOo6rCypJraDNkkKyazxxr6M8Nz1NELhJlQNpQVaI9LXB/t441NPQwacNBseSYyMg2vUdl65FZZN3mRVZIgY3PBMXDWLGp0nmS+Oph4JH058eEcuOF6FrLU1yZyxciOZCtPB+g2ja9SSpLXMcIyoglGpNXD4NJZEnr6MjSHakEWRm0cI5ELI7bunwGq1Fa7lkyLx9JM1PIaT6jNlJCbMuGfFn2nUkblaRVvqSvQ1NFwhaenV8yXyPImOo0kSXFHUPlt4QakzwyzJiSU8mp1W0HP3ENkzkSeY9feNrhur4Cc4LRbmIb5meCc8jzMHUsDX7fyPIiccNR1jBhEu2BKS1ORKfpy9fIrOOEoaJbz6WCeRU8i23Vk1rLE3TPsHfwEkuRDsKFg0EkhTr6V7VSTeo0zQ3VeBLZKIdGba9sbujCyLw9LOnDUcpyWW544ZY9zUfiY7nV5io7E2SG0ukVuZsvYlcckRkiOEs0Y8RHo+fBShpLQ+ODJPInhJBnXhhIgzqdJljs9TbRdR/IuosksG3cQ0aC3aCSZnDFZkbZRtIZ+2ClsKnP9H7DzISyNRgsqqXB58ckxk8ieYs6cImGJxyMopnT0FOhEwNNdSMRJLMafYNxgXDyIqQtCsvP5lmrCT1MLgvHhD0+x0HNVBFaIw/QSFxg8yVy4OHgluCtavrf4ERLbHtWYPk9z/kjHmVV+RMkrRITWpXtt8/eSjL/AAFjJiiOpSLkW8jLQvD2iUnxZFDGuYieZNtCZM6GTQa4Z0Q3+3ihcJGyKKY934jtt/k5k2eTGkfibtUYRL+Eq0iUdTyQ0Q3k1HZvpFu0GlPC23VfmWVWrOqLVsjQttrwhL7yXr68xdJCWSGsDhcMcE3r6TZrLMfYoQkPNZ9ha3ev0JDp2sMaRgcOUaCyS+GNPsMr0c+h5GUOBtjsNJYHjBYc8kX704mB7a5Issi7q/5Kr8FqJrn64IFbxO2qrB27SaHwfiSzkdTGq6kt5Z8R8TPjWFzMWFLxArLUUPlwj0dcGhq/Qc+g6Jm1xKXIzqZZh5k28IY3DMaCT5kP4hFoJ9B23dPh+p3HRfE8j2oTjPDdBF6yjpUIa5iRh54LwE1z4LKJT6ZEvLhCIjBhfZsYotifVjbXUWorZF3e61K0G+GvDBX2ehPCHYdd2ePed+671u8J/tF7RSuGfQbWhpgwyBm1afqQhy8IW59J3bLLOw5zOfzE5hGuDu+af3HZj/SPxGjDydl+fDOgi1swjbVmWJyKWoJb5nmNrU3SJWfSVsvQnjnQyLmYMvMEmvFtlu5ZGpacMjB58NeGURwT5Mb3YGt2BKPQnnwzqNt54KUTXXg4Pi4IvBB8tfENWXr4iddHqLAkJV158PeeZHG0/DwTK8EYERyJZPMiteES+EuR9UG/5n8UaC9CZy3BYmtoKt/EuEvhDfCOGpE8GaCHiBwJVWC25SiOR3K1WS1IlyVfjoQnMHbpTDsoh/j6/cJVWKoqp0FeFLZHM7UawLyIbyNyOlWzqeSJFVcyHbqT/ArlQVy5Nrsn5CiIFbsPpsLsXjGnn/kVt6OOOvBQQuKg0L4G4wisaHkzpY4146HkaiZE9Jak6HxcZa6RQhy+ol6mhC4qdRzEDlECU8P9w3ZSjcn7zOjfCydhR8BZ6ozXJuu+kVqoys+lodOpVx1ipSunqyHgxoYHLyzJaHjh23S8LmvE6ST2mWOOXCr5Fl2bxf2FFq0i255bfoL0JZ5GV6DUam9jrBarQ0lnzGnobn/x29Vko1eGKlFPc8uZes/y2zP6e4ghohsVpJnHG0ODud27lSNswsGomyUZ0g3dy0spdPDZqdr6rt6019hS/wDqXo6+lKM8Pi4XbISyY0JXwmnDzJYnJBnUTwORXfIVqr2C8R2fvLVWjRrqjOpqYeOHlwh5a4JJFcPajq1NTUi6aYrLqXgKqWBbfhN714XRVw5FJCWCSORNdSbPhjUm2gmhW5HxtQS9D4kJVfUVbpnmdKwQnkwYJXITa1NOELgktZGl8M/iS3FRVrovSg1ya8NfRwQWhZJfM28jb3Km3udyzWcevIVO1SPPmZISyayxSKscxuq6UImBvmd/PMc6bv1LOoq8z4R9yMsSdNSnbVOR2qcjYrYSPqO1btzurj8x0mdtmjPoafY6c+DJephdPrI2tCeXDz4Y1IWWTZz+RpgS5la2fMjkjTkJLQU2E25M6mFkS5Ez0rT+/Bkxk0wS1kWxIWeGDqr7z+Pty3+H+ZuWbW9fwLpvJG7IknklfGLAk6kNvaOteZCQkqRJirNRPaYQoUtiLy4ZnwE7CcmKnhXxGt8mdBurJ3Sh5K7uf4FrVeeXuHurHCUdldvtbqP4vI6Vjjjg7t4R3e32e45p5D+ylI3xoWTeRrmeRDWTzGnTUnbkTJfImCEjXhadD6h6ORzqeZubbqyVWWiIHKwK6WBWaEnDZ3e7ddFaHf7qcVt3LNfe/sml6GmnDdyIWSzXwpfifM79NndlqPBEVyanMgs1qdvYuhascLoMPAtvxlZeIJ38MllJIsyPhPoOnaUw9eRtai5pBa6UwbohEpoyhw9eCnQ8yeYu0n/KNtaHmQ+ZgitZsbbJyJfuehmuGJHw9InEtCe7qOt6jS0IjJN/hQ4/5P0Op5EiHhobSyIwbq6/odnGZMmHkXiOX6GnBpqZO73OxSL31fGfsI5EDUlmnmxoYJ5cPhPAVnTBC0JZzFBZJcjv9trmXb0TgbmV+SEoyOv7h4hHysnyhKwu53Jfr+R3Yr/Neu3/AP2Z2qc4+173zLKyb6fJDE+Y51N1T2jvyQpSghrHBvnwS5M/2lu49DcrG2eDIadrfoRyHtlM3MyRIqpYM6cMPpjQvR6SUfIcjx0jRu5+g2eXB9xJ72SOfiMRu5+wbqsQQhp6nmPt0e0s7pqqGuRFSXoKieCtq6Ddn5GXgy+fDbt6hNai6pRl5HFsryINyLK2ieOOueCXixpaehj7PHCeY0hzXpNMiF0zYlrIsZJj0EkN+RRtYb/U7qjH9SK5Y6fL09ZErNbTTA8cmWZhaHyZm9/XHgfT/QUtK7VU7e5Yn3/bvJI0ajs3kTyiJx5lfaPYLt3p/J5ngO25QzAqpvaOTAvElacG2boEmiyTlCpW2BIa4xbtq3tOmsLhPihQ8ix6O3nwjmShRqZ+I+Hq4RyEO91kVKqENGx+0YvYKZaRnVmG5FGplGBOt1s8CXqKS215IP8AaWttwaZG3qST6GP8BkfiS9RNIyhYPP0NeGHgXdphJF+13H18pFZ2W1HctZuPwLMVNsMl15ZImZHtiPFHf/8AQ+ptLqrOqfi/XB3vre+3b6jvWbl+v4f4DBrgyLxIOl5I8DMInmPBygiZPIXmRwlW4Ju3RGnnrJsqnr64ErZyKuphEvX0E4xwl6DScClnmJW14wtTKwQkfMjOhHJcZScjbISmxCSEr1+4b0RtnrNRJ6Eo8+OdRSWzgbR4iXMaevB+BlibeRP9w44ucv7Lz+xwZZK0+wlPIpHOgvqOynuT08hfTXW3uDpJZfuN2uRRfEi2YfOUX+p+u7tVVaVWv4naaWz/AMynt67L9DGn2ueEHkM0zxh6C+lVv59u5+Cr4tkuS3ddm6NYryXmKCNDFeE8+GHg2wjBav7v6ipGFkTrDrA1tU/iVq3lCrXQxbQju/FygT2x5lXMtkDaEZWGe1kDtGgrV8is8U3qShS88E2so+Wn1EpyzPB1u5LX8yIwJwRA/AwbYRjUbVMyblzHtRoaY4JjfIecIW3QZgfj/hoQmKFxnkQhvdwwiGTUVXqPu9i3WsprmJfVV3UWMa+8S3LcuTxyKb/qKK/MVK96jv5KX+Bt+h+nbSb6rY/AXd/9TvuzXLkvd+pXtdusVX2uBtcccV4yefBozoOScpHU1HBV9CYG0meRAnbwO4qYsKsS+YpXSU8hrbqXw/IXVLZ58FbkN2WOLl9HgZeOHv4wNtdXG2BtLAm9RyVnxK+wicmdCSVoQuCTHV/CU7e/qsNN6aEjzwfiQh2toY44foTP2uPsY5jbMNIxXqFFsmhCUtCj4WPAtyyRtn11N/aq1bxRtv8AUXafjZibruX4iimftGhVXxDbO21aIcm6xkjmYWSfQggy+GURGB7V1CbrFvQkbJahEtaHUsD2oSXwnT8I3OpseglVwmKLkRk8yz52LLkjCN1nECb5qSiT5Dkzw8hiknlwbjD4beD7j0K2q1q9S1hNiRJIh+I9yK2ayiXqKBqCJYsEpEGWP/FyPax7nkhEsW20L8RrmOGbuY3I5eTv/U07PzL9taf0O39bb6f5dtzT93rnxNOM/Z27nMfe36jbcySo2sjeJW+8w5Z1WwQnJCH4F1b4Rxpwj0Z5jmufS2vh5EcJ0GWatkurL2FU/ifMl6FmspIVVbPgOMENShKOkXc5LkbeRtWklUuQ01L4YQ1bXg6twjpyvI0/sWs6yitdnSadfgb3yJ5nSiXqe8zb2kx7yEsnVrwVbPp5DZlcJtaKCT1REGT4eGDBHP8Aw1mhWnqkULqHjMClzBl5EWk1yJQX8cERJ8uqingZfHVyS39lbzZRLkys3zkSE+ZVVSIbyOMmXgVXqZeBPkxQsel5cP8AsbnuSiORhHmVsrRXw4+YumUYwh3oR26vxb5ewcIlrIxVvWVyPeOMr8zf/wDcOttCkY4J8ittzwzz4bpyK1XoWc5FbhHIbehbbXEDpfEla9q8Ko8kWUQyPIUaCjUTfxCbyhrdPr+n5kftNccJE1zWTBg7dW+Zmsxwhai8OMLhKLPjfvV7Nu5Zftrqyu20+unpTGPs2jv9trngtDNzg0HGIGxW8eNmzc+GWPjX2+ivRTbxk7UPArN6MitpOrFiOZZ1f3mGf7jGg1uwec5O3GkehHovZ8fI7/YrZPu9qd88nPLx4a8M6EnsKunedc5Gq48j43tHKz4k8hoTtoizdd1oKu1Ib8RWa3U8vw+4ads+aL0VosdusxVEm7t49pW9+50wS1FRrxF/oIFGp8MDl4O0tz2+up8WRJVljjQxqKHoKt10oaSw+EJ4HB5kNZNDTA8FLRqJp5TNsGpHoIvZXfV56ezh3r1vazsvchI8vsIudqF0WrgaWn2fzEsMd4iw5aI5stV+JadB1jzI5CSQ0tRcKjXMabNo/BcPL0JXoWZV2eExQyGyOXiOyZvTx4EalZfBQdjsr/MVeS+yvenbStbV+PByuLis2eRPm0bucj/1MaWgsjy4JWgmmV3fCOt3NTa9EYLu0/3K2nLR5ksXiQn947W+8eCFzMmuRysmUQlmxWXoNV+IW5RcVmukXgyeHmiYHjgnZo3TgSnc1r/Q7jzsWP8AITbTLQ8m48zzGmteMQoPC3FLlwn0vmt9S+H9Tdan8FEOyX2dnHVUqrP+RMVU/h9feQ3KN3I2tHSuY51Eiq5CI46jbHZrUvvSaenkR9heq8GfVdh/EmNpaCs9WheAqvQTSiRLwHS7x4ii2R5yX77WK4Q8+hfYl8yMSR9cl/2p5aa/ZTavoQyJ6mbuD3TIqr4RRox0H4CUYIXwok0hmskquBJrpK7Ut3mRK3DdEtwp+MysmNOEFKVfUvxFRJbR+ZbtWfn7SDzPIglmg3LhMmMHc7dcdtvqt+i/qUolp+PtPKR+Jpwl6kT1cMlhGZ4qPTiyTRWixRaL7R1ejPm17f8AC9Wbk06rQ7kxEmuBNWyid+fIbeEbnroZ14K3CYIFVe0S9CPSt2raMv8AUUU9t6nzeyozp5+wrApZvkknkPqHWeQu3VZsdun73r9jn7ONuC1t+SHoNQdVkkJRrnXQrPuLXq9NTbXPBNaSPwgyhYhCSfMTfIeDTqLb9ORPIwhRxS5nkSirnqQrW1F5mdBYyOyRDepFrY+4ar/cs3pJjRELQknhKPNv0EZMHnxtOvL/AAezu1mo7/R22t8i3z+1KRFk6+71+41UC8BNJtISq8CSfDyJRqPasjzkyRRzYjaZoS04Gt0IxY8vQdO7TXmW+o+lXT5euEbdrrYiBVjA1KE2zp0hEvNvAt9T9RXpWBfaeXpwjyHiGa5Js5H/ANjsp9laPx93l4kVhuq8c/8A4v0G/wBo5n5ZNfhO50TXUrZzLWn7iLev9zKjg3BoKzpDG0iHXA0hELgk0YWBLmTEE8jTpN110/mbq6eBzEtsoT+io99nn+x2rfWKe+370vPz/QdraIVp4xwlrBzJ5f4+LJNC39pbiEnk1FXmWiuBNeHHL4YMsbT6fEwo8yZIdhN/COW5RPb7jceRDfV6MWUoV+1i8jrajvXxEt8G125eAq9qjZ1Lan4m673WgSqoXpY0+z09GUzOo5G/A7nd7dIvbX15G6uVYlWiyJg0IS94laRrmb2zbW8STOpCyjCFHLhMmU4XrPsHgzwq/AdkijsstihQPcuZpjhPM0JGrKUaY4wMS8BNGv8A/gU2eRu8EYE+OnBGW9niOsYGhy+Cu+RtkqsyK3bX+Qs49LbZYHb5bTYnsli+X2kn/im9rf6GopMstar62UV1C8SBbbdLehD0JWUVdarUbtrJk2vSBNIo5htEC+KTOhaHiRNMq3rBaHlCjmQtRqRIfgQ9fsMPI6duHda+XtEl9jKeOOP8R//aAAgBAQEGPwDGxocYAuaiAGyoTqE+29Yxmx/VZJCIbva4jcXKdACaJ1aE/TfhCkXt9RSvTooyV9LYkAkdS2BbYGsqYlphyyTiuAW5uRzaVBtTYP8ADt43Xha2lyaCKA7clgBtQngSCi0uSwZWOCinabWVF/DzFHIwMXC75KmxbsUEkhASb1kNmx7tc4FAjChuostriu8Cv/LGoUgJxUIa9vMtoA4b2bQ8OWxO02aCft1rEPtM+Hh+85GGnptrdpFt1rgFy3tWPk4I/wArcgXGcf8A2v3NpRSSNxb1XF6gjyW53tTso32Lne22KKS3e5gvanMJzcldvmbU6dwVARYADkpFemx+LUJIcrQEO/eUJ+FNnyMg5YTrvtCFQOQrI9w/dHvmGuOR+ljG8IGFSGtIIFuNe8fs39jZTmsMXuOG3KxYGhA5xG4kng0WJvXuXukwzcrI9wAyfV5VnHNsHKhs0XpXArqdFJ4j7a/LNvFONuNAKg3OC2PDlU0dgdy2VXIRYGxAoBSAE6TrpzCrenagnS1iEtw1SmgnW3HihQp8aUB2/iqlVUk2tdtFb6af6rVvkTyFuFc41/qte/Chk7muY55YMeP85oHFrQi34GiwQ9cbzG/ebqNAQSqE1tsHHnYD/wAqR1931hOHw0W1PnjWTGdZ407R+BGmmlZmT+7/ANz/AP217XgCLc4Y0mRL7lNkBGYcQiFmjVbaVlx+0PypsQZDuxkTKuUA4lsoxtWOQC3Cm5ONH2gJky4Af/lA5C33V6qSKB0jSSBO+2RdCEW31Vl4kpIb2fUZEgChhydNCQjV0qeKLILu5+fBqoKBpLkvrUft0UTCYgCYRCOPEu/EE0CrUOVnY/eymHoYOoBqKpACKCLrUWyIQwS7exAS1RuKlU42omSMAqNsg+ZQi/20EQrfq+rjq43Ab8FoGe7kK2N0VFB5m1FkmAyQSoqJYD+Yi6bfvNNkxcT0OKqRRFQdoCFpIJNyCfnQ7MKY4LgWqVK8TyN67cQ7TLXDRftW2rxQXHGidnclaD2hMAuv2FL606SWSWIpbsDmqX+oX0NF8id2L81pQKLo7mpJ+NRL+TIB2jrkYpFypB27V+0V3HRF0E5ba7cfJREKhHNIeLVLFLi9rJjPlOBtlA7eVrNqSGKMtdC7sdxpd6bKgA0S4UcbXrviUZNu92YMdcfHTgqAqdKSQduSJC6YLPERkaYZt1O28eFOjidOH6RCRBcILiwAX7qxpWNMo27ZlcQuXjzG+I1B0rrotdx0fkk3E5SA5JKnp10++pGwsdE2UFQMftHcLfiXjpXp5idwCxsKHJAgK7geB+HCjke+e3y+9+2+nyO7hwT+gysiexw/1JIHSlx9tSe4Senx3xxJPhen9OMgbrKAv0sS/FF41LirLk45Z34ZVAaOm/pEQENS68qPqGdyHH9PDJFhnaFLunLJtuLTYgXpczG9NjSY6xRALaBNuWSLEH710oTzEntLAoCKMhCD0/haKdFKGviEw7WUBtFypK2+HxqVsK9wtM6FUuE1v+H7TUscUc0mQhxYlxS1SCG/TbcSSniawM33afOwsyEdiLEbkNxfcvakAOM44rUOBuB1pxlO2OUPOpycsyBS4kEqpOvMmiMvGg9pwG+3wYTx7ZBBA3MyMdw9Jl5eIFX3EoFPGo5e4npYLkl3p3Kil2IPqJJ+VN9zgwJ340cHpBP6dMUdgKrgASCdV1rtZEUMUjQ4P1BInUK0Wuo01qBsUo885AnMChxABQXIUBL0S02x4RjrMSMixQNSwF+NNjwc/JwsZwME8cE0+KFCAEAEAEJpRkyHicglHTEAnaF3I7nz50BYoq7rIQfUHUpXcjycQSPv1b14BHAoBt4mhJEZZwT+XZf7RHgFXxrKGTF05PlQTgD8JuxyqiHjXcMBHYHeI/lBG3npXat5f5M5sUFyEKX+NenkWfvjqMx+nbdQRofGgI1JmU44Q2LfDQI4fOt/uu4mYAAiwKBGoiAC10qHtQHHhl6ZrXJsAhKput/Gvf3/ALvl90n92wRjN/avs3tfZyPasj3j1A9Y791ZY/8A+WMNE7JPUUSp3YyYOD6pphxDpuTgCri0XReCUSxC82DRYhTYpz+2u+CN2rgdOLQQuqV5cAU6LbUg3dV/pupOvMJqvw0rHiA3HIv3wNEOgXiUSh7rmwgiBpQB1gECLzJ8K7qXI/Twn+XTgqUAGqS5brY6HcvAGvpKlxJRV2rwJ8BTnhCHE2upTnexBN6u1blo2ou4N8LUSE0XQXQLwo99wXLIsAWkbUQAjQryr1ARQBvUFNq7eNuVO9OfpQEhdxFrLpx4WqdccNz27rXAKtOpAvesnHdjdOwlQSekEtsbKbaUVL0KI4AWX+CUTxVQWCyH6vneuzrbiNA66Kl9wpT9JHEcwicwqceFWVVPBEAuSAOFAj4g/el0NXJBFvgE/hakHP8A11q48df9p1oEC/IqD4aE0ABfml/HnotC5AOpXRwQoE4LV/5UVqog4r4r91Ae3e3xn3FHXc0gAOJsoBO4fdTUwGZD7i+8IAFUBE3DwKUIcjHyvUPBLUwUCj6Vc7RE15Ucidyt3AgIQnBAgCIdUrIONjMORjcSFBHB/IHbxr0/Su4nkDtdcHj8KcAXLuKIFFgAAvFtQdR15/i46Lq0Xrc1PTOB9WCAQmjUUWFO9wx8dpgcXIlh1NNwWgEi+lEH68XcCCoCKQoBQAEjlXdxrkKShQ6dW02U/OsbL9uyc4eks7qIchKlL3Nkr2z2n92Ne4CJrQ7L7bnAqGk6AhAvHjWP7gP3VL7fBoMU57HA23WG4gC9d6f36f3SdwNg2ICwRFD9QT4WrKxv286FoxS1BuYpBK2DTdTrWRB+2ppsK6Y78F0QUIQth9K17l/mnvfub8fJLxb3BxDhISq3sL1kzTZBmGQRuRTYLc8zerngTZbm50H4iaQgNsDyBRLc1WtAq8ztRUUk8hxoi6HRBz42RAtbQiEW/wB3jrYFTRnhh1sT/Z0dY9IPwvSKoP4rbQAV0v1NVKO4Kblq2BsSoJTh9lS5vtns3uWTgwq2b3IY+U3BBAQplFobbTiFrtZP1wHzbaqLooHPjQ7cZaoUu4FfptzravzFjqtOOJM9jndO5p641UFOHUKDJnlu0nqPEE6nlcr8TRx2wh2S96d+b6RGi3VdpBHxru48hLwnca4L9Nr+AqfNfmwwPw4u5I0BPVtG1yBEAVOVSNY8SY2Uzvxq0/pHIhKcClY+S2RZTlGD/LPTk5KjHJGb6o8P6KyGTREw9PqDjvQqh22uSQaHq4MacQWhdOpsdNzl1Q2rIySTjwn07clS7IG2yAj+0NKgj9uw27U9Mp09JqHImvFTen5uVDiO90mGFNESocLWBBUAXrIHqDBHkFru+FOpFkFwECcLUYI7w/hv+qsAXIOIJ5Xo6tafy0OrQnLWmjvdn05tCiOOQqgq1FJHOh3yJI9Ln9VYXVbXWgcdT2gO7vJVCbAFEBNTREjusI2JrZbK0Il6jjltN1IAA76hfgAiipMV2nf6XIQpWzXKAeQ5VGHAtQdqWwsNpuRzodyOCaM+U1kYXK4kbkCa8tKsgklvNHN55NkH0qiDhUG++2Yna4/S6yG5BLfuqPJDmyRd7uyMedwHbQdIPSoIslqmx/PlmM5nAsoaQhaHDQAnRaYkYj7cxPagII9KRfwF/GppoZFVRHFf8PDRLg/M1j4WHHPk5GWMcnE0JGji1t1DefDjWM3Mkx8bKlx/00IUO+eVYlfhevIYAyID1AKdLkAIAUgElalj7ZjaD0nINibFQhRftqSKZPq790cpsm5eFfSJDKeBAOLjLY7xfcv20/3aRjIvbosjIx4vcMggY2T7hHjE9osX/wD2AGn4fGomTHu4xgRi/wCLGMUJB+dBnd9N2WlIyDdwFmhQt14Kte1ZH74wvX/trDblTuE2P6nHxPdJR0jIxVu1DqSRdayJf2z7PD7Z7TI4+jjcG+m7YAX0YA6QeTqka492JwSawAadPBGnnXpGRiZsSOillQMW5RtgN1vnUj1MqeRNFE0jV1mj4cuNQ5Msc+LDaTEIBGWCEc1Wp0Ibhb1P7h7ln52dmZqOmnz3epycgAAA52VoA0afCpbtlbcSzbf+mREbwDm1EyBzfKdpk3S6tsFU1HLAB35fIyGohxmkAlwIBDlPhapvYP8ALzLk5nt4gE8zWJluRAQCDtPjWTnPxFkbL3u6oX+0OARLC1Yhy/M9qM2P3Bjj0+Vh45C5ZDrBxXTmakmwoQMQnKgbk65WVh46eldl4zdPcgQFTUXoboOz2AJvU2/WFzQltC5KjdKgJKqvH6vREA7ioGulS+SMaFRP2wUOqJY201pxlXIY6Zp84f8ASWKoE0KVPKmINrwZ9RoLDCVNypesjtxFwkdjHtKFAW1jbTlxqWQbjuA7+v6jQfJE0prNzW9wHzZiQQdVAHAG1uNYjo19U021LS0WcCUS4P2Vkd0ASuAbj+mAEGJ6cIpP1BXa1hxzzNcYF5EFQuuiHWnSunMcUIdCEA1FgSgC/fRxG52Li9nEyJ5s7LDsfHBgWwCq63zJrAy5GeuxRl/r4tD7g1tyADdoPA8KM+LAMCM5MxhiBGRljGNoMT1QXX4IK3p5R+lutnCxKFAaihmAAAA3h34Qo5LZONG5QC6D4+FYfkCc7gIV6RsJQ6XJU6Vg+3Rt+oB2QdSlkU/VbxoRRHYupTgECBeH2Ulzbc8lLryKEFPjXeCnslH6BthYkWW1H2r9pey+6e7ZCEtb7ZiuQgC5LkITh416X3n9te6+xOgJB9ViOwwUbrvc0NcPnevTZ0PYm0agBuT+MoDrrTATbGaQ0gfHgLEk1Bj7iZgXOUGy3N77jY/KgEFzrql1tyFqHuE5HYySAQpITmmm4rahne3YjQ13t7nGwafqUlbBFNZbHX/Ch+AB+o20oscPHmNFF+BIoKCOShEOiglUWvpVQSOIK3J06kStdboijU2HhertC/7rdeP4auhPEL9y8F+FFC4KE0WgSCUI1VOaX4p8aM7dAgIsv08GnVBelRLlyH8Xx8FAra1iqCFDed/maF7IG243/FbQGjkOdtDiS5ha4LYAAghLgV2fcMRIRz2atWxVpIBBN1rIm9mwHbQHEdIdckua1WjcCvOhjTY98VrdyM2hHE9JVoUJU/tzMc+mnTawAEkvB3Kmt9K9zyHYy4wkkIG1Doq+AQ025EGwelRwa4lxVDe4BHFLGj9oVLoOHDTlW+TdYbrOF1FydtreNZOHN+pnCOxLE7tUBadUBrInyDxdYtARHkpzBJrtxRCwJv8AhABJsB+AD517d/8AzCZ/tuH7J/2b9699/wDtv2T90ZWcDn/uT37uPjd/l2ASEAexzTyS9ZcGJkhxx8vbjzlxbtuQTZRcAr40ez7xmOAP1Bzx4WR6WFGHJ90yyU4vlQEpcdWqnnW6bNzF6teoucqnc1xI6jx0AoGcDaFDSxwCgEBTqLJ8KTco+K/1Cvxg80Gv+00FfKlkUJy04kLQJBX4X+41ovxcPvFeDh1JqEJuTyqZRe3A/wBVbpmAhxuCdHEIgAFdoDsAkAWQXOnAg2WnYpPW8bdwKoV5ruN9fCvb/wD+Wtv/AGOxMb92+3+z+1e2f/e3tsuBi4eC326drR7kQ3FHuMjnAXVx1qXMcWudKiKOohoQO4EqlIiBFRDfxINwAKUu5aJ/BFFAFSdNbnlotEyNJjVDbnzABJqJy3FktoCdbKeGtbkJdCES4bfw42rILmeX2SBMQnplQiwCn7LUzKi/Wvla7t48TdXIAzKdoLOFe3Re1e4e6fuP3n3L2rD9y93nnwh7c72T9wtbuyvZsHGG45+NfVRaoM6V/almg73aaChRQQmtn8NayGNna2YtgVQsDgm42cDtDWjXwqIYua7N75xxCIA1EDkdlIPqRE51jZcrHHJna3LdC5oaCci6EuCqDWRly4/A+mAIPAqSDpbhUbZet2QSLqN3HabXSs/u+3GfImJGDm2X2WfHKEEJcvao+dboCuGRaJwG7cPxE/Vr9tJGgP507kBI1u06KPjTRIRKChkDrXOh03BBfWsjHxf8K9BKSpJJRU53FuVLF+agKOREIv46VC4hwIXvFoUqASNqcRUnZi77zAZpbG2MCoHSE7i/NaDnr/fY6LdD9ImS5txo+mihjzNMaUj/AA+6xsR+Ic62xxedGVktZxBJcAeK3IRam8gxxyoliU2lbDgW124x5QBlsdOG421N7UcqA9kx/nEg8VVVF1PJa2PcjpAciLcdpcoudy2BXTjSwSw7jBjgo0KrrAJwqeX2+DAh93jyMbKxPeXGf/MvajB/isL2tek4ucP8SvA073P3TNGT7jMBdhJFkG0RaBGV6nKZ2onnrsR5APwBFPy5/wBf7xl50+NDiQN/S4uAAB3pgepV/hRWMbCjUgVO0ttw4px8KkMB6Aiw6gkpxVWqL6aihjRSmWDvh8kKuABJu7buLA5NSApqXyOwqkXUnsaIblu7lpUEvaJBBck4T0q8f+Ku4YVE4WeIlBqUUHTnpQEm2LGdEiBAGyhCC1dKEgjZ6VoPdDj15EAumov8qmeY5kd5wiAI9M1qDpuVI586hzcXIAzMcjOtjrk93HtC7aQhSx51mZvuWTkZ8+WmRk5EwP6nJydOgfSWnRESoi1g2NhyTJ3la6yfhJvy0rKJjgbBktEwUjHdihLYY57tbcahmjgAJCTwcl5m5uKyJY8rshx7MUQvk3RVA1I8aWMCSENHlu/UEIFNzoqKmtZMs8WRF3MbvQwk2ysBjUOZiFSjrIlYE2Ji+m9tlJEc+RqSFCqU3WOp1NTZMJ9Xf0xlw5VU6qA0LzWsX17u97fDKZcX/wCnSAFt0CEg8NSaLoMbvyEkwyhCEB3WF1dfWm+r4gLChISyerIFvCtAIyBBMmQo0UBjbo1eHKoGyQ9iFs2QlibAWXgLeNdyEdx0RXHhmO3chttv1AJXdGQPPPVAmm1uqH6ENeoihs0eoimnJNrjS34viKgkB7PfFnIuK3vnqQm/CpNJA0ZlktkkhCAnA8KwfaMbN9r9mZ7pkOw25vvU/Y9uwRtLky5yWlXFqAcyKfj4uR6yY52Tj+4dgpik4pLFwmlSA7VeIr0boRkRjJCzngn4didS8qfOyDKxpCTAuQjWo0cAdFbpwrpkEKY4Q878QSjV+2tpJvbeAiWVpTlREhSWcu6gHWGoBJUDSmQBoIc4geJNl0WyrQn1GO5GjQA7QXbiQoQXpzQuPjohJuVFwnBHU0roUaeFkXwRDRDTcKSrWkaA80NqMBuo2gAoqgA8QCbWoZrMHDxJsgSYJcgGbu3t6nlC+6c/nWT+3P3b7Bi+94HuULMMOzWRP9xYrS3fhEscQxu5dbAV++/2nhu9Tj/tv3f3HGw80sb/AO6e3914YCBZrmAAfKhjuUOa36SmjgOHxFFNBwujiEQhdCG0YAvbALrpzBKJclRWW06O/wAvzGm42koOkC+o0rHyb7/QOB42sQdQVANZI5kbhtuoQoBqCtfl3CHdpdAD4/GuW3UXP+0GlIXXRF5lbXWu7C1yOUgkdIXpKJ/E1qPv+fGgouUUAK2yKhQk1+IIvL+rjX4uaKOWvxSjflcf7wXTVKcl7N2Lqmh4KFFakDwKFrvDktPF0uT9gCkIpWj6p7ha4aAFH0qfChjY/wCHcWkNQEOCaBquKHSkaT2QdpcLtO4IQQV6kNT+84+K4nY05GiO2kuBBPSor26DHxgEzlytdACQiIvxqOAKJ2PcSiAIWhd2hW2hoFrCCqFSi9X4uXTRi6m+lbYlAOIBCamnY9yRyW4VepF4GsLN37ZiALG7R/KhAIVKbnTY1soPuUAAs52ulenx8dA0ghRoQoActiy1e2ftM+/+9u/aPteb7h7p7X+2Xe4l3sftWfl7vXe6e3e3k23EnhZbUgxSSoIBbZLkutxutH1GOSb7drSmnAXWgd9yb6lEKoifVRKrvB+oJbgPkBQcMcDXpIAaq68uFFzkFgqABouv2AUl9dNpNiEFtEX7qAAVfw6BFW6+HDhWh15n+tKRTY8CP6lU/KrsKEE/huLnVNUqzSbnhdAutuFdKW+rhqb8da2lAUVDcH46C4otAU/hKhEtuutwlDuTAQ27WQAhQIrTbqF05UOy5Rut3/AdR1GoFqROJICXRSdURLJQf2ulCNqIQdUPNF1rtiIgBU1UAC6k2ABFMMNnDwJ5g+BBThUb07ZDUe0BVNgMu6ofuqS3mggTyusGr/upcj76klA/L8mIZCEEBPpC6laiewl80RIBiFvqIc1wS21bg2odoE9vIcXZBI6MpEIwl1JISjJI0TOa/vY4C23Da5AV3Fbpzp7HwAQ3gaqDLupLncxf7KxJZ8fGMELX7eIJ1b9OpBN/Golc4mH9ESgA9UiAWAG0CjhncB1edzOKE6EABv4XoGV3ZMdjM5oFtUaDxdu+yhtgN5VIG78I1NgqmiIou3LKp7WhJRPEqFqDCllMUL+oLqQo0LtaZjY8SDIahGQm57RoiXGlqjdIsXdPl2+ktsljyHGkMJfEIR2jNrtB+KIT86SJ7j127K2JAVQRYlayfaseOBMvIMxypgDlKm3Xjppxo5BhvkKe4n6bGQG4OpB/rqN7JUY+Y+pRFOKASoUDUC1RxJ24Y519skABc4MVSUu5BUzn/UZ/LeICOoC5uTbUcqjSXyFPqEKNWNenXjT/AMz0n8iWGT+Egaoh+ddtxEoW4EIXboECAhoK6Xr08bseKaAoHkXyoygG0620A41GXOg7uuRH0p5zB27g6u1QfOo3emgD2TnZKQrjZHIdL1jwhg2McTKSNSUCW4AmoiYO0Yk3SNsXElA1BYgig2OIle+srgAcbiBtsbKtGWMmWcznvAFeCbgCNK7hi3zkqQAU2m7U223BR86kDooowy/dm/xJTgtw5DyqI5R8mW0pBDrIi7eIBt4V2Ug2uJPcnTalyGlLKeFTROZ+dbuHH3txSNPBzSDRjEfdfCAZJZ0QyAgkxBvBPkKER3AytVobeMAOVNEIqXs/VH6ieQ6fpoUCiwG4cEr/ANvinnypFdHiw3dlAovZAvub4Xr0OXju9fNCkWkjg4AWchICEXXU1F/mWPBkyxd+btEdQQJdtuKa1IZMdzfUg9x0Ad+mAT9L0jiirRYn6oAHuy/hF9eCFoFRdsTdpwMxDTtsCB6snwI08awjI7u4pAgEE565PUkFyeB+yooWs7ePFD2WRwggYx/6YoqFzib1FLFBBC/GLTkCb/CuKDgCXFxP8UqXOEbYo5C7JkHZGPjYztXBmKCQ88k50OyEaEMcADtyWVQfgvhXfjUCYdXd0cVRE4kIlM7bWiUATuJJUJ9RBKCn40mUe6EcMYk/4XUOG0cT9tCckNlKN/lGG0oL6oAKkY2aCGKPKBnyEI/Sht0N7msTIaYJ4Mbz4Yp3WOHoCWkoVPDWt2MkMeTlzn00A/TYZBW4uQ0/dU7ikogQmFQAbgB2GeXFNalbl+242Y/JLfSS5ptjXX1mu1WniRXuWDgengxv2x7V/wDcP7s923R4rfZfYBO0ZHu7Q9zR7g4ueBtark4Vn4WJL/mUcJ/Qe6QBDnYLXK33FECEt0p7FE8k+KCHZZK2PS0aKQi80oYmbj4jZclbhW/4duu4WC8BxqBsRDTB5ZMX6k5RC3PEtHhRlHrMfcR38cjUAi4sSgN6Ah6WKEsiXFibf11kB095SpuSo2gWuEUoK6gID+k00LmhFDVS4FzQAAAL3dLTZbXKpyoQqt9uqITdquu3Sp2wf4jGVToqAIRZSQVuKxva/czmZPsef3Prb1DcjiQ4Dcqipc5v7li9aMYAe3ODv8wBQ7QAQgDSBYcK/cH7iQeo98y5MpgaAQ0Oe5wLbnUOr/MMnHKC5NtW/E3KmtrhsVboQoXW6hSOHhQVuh3KdNq28FFe6d8pt2hvA2QrfwFe2opH+XuaXBAibblORr/KfZPbc33b3nJzj6X2vDa4+4e6DaVDWAEnbqg4CjDnYmZhvJ9Dm4mY0x+4+3Z4IdsdG9HNTRCKQhEGicRZVNlJC10La54+OmtxTRwReSFbfG9abQSTcBDcgeI0q90UeCAaJYkWsac08VKXVDcONxyoFT/tW/zoHmUCakAaBttDSk8LC3ju+Fqa4Jf4BLctaJReB4Jof6KAbcOF1AvexKAqlIv6kOs8FUcL21G5D8EoTTng4NLRtClpJsiCxrK9nySCx4QKdu1xBJuhO0Jzr3LM9ODje04aG4RSAW3tqvC9e5QwFW73OAB0KgWJK2RKWDGC6DgAQbKeJU1jGb2w6nRwBVt1d4/HWkh9vb3z4u+J1CLau/7hjgDhchCdLABCKye9jtJxg8ucCR+FRew0rIttJQ2CqSVRLptSgQgRFB4rYhbICtG1zY7tbgLpZK+1LEFwH1KfnRPDQBCeQJaEKVZruP4tLFF6dBRA4qgRAgJUk2BJr/Bp9QB1B05HVKPUEI+YR34tBeuOnADxPFaQkAj+Vh6kAsqDjVja/UEOifUUTStxB3PJJudQhHyFNJdq4jTgiAiwslEgjQ2UIb3XlR+nUH6DwXRSDXAq4WK/CwCDUUMPDhM8oavZIL0DiUJQEBPGgMuGwO446oXG2h4BatFoSL6eI18aXp36LcdJ8VUAgUq8yF00RNdCT9tXw8ySWCx9OUAxuJNxY8aLu0N8/kjVxGL+FeJAWnxSubkdzJgWFpCemBCOUXQH52rrlPakKpkEnHA+pMOygjx48amljiynxZnqCJ7NJyARqLIob9lY8rp+zELdqAXsEKg3DlrfZcdDjhNOQJFkPjak7SCfJ86/UCSnOwNrip+4SGAk7lvgAoAfFfnrTcCQGQFxyw0dJCBPWaE8dPGtschVAQCANSStidTTpJj3pBKJ0l5BBoEHyoefsYF7QGoS6L41HksZ35QohJOq3IPKo5ikXbt0pqSQATqiihJkP7+R+TEm0AkfynQWqP8AUfmlDy6T91xrQ7cZJTv9xUsAnE1LKoBjv2vkvK+ld2ESjtp+cShvcXUBDQzX5ETpfThYShto3RQhWm40k/6WYkzzY8BmONGLtBdYtavO1QxRSdsFYYJb/Fqg2bqtOmlPmjyJMkhMdoAGqaEiyeNBsbdWmd4UenV2puSSOVMjMvabHudIBp3UVqWuSTTXZBAllhPblChZDcon8o+VQwdjHy3mdZMglD3SjWhAQpH2LUzJmMiZDOe9Gvdd0ixVSeGlMfNCIopWwOgxclI/U434stfiLCjsjQBDFjak9wpb8RLR91LK5w2psA04EgcCWjRaOT6gzEHd3p7E2IRAAiH7q78r4DLJo4FB2j4IhJPHWhM6cNsALcAt00QLrUTnSCYd9T2hwsLkgDThT3CEmUO7EQupuqrwaOdEuiAiH5qleWg8KJw22RGAzqSgKkKqpRJjiDJApV1l0JChSFoTNjmjjYEEkxHaIJNlQCiQkna9QWjUKvFEG263qLP9vyf8v95xvUy42fG0Okxsg2dJE1wLESyEWo5uXLN7hJMS6ZxB6pi5zyQSguTdKfLDEWRgdvLzMfG7Rc2PUN5oBoKdK14j7mQt0I9OefDqHgtNOplamRfgpvclCambLLDLA510HmAltmkfylURUNSzTR9+aLsCF0YGP6T0xUYhII6r/OocfLmEsvkd2OUIAICoIITqAPzovjeHRyZRMl92Qcb8LeKFfur/ACtg9TLHkP25ULiECGxUgXbwNRyRtikRWq610uAqBXG1RsdH1O3OEaWxeySFW4KE2RFWo86SfttmXIxIlH9x+ny/Wnk4XAqUsOPjySw43m/4guHBOW1bVJGD3ZHFwWYdJVSVOlxXppkixPThsfNdUbqCdw4miJmiEIbwL6vQ9O7RHDheoJk7JC+QOrJIDkAzLHTW1FJ8aCM+f3CtspLoEJ+elFxbiui3FRZb8WLre6CuxhTZmCuJ+uyG5eRiH3FoKljiHAOYn4SrSmlCPAlMwgDQs4I/TDpNzxqOQYTJ4cfJ/OBAchHWbfhA+VFwPloUbooCgKfqU1D6f1M8mSEyTD/0zT0/o2jh99CObyJwmPdqrjHRziQTvcNSi13IcbzfVEJfbZoQgrdf6a9HIewNNLk8TpxPCochzLr6TgpVUvogHHWhjou3ibbQbWNl1pzZMsPgbsBNmkoDbm4isV+OPU5DfpKDbwG1wKbiBwoT46QWaDu2hDcEAJoRyprjkIRcADdtUXcSA5FrDyfUqq35tVU230SoGBckkqPwhoPgmoXWiCGmZA7a253KhvYlBUzdQ125RyVdt7HWvTmzsrOGEEW5JFrEi9YuFDY4vt7ja4BLkKhUJWv21/3D/aOThYn7n/aHvR939oOWwZ2Acxwc13+ZteC1/S6wNr17/wDu793ZGBJ71+6Pe/8AOvdBh+1twWB5CdMbAGNbYIGjSp0/IvuQlSHLcFBx4a1Zx8ARfwUFaRxsqr+G6ABUtovhRRCVaFS1w69uNWs4EKfxfwvQAceNraJxUaDStf8AW/gTatTY2v8A1CgNU4D4ogJ4kUmgB1GikjQcqIUKoOnwokEYYB4s+kIqWuaVwJKIbon9m6kEj+NFwLQAvBChUHaNC4Cg1iIN3bd4lpsU10twr3H3cN/V5BawhAF3F24KR1FB42417pOyBIhnvNmnTcQjj9KLeseD3DFHunvUnUzDYzc0EAKXPVE3USfYcXGI6rghDzallp3f9sBbw+lbXAROraKJ9M3HI4bQRYbVC/01kwe3hoBsLEW2hAbg6layJYNhKEqWvFhpfbWTDkQKQg48k5C1JkC6tdY8vpAFkaeNfWnEoboSqHT53r63FeFiEJQpa5tRCAsKhqK0KEXRUreo3ckbqAhKaa16fGh3Et3NKLqeoacVsa7ua4X0aVKkaaJxpQ16KoRqIUTjY1tdI0i5uwgBOaXWtrkZoSm4FLbQEsQ6ndiFpFiNuqA3AXRUo96EIQrjo5p0XQ9NDdjpbagAJJ1UErbxpyBONlCWt/5U36dV+F0cT/utU/Kv3X7R79ht96/zLM7zv3CcNsGXmYr8Jqe2e3HLVzAxwubVmy+3q3DOZmtx2zBcoYCK0FOLRYfC1M7KogCEHTQBNLtFTPcFfZB4DQtKBSFo40cBlBHf8kaIQql2gsp0p3eDe7KFJx8kgCyIbhQU050Y/wAmMKc67rhTsAUqnDhXuzfdMDLm/feQS3Amcw5GC3DIQEFzkVfCmiNcYRDqjIFsaAIShXrJJQVOz1APtMG0SSaZaqNoAVSQT9lNnXvd8+nl3dO0pYltlcPALXaGOGxAemOv6kgX2ixG1OKVFMVK/kSC3oC0pw+HjU4JadzYBPsQ2ahB+J1XnUUMZ9PL2cgT5xvkkTmzUKoHfcOFNi7ZAIb1Kbu5g8dxrtxfT306rknW9zqRSuPb6UljAKEHjpoDRje6KRLsN1HBtuBtSSjaDwapI4lERAUqPsMd24zuKEqS5b6lV51DE2MASTrE1WkuyQbqmi/ZXYllHdC2VWr/ACBUHE0xsL9ke5w70C31CCy3IqQbnRSXG5SiHUkhBc+FQiZInTQBZQVX05W4Uaj51kmOOXFdJdmWixZWOAP0nZWxUa1HDJLveT5ocfp4tQ82pUgOWexHPBMYwVaToqXsoqWbJ7DTFvVR+qd3FIaVN7/dUswTbK6IQoAEEqklLorUqJj/ACpyOzCFXILQVQXRL1Ltfj+Y6BFUemLShLTovPkal7kqSL5shG71gJsNwWyHjQMommZEna4gImm4o0X0FhUWbjPEEsM3fMmQmQXNQD6HKQicrV3SXb3kziWY3AKqU+m605kh7Uwce2dqqnAjQr41DuTsbUPVxRTbTWoTvvL0N49NrqhNh9lSsAVkJ/MIAiykaglCcQUrftAJ1lIPCy+PxqaR4LwAV0vKEuWgIlRBp7ybSuPjoVyDtKLqG8aQxJISfuCLtBKW+ddr04mhxxOO1ZEk1KG5AN/jTy1na7Y73av+r0ufAEpQMfZilvPP8wLaXANqz/c/dvcXST4+QY/b/wBtxDzfde60+pnM1hgel4cxSiRYm/4cFWeS4mzgQQ4tJ141G0SEuZOGxi235KLi9SGz4sJZM7JAH6XuTdhgaDZ1jSRnuFiJMNO07V2hBJVKniEcjWSg9qJhFspD+omPEka8Kx8THZkd2KLH9RIUIyM5SfUwEEFUslB8nuc/dlnaHQuOTt9r3JjH1aWIvw1FS+yey+6u99OD6cTe+wB49u99LmjII9u3EPHoSTAtlo+WphyFkgsS1RZSUQXr04CSRFe0TqNU3IqEUkJillXoinC44T6hmW1F/nUr3tgiJnc2aEhU2q23K9AWnYent/FdFFw1vHjTonugjjIBiQdnGAxwv0kWc7+NR4+Pj+oaochIQAINwegBqOOCPEK5H6kw/wCLTTpG0FwBKE6U4zNEsEBeCn9sOsE11qCPRykwDabu+qw4CgJ8h0MtksURUDQdNt6yp2zZXqIGiBAmhb+EgAdQ15VD5mPBi+mNgVc1QVJGhVKgmYsA/uJLJ6kEoSmgI0oSHJ7BS85X/EuCEAJoQdajkbMrYAPUZxA3gt5i/wBRqc4uXlW/USDIP0gWBAUhw+F71jZUcyS+mxRkJqDzvZENY/YvBPjguC7gosRx4jwrGG4OcWrODe/8q8UGtY2NYHddNEXwTlSj6wl1Nja5RFUD4U7bO5lxYkkEk3+RWtxndtP1Kt/5SQtDtuQcHXOpRE0CrRdkG24HgqIvC6rWNkYxLU6TGVvwJS40PGvTnF84BUIGoCklL63r21qNPczzm2HV9SgBB06fCsjCJPkxohJKAvJIBBKj40WgCNrShUKtzcoLqVQmgWknIAso6gouVUKCKcAgBsRqut1ROPOtxXQrYKUKaE6pQ0RDyRtk+a+NJqqEKbXFrXNvjRJKBiKeXBeH+i1uS2HiVBsaPO3AX5gnwpzj0iyOROY6iqUGgXQonNCgUKKOOMYunag9W0cHC/iUGpo7iUFxZQCBoVFZG5nEqGt0v06qK3T5QbjJdwCkglCnDQIoNOxYvyANuoARo1sCVJ+2p/29kriw4ntwI5G5Nks1yHhesr2/2cuxyNwyMoAXvcFEJJ+dKEXpOU4tBdyG09R48K2n6dAERONyLkGhjAhQ0aBSEuqhUcooW0RxsES3/Dx41FBCEQI/bpbpJT4Cn48xBD0QWs1CFJJvWTnwuCb27XtjG5QqGyAI6snui9wSVs7QG5tavyuotT69tuKISt6xMj0x/Sua8iylDq4X6XWB8Ky1xsDGx3ZgyjjYo/QYe1oARwaHFTqOdFrUEgS23duUjQtO0Aj7qe4YvqJ0aUspIQFCFNnGiqY6gABzSjVIWxS5SgZpyRyvoNB/vEfdQMDbKSpNxfkb/A0DlO0VApI5nq5DSj3IATfVEHO/Ku46JhJRAjST8glZE+LC4NBVpNv/AJRxU8BV7EoHIeI01NqsT3Tqh1CHjoaTVR+IAonEAqAlAhEco8eFkQOrzociGzSRkKFJB2kNP066JUNnJuBJ5JfWwBqf00oi78XalNiNo18fnRy58726CCfL9NBhd7v+6l4hM/rPTGzfbNzfjRjP9/zsuQP4oNK7UkAMcKGLIQepCagpYBfuqeWUliOA9QhUgajaApHPxNCZN0BywDcK4koAhRLga1+6/dP+4P7V9y/c37pixcPH/wC3kGJsbjYHuxdMcv3n3neHYpGAwhAAprN9xezEjky8o5LIsYgDMyi4uJFkaSDoEruHvY/pwxex+E6ncALtG7jUrRMLYuKQARdCFtxSoTHF/jHZQ+BQWKLtXhTYZ4Zou2ncjW6CwRL6Jxp73gulvMbaEWt/u13Ce0dO9brxV/srqBUb+45jrkEICTaw0ujag9bLO7H/AL6SD/FHGX6iCdb1AMZI4Yls5L3O1xCJdtEujUlEyB+nDCRctW6ECi6NxlMQW/1CwBUjW9RRYkWQIwD5nJVIHgPjXenkm7SoZC3UqCAS3RrjWTBIjCANpN00RG6NdRBkMm8XvoCNSVRtuNWZDKvkyDcUPVxCfUBUvdbeFv5SgdC8CQhVx+VNDYYBFMCFl/UHueLTZbKKMMLoYhAO4ZSDcbgSG6jU08BrO4fULKT5vncQuhAPCpJOy3ZFAGCKbawolk1J/pNLESMiQjH7DiouQSGqp0K2rZNKQR5AlB2xLwCBSoFRbnCWNAYpJymUIgqtFipsia0Y900PccXdogrYKNx4brVtlK48jE7tnDu2sBqthUrYysK9rvEAEuA0upQ0Iw1RaEH4nnoAtZM7pw7MJGPHiwL+WiK0AqOVAatmWA3Kg20C/fXbjDUhPYkfj3JB0D1shW+tERKAEMrTbaeVlsTULJmdqCOfWF3m3+rUqf4UTjw5EfaWFyCEWuqkajieNPisp9QY3kkO9OB1AbipK8NK65hAPTgj+Y3ssQ1qSWdGzxI0FbkX0HiL1LDumyipOxx1P1CJQT/VQmbIdzB1xbV9ONEHOt8cTpSZlJadzTGhQuat0XjQh7vZ2qY8ci+QZ/8AkroV4UIZcZ0UkUIEnYUmbuG8zEVxI46pSRsOyEiDuKpeNAQbENJ48629rMf3IVUKixEHqPEX40GzNaAiww7S1gsp2ygANcOQSj2biZxaZZ083i4gBSSed1qXuggBQDE3gLC6KL1I+UdqVXeaAqBxQE2N/E1M0TSPibAu4hXd82JVVLSFvpTMaX2/HIiGNBGUHqkICu9UnDVKM+HKTjIIA2EWOTo71RKXI+2pIsiQnFltF2SpxeFr3BJp+Wcf9Pi5HohlbvTn1I0w1FySAvGnQ+n/ACZ++Qqel4EPuGm4vUccrsg54OSMmUgDHxST+lOIOJtrRhXKmgbt7oCH/EaHpU60TJ6prBZcfUIQ0KgcSRx+FH2rDOH6z6nTe4nsYoCKWtNxu2/fXbMzu4bPhDSWjUBwa7Ru4KDXbBHqRiHHgmCG6/yjW1Rw+gHcwO96jIuW5bsi5OcACAp04UcufBdg46kTT7HMxiQCQWtcGu2NVAR0nnULHzNgdAQuQDqGkFQRqqIt0r0/fU9JBtcDXal1XgKLVG0lQwEW+YvoNKbKMkBi3BcRfmASulNMOSCu76nKNbNAvTT6sE7ldJ9JIJOgI4C1Y5B4NAd/asHKSihPtpGEzk3UIWkjUoVAIPjWPuxx0qXu6SQvDitKCgQ9CAFOAXhXqZ8ooAUQkL09SlDqiJWT71nLjt9EuLjhoBPSXAq7VQKzXMKEtIDS5VRzvil6lyHY4/CCugaqoCNK3Gw+lQCSn4dAEQBKOt3JodV5kFB/GgeKPC8UAsF1r/hYv2D+mn/CcfwSpuSn+igF+SLWxPsC6N0I8K00so4pwXwpP4D7Pleri4RLhBoqDnQsb/8A5lJFgoSjBjktaUUEkuPA3FyXDWgjSTu6ySXOKlWoQhS964/UhUI3abohI6iflWT7hP8AWCShBAJRAQHAIgN+Fe+DHy4yLABoLggCHc5bWrLnRApHVrYuB14rX6ZriNDYrc/eQeFObjYsi8RtI1FgpBVaB/y5wKB1gh6UIROK/wAayX5GI9qEBrg0tcRwFlVUrJPpX+muE7brFSXHTjRHpXFb9SgjUqLW0p3t/pdsJQ3uelQUDvpDhWRlQYx9IXOIQbgjeLi242kUACHBCBptA1QE2HzpoEtyhcQFIuDbUCuxjoWJoluFzo0klas0+qy77yUa42UDaVCD7aangB4cLHRFoF5UgHa4FNz2qhXxXSkmXuIup4WaChVLV33HOyvdPVH9Gv6I+3+luRnBqgjPSktYHqA5qUFltp8qaSp26dRHVofBUpA3YXFAQQTa2iqDWa1TOICBOdfQECycXBdKyDND+JQSlwLtcOF/Cl1IROa8VsgFT+R5k9u//wDSeABUOK0JYiPU7v0+QWgCyag6G1S5c2RNLmyFMibIaMhrByACX4W4V2bgaiUA8CLJc1EcYN3/APOIsiI430JrImGErvUBsBAaXFo+oghTtRagl7GKwxZBmgib+oLoGhAo1Uu+w04fpBiZIPfc4EbTtJaSFBbc8K61mnOO7vepurTYDB2gtVPspjGYhIfqL3LDqL3AT405skxEJXKO0u5IGhqFAdCoqVYBKwknsq0ZOKQVaQQLqL24U0xxlkT/ANPkSgp6q4cVsm6osbG8p21ZkOpJChbm5sPGsbIkIhllIPaBHqMUwDs5PqwNWuBULXaiLpZuBsh791BNiPnXcDgp57uKDpI6XbgErtsx5hY9kBNA1SRdCA29QwoZJD5x6XBqDgfivyqWMSDuFCSvcAH4ioQtAWoBE6Ye5d4DJyp0ON6a3bEI0uK2RpNJPYRAepJtq0KL8V4VFLmHb2iCign1TgpF1JaOVLshEaIXoRqtkNz/AEV6eLFBfKuPJL6cFOBJO1AeVZuVCwyThO6JyspuiJqvhUkbMUFsYsnKxAACmg6LtxP7xEveCT35IQFINqic/wBMe3kOyJMVw87szHUElCVPyqYyMx3tNoQAhaDz8QaDrNMat7ajbkxcJVKgICmutKINnZCDd5p7QuN0p5mjKYyTC71EoduAMRNvL/ECdONGaKP02Q+YebkN/wANGUIagC7iUT4iooA4N7ZGRMSQASbFOpB4rpTPSS958U57zid20nSSEWW/JaBmdZyRTdpZ/NDlCngrdeVAxw42PERfGhPl9OkkX4g55F6lYZWSl/nqLnREAugaKiiEva7riShaVNygJVFre2NrHBBqASAEaFsOA0508yPSWVH9sgkXsEJsCEpdRL+SSlyhVSDyTnW8yXiReG5RbW7vvoS5EMgBhWJ8+NI2NpJ4ckWy08Nv3V8ziGsA3InIac676XEBEUktwouRyVNakkMYMkY+t1lFxzBqCNpSCb1DojPjpku4lX6bBf5VLM9hEcQSIQloIFggvz1oPbIDATskiA6r/SpAuvGpQ1h7MUKzGAiPpJBR1ySQKkDZMeUNaJ4pSAQAioi22pwqGXE77JMQP9NnwHcFIImx9pWzlNMLBkROZDC445xydznG58FJW5rdIXCJ581dCiHsIBa4+NJLEBjynvxYkAT0w0UF2qtvWNEI+zDLJ2MXKURuB1V4NmijHHKXuj6sra5N04vtG2ykIeNY2Fme4we2Y2VO8z+7ZDRkwe247cclrM3s2LpHdPgTTJMJ/o8YxJKzIA9QcjFJaJMM2/8AbZGhed6m7ULUjQ/V8HAi91JrMxppQ4TEz9qwJuNuhKEVMHF0feRuNMpJBftsEJRBxuBQjuyO5kHqTrArRmJ+Fx+0k0I+27tRr3XzktUlUOaiKS3TnWOzuDucXEFGppjfAjQ8afk5MwgQHo9QIESzSSFVBURwy0zdU7lcgydxX9G3RCPtNY8Rh7MbHjI7zlHVYkhRclanEmYqp2XNNjp0qAfspBJjgEGbHJKemRNzXF3FbXSjCe44Z2KV9KQYFIs5yklSb617f7n7yIMj3L2L2DF/a8G0Y+DGf2/hBQ/LbjWMi/iQkpW0RY2QyHEaZSCAjZ7NLeBQGseBrmtEAcQ5NowenQnjuJTjrWBnYeacmabEProXeR6HPMwUgIVadKMSA9RMhW7TckkCy0ZYsh1ncQqon4eKcKG7JCrYGxsiFTXZUiEEI1TYjgbacQlQRKgCciuhOlWjA4k9RI0KgKb2psWN+pHEAOcjiQLpcDhRm92yBjent2Dt2goSQhOqHWmYWDkNOErsUlpPNGiyILVkz5BH6kBQAtw76i5osByp2CXHr1KmyH6idNayHqFOgCXsDpcIlI1ya7hqSUKaXFbZAdxQC1r8QNT0hKQE7yXKiIg01JuBzo3XgUuhJGqHwpPAaaO0q6BrV+a8Dc10IOa/eg4FKQ+HA/DcQTdaUa6aLex01T7qIN9yByA8EHLlWiNtttqOCHVpFB+PGWjqbu1DjooJJHyFBtgQBprYnboABau9n5PqHajEsHI0rYAq4k/CsnGxgXRhhDgm1AAgRyAWH217qdG5B0c1SEKBxJC6UW4+J6na9ZGhVQm6Gyi9qHu/vDvTYuLtIbvAVQCoDrlyNp0P7f8AYwMfGR592y26KjS0Km9fhXedjYYJFukAAINb/eaycY4WE3q6sfD2nhtVSbH4Gv1HtjcTFH/VANP1ISCiuV3wrpxnYp0BG4qilLqV3fca7uAdp4NUIeCLwSne14OMMjPmc3D9s9rwXBfdc7KIKKQUcpvcVP8A98v+4v7fwfaf2UMxvqcbD92wcz3P2o57A8H3P25ji4AtT4Gp8EPJaQxw0TaSTqv8o08aIx1IOocB4FSoXjRd9OiqFNlUK66FaBYVLukhUQ6qLqDTbAhEuBa6cbqQeFLCF/BusgIut+IriPwoqBFQ2sCFvRVduo2kBzr8LGwolwa0hHBm37y6ykkUZUHc0EirqlkHBKDQ4k5SeoAJuUOoBoSQQ3gJCi50NwTwIVF0rIEgdYKQiFDoh+V6co5fZ/5V5aNUBPjxFrA8K6ghVSeLdPq52oCWH9R3gInk2OKo6U8QTrep5caBYoS0EX/wp+oDU6nhxqKXvdrvjyBBkfqRxQgrtadDW/G9sxcMdrHgx4IDPkEZOOQHH1U7v+tIW/Gj3D3ZZ2pvAQBVBCCytFql7mSfUwp6bFhvrck3UlD86O0mdjQCqemyWqPq4AhaIM69prcb1pDfVEZBRAERRppUroYu64/kY4JBIxxdSSC3cPtpsrpRPlzNhzh2Fnw8RuQNpxMoFC33EGLS6VBDFu7h7MAlh8VN+APOoiZi+WTGbvjCn6QVJ0JJWvMlQdJQnp0TQXVDrU20HQjaR/Z+pRqPsrGjzJO1jiZ0UspJ+o3A4bQdOFT4WG0sxSllCn013H1Wu0ppXd7qOngORCmT6j9KCqFoFng0GttMcgAAXaGoDZQRoanlfEjrwQy7ksUU7UQG1F2WwytiH5cSgGUWbu8K7lgWglw0BCAdSWsEqLDa0xWM4aAfT5MyeCkH4oKk7nefLJPj5DpULQMhUDSAG9IA0/2Vke5HMd6yXK7Uft+GT6/FUHd7kXfScUkflE8VpY5e64NnG4KLIAvVof4GoWE90J2C+Y9/bGmpJQlDomlbe+DH9SBo6bWHO5r0txGFnMR+odw6EpuDfCo8fIPYEqx9yW8PMAi6DhWJBBkxZD5R9BaTDiooVzrbtxvxprB35e50STbQm8KWp8E8LUI/zHzZJD5XlPyygX5i/OoUh7facZ9gPbJugQk3TUc6Yii5bLp+adCeCobJQjYBvvwAnb2GqSDZqIVo7JwW6iWFEyYyNrAhChCb6JUZcdrj0PimuWoL7TqPtp/deY2M7zo3E+XoQCbITRZIs7E10PO6aigRGHOU9sBbL46Dd4VD7j+5YIZoomns9/dPgYcrXA+dCNQgr2/C/a2B7fiziEz+8y4wZLgjJnA9P2CDYHiOC0VYIjJZyBQfxHTTT5U8CdIh58cW0CyAKdQHLWyJolY2C0gCErpuBTRdONdieFI42iHcqbdoUt13BdVWuzJuEEhJCESyDqRBx27rVFGIUY5VV396SSp5bf4U2MFHAyY8uv6m6LtSwA41O2HdG6JRIICYwLIAC6zrG9qDB5NwQW9TSFvjoAQFWzvGruLJyB5a+ZZ2h5BK87yoJMk9zQpNfRQfupvdyRK+Je06AJYWAOtvjQmZLuZIfNJ1G+6a2AA14VlQgo2Jwmm1nOLGSBx6v412u4JZWFYwAB+ke1UIFnE21vWVLNjmXyAI2BxKZAKhuGjrO5rZKkMU0Ik23iIJQp9KcL8uNSwSHkO7ceKO4oqih3Je3NEP0wgCnHINtVBa4fHWhHKJpDlATd2H6SBoHaNUOvensZIR3jvJmB/VemJ1F0Va7krTJILzJ/hyNW4h8SOI+2i8NOODOoiKuxbAtKAq5OFdyLHSZs2JBAS4enaFVxQHpXhQbNGMhsTkhboRe5RVICm9d4Tbv1QMPaagVNACE8LpQf8ASybHPfgFgA0/UCoJsF8TUGTDMOzPiI2YB1iAGoG6jSu5lTDu5GKfU2TFSAEgkAEFxHDjU/dJDLuECO/IJ6QOZXgb1h5PuntWV7Rl5OLiztx8oiBx9nyAZsTO9LOSP1qjnag3IymnG3dgODEU3KO2g3Si1s7RLbQ32p/KpJFQRwZB7YTpFyAvAgFdKgbG0Ei5NyCqfepre4FQLDxJRQQTc6+FDIJBCEbXNBXwQfCty+mgVbAOLQFUHkU41kZON7g1s+Th9iZj2teSCQA4Ag7UTglZUIyjtJ8VuEGlwHDjQeP8QT0gBAdApJsPnemz+o0aQAQo3Xa4kgA7eVN0DUQHxKa/FPCuzKqAkX1UaFbgqq60ZlDVUgoo+4G96GQSsDUjVUU7lVUUUS07SuhNgtitgo/rojxcE13XAVASCn+h/iQOfFo08K14/eEPC/jV+TQCBYacQba14kAX4FLeF0WtoQpxIN+Dj4IlKUaVtcpyCeNbfTA7COi5J+Z6b/HSsqLFd6Qh54XUqHEEqbV3MvMJDkaLkk67SECo5PjS+45PWxpKjcQ1UU2RzgQg8KbgI4oB0lAgaEH06gKD4033DIawZG0FyAhoBcEACISSOFPCt9OerGxQ4ABuqHgdeNFmMO+AboXEaKpDUAQ6EVlNc09Kq0EdScQSAS3VKyyrWxEuS51J0XUXNNAcXLYqHagIUaupHDWiIAWsX7AlzuQm5WjjghNylxWxJuF4J4V7f+4/bsduTmex++YPuyKFAw8m7Wgqu4BOVYf/AGl/Y3sfv/tXt3uno8//ALgZHvu0Ne7Djawe3+1ta5xcC4E8LVk5mRpkAEAgA7QR27cNoFNIsoQbeCKgpond8fkFQaA2Fq9Uv9kKpsFIXUA+HCnAXF1cbtU6EcBYcaf4hp+0jhauWtv9eNKGntooKkAOadpHBBau0XWVv07bkLZVUBpraOaEr8DYkDXhSEPcPDUaG5OiHXWsnERQU8trlC3UlENTS/kI2/jfpKJw0oqgQA7rHjoAg0Ipv+bZGVhe3elyC3I9txzkZIyrHFBxiR0u0X50BHB0qe8fAkoU/md9xobYG9oDzoURLIp8Qv3VZZ4kJ75ATGCJtK3cAl6nl7+L6o4yCfHQF3JQbAuGvjXa7Rx5MgDuxHiSEUKqU6KH68cNgCj+b6tpIvb7aEwb3yfpFsdxAIG4fzbTwFEy5JRo3HVEcPpQ2T+qjts0vWJzgFXmbfZQ2gg/80KiADcVAu376jiAaBIAJDpuQcvxEnj41HL2tzZAZjf8QUKvDSu7K5wjjOl3jaCgAbayGonRr3ZtRcNaDoeScb1smkOVFrKYTYcL3BF6DpJGyghSCQGggE8QqgCi8cGog4hOSC9CXKjnmY0jb2lxg0agWKAc/CvUduCPuzbe2hZioTZVuCAV+NRITuQWvbwtqnPlUjXgb2X4KVA1SxN+K1LOZ0a7HSOG18hCo0VDqpqaQ/lhrQfPXauoAN1HgKkjmccnXIgMx+wORP8AaKyGzRQI6ESx8XEJtuQl0P3UTBFkdEm7+0CpAGv0lfhapZ8uSSTI8hceM9yJJAT6gPBRljepIMcDuRTpIg/TEkJY62J+21EiQvmlsR37CQX1RNqWra9U7e3cSUKdRQISEqOI3iEMXamT/DIqtJCE3+2jjwyQwRzE5b16SAy26J17250Y2ymVr7CcdZ3fzGUoR48ac4FSSB3gXH/D2AJ4A1N3CetDqu3KSyBVUA01zZXHandGhPAjucnDhepBCq5MQIS3pIxptH4XFOGtdSvPFxUWOmp+qmxwTZHSVkUD6BonG5oOSZY+/wCPC+qq3h8DToI4+uOAlMe/ZcVdqn+29bD+e8AFCsa2/EUBPhQibDGzYCQPzBPuQbnBAqE25VExxan5c+iZAVF1s6/xqLZBOHRyaPOgvcXU351J3HlWRZCANR3mEWVwsV+yoWQSCTHLW92H63HJGhBIbuXilqxcR4MbTkbTMo0T+awBOn31EI2iHMEHqJ2zk5HUv5MDonXIF63iE7JSSZnWlSQkE8UcT4a1+olgiABIhA/Ch6ZiApJ43qF0bDdE7IIUnhcn8N6Nt7VOPIQAg1sVu4qaHeaE0hLCnmAqFGimposnHERMwdIhsqBDZR1E3TWkFl1k0iBAPDSwNdzcYz2CJXopmINm6oT0repZDjpESfNB/VAXO9boE4Cg9ixRzdQaXEuymgK7LAIJafAU2W0Ukp6pUuW2OhRCKw/257B7Zl+7+6e45AbDi4Z702QVFtzTZKxR+8vZ5Pap5YsU+mDlyXFzd4a5AGghuvhQjkBk78zp5o4D+mBagYpsWobIONNjx2zB8oKEnaBY+paSVAbpUGPITL5JLZCLeogVB5KKPE/Oou8JsqQqcpMjsIdqDEAII8ba0Yi4xykntOnH6bjqA5S4NKAprXdSDtBzYXS2OVYhUCptA/jQfDO2WLL9N3w0aIQh5hC3UUShkVJW5H4bBLkW8EqDGkySi2CbhjL/AChoRHApUGP2cpzTk+eSQ1PkpVeWlJMGzzT7gFRBOLhoJATaBanSe7+6e6+/Sn0uPBPn5Zy8n27FxgmJhXJXDZwH4RU2FKmDHi/qpZg5MXFLlXLB1K8qnZDmt78GUYJcjGcu9jSUdfUkWtUG6cqCroj9JAuUJ0chpZt3pyXK0m50AIG6wCUFlkaOmxCG6NC7Tt46UjcjFbIBxALiE4hbH5a1Pj4WS4Ako0DatlJDh4Us2QewvzIC8SVN+FAQ5IUKTZXG2inqK6UWoDxRfDUX0SoTYrihBYdJ+CmhD6lNvFNeOvhQCm0R4kqhI8FK16eZHdIQovABQbm1ZNl9LdAAG3PFQFIFTt3cekgC6n7eFGdSVuAXKT8PEkLWxys8V0I0Cr40ePP7qICkohDkH2X/AIVYEhBoLajl8a1uJdbkfBTTgVA+GiheFFqOQBeNjfgeCCgM/wBuaAeAY0+ChRYhfur1GCW4uQd5Qxi9nBCOai5puQcYbusjodtaRo5TZTXqpyXZJXYFUGyAFhttTw4V6nKTsWUhxBUBbIWkAHXnS7g7GabIDcghHbFBAIalKswBNwC431aFD9FNNECscQrRuUkNcnBF3Vk4/uOKmTlglQCSCDdoJCtXWp8/GxCMdzyrQ1yG6sLdW8eOpr3PFzfe8D9sHGwM3Ox8z331Lv8ANPcMDX23212Ijf8AOkAF+krQkx8p4xyxjXh4IJUAPVNH3++ncu4vy2qvzpwG8ol2oA4+IKE3+00MpUeC8lSFv1XTiDrQaCLghP5z+G4A2rrRdkEaqhbrc/SLIQBTkYgLAf6eOmlKfByrwGqj5VkhrR2CLtsnwt40HEmxv4EBARa/+yl7JyUsFKfYea/dRlnn9Ib+QPpBuUTRStDaPSlx69HLwsFCqONJj/3ZLU1QHQBblUq5LkFl/EFKjQJTQbKQDzsqrx0pkrkDSx0YsAW80XVTRQLsJvYqtnWuNTW3+7fxW53KfjZaEQt1KJ9dSqWRECJX+GE6uB9RuHAnhf8A21tkLoo9pFsfVdD4i9bAFBbukJsbOVpVEANlFd2aYS947u1tTTQBxITag0vXcdkd+MAk/h9AAAE2qHdXzrD/AHblemw/ZPcvWwezzDLhyicrFUOJYu/BG7gRda7xf3v05BE8K4yqhO0XcQBr40RJAdB2IW6KgJVLJyotxmguXzgoHpd1l4Km5T4Cva8XB/ccf7j9xy/a4PdJvdfa5cebGy8XJM36DEBLnNd7dljq+FdUid4WLlW2trIV14ViRFzYIosf083ZQZOUhQk6C6IaaZZHFsobDFtNm42OgUE/Vf50GxAGWTc3KO7idHFOVB7lzves0zQuiB3Y/tHp5/005G5Scxo+VSPEmTu/xHEgniUVQBRbJK8xlTxUuNnBTdD402QwqkwPpy4lqt4OWycqxZhGCxwc4KLG6ANKLRZI6ET4gHcARNUO5eKV2t3pVgd2uKf+tZFUCpnOfD+cWRHIupZoVX8R08ajibknFmfORK8gOi2lpU9shQ21uHGoosfIEsKn1N75TiT1QAOLiruBSvUtlniC9mZwuUuAdEAa0UcfGzDjNkTyQ4vWIryKoVWgXGKYbnd4Ti7tVA4EhfmagmJ8hyNgZBjJLiujULMSVJmK63pWNdI2M9LSQCeCWXUUGtWKAOHZjgRCkaS+bqrTw40p7zxFE8xMfYheJBNvhTS1qCQEY4AuZgbqRoVB+VbZHQwvGQNwxgWgmMrdRdTxqWZjSnfW4PjzN1JvRbsVwCbIfmSDZw2jWk7itcRq08BdNAh+ND03U3buVy2Q6lQU/jXmSd18ZAAuilORUNLkp0gjhjYojdNdi5CDySR+Ejjxr/LWydqFuXPmERRxwOJ2aerHnovBa/O5eah4hdCPt/20ZWb5IpePJNTdUFStbFE9ryZZfIL9pSx3Jcjw40w5DZHPQOeiqeFiDahGkxcDkFFCk6gLxF7VE6RZSRtEoCHF0PL6qfpLHJuAF0AItkc2uTlUUOQs2L2u+Xv3OOjg0AEkhSQvhXp5xskcD2ez+GLUgk6otCHGBc7s5G4PXcSEJCuv8PjR/ViIxY/ejPppHyYq2IJW9l+2iIkhfZgh16tTkbksv2qaw8WCMd+aVYsWfJEaANJdIToBx8TR3TRGMEtMp/MRS0tvoA6jE5Zof7uMkHXUkX0X7KGJExO6s8Ua+Ve7nDXgPtoR7TjSRq7FcAp5OMoS45D7ahd+7Js2H2TGinM3oMZrsvKyMdwDcPqKBucmoRKzfQwenaZMgY0JgIBxyOY4sB+2o/3N7lHPNgNwIMaHOxoWjL/b+VBIZxmNxSCM4ONrHQ1+0o/aGRyZnt/tMrs/MOP2nZfeaGBzkG7cl0NxQ7gSOIHuCAf4rpsBZAWmmymEmAkwbJ+bl4niRT8vFh7EcEwE6icKv/SttdAVJGtGZ1lU+WLEOsASd3UftoZBajJ4lggJWfVQ8ldL1C6KHvZN28duMFALiADuW9draqQEOl2oGqdC48ydEtUmIXZMAgw2uigIG3qvqVUvvU75T2IDioQgyT7ep42uHA6+NCePHxsiNzU6i4OOIqHmTcqlK4QlsDf0yNAQElSVQn/ZUxgGM2GLF6sjGDd4CgIWuCFVRedLhu7BemK5u42DgDf+Zb62Wkl1FgFLlQlCVOpJpDZhKqFQAqAW21oC47yg7ipTmg00qcY2QmlyXKUUHwpJJSed3G/iTSQzhy81IBII1GoQ1wEDeq3iilNfqojHARqfqgEJC/SdwIIr1E4BBKLdPBQiX50qoPpCFqht7WsgaKt/hg4cUJcliOauNbN5AuenRVPy1NB2OvqDotuACqqAlazm7R6hHKqE9I3bt2ilKmdr+G9hqnJL3qNeBcb8ufwWiV4qnDUjUX+XGhcbxxN1N9RuFilA6qCRZEGnM2CVGgNwNAgN2cqhUKigcQNoX5laBJFifgQg/hW7drZblQR4fGvThCoJsToBdVOvzFDIw2OkVzdSQdxsS0i+vCsnFyXAZjRJYqW/SSNp/mCUYQ02DS0o7UEgBAEJAU0WkhAQnAKEKql7UMi7lABIABtY+FhXp2ubt3AquoLltx1tX6bECu2tKvcNoVCFsi60qD1BKi17uAFnI5rUvfWsnFyccjJxDccSS0grqo3H7KnxXQdiDHJ2AtFi1xIcHcTfUXrnts220ndZeAJNN9S4AhEaouCvEG1iKYqFqG5Xau06HVRWRCCil41UW3WbxQpTlsPtQmzUXS2vKgxCSBtJbfkQluF6ab3eBrodqWVRaiTwVSnyuR8aKlRpdRqSbG6gURrqAQTZUXimte4e1/tXAHufuOD7Pl+/+44O9sbsD2b2i2dmAudGDIS4WBJThTG5OV6huVhBDigFC0i5sbgn7qOyxIDRzbYakqimgiAG9xcEagO41fV23byOqkELwFFpcSRHwvwFrCyJWPG652vKDlexbe5ogL3VduQXabp4XFL2hBc8TobIpJDbDjTtpGOZyChKnX7hasmML3LE98lAgA225D7aO+YuljSZBdRZGprtIoYhhTGlInyJdyem0LShAFyfgKEcWQ7LjiyVjzJgBjuyeAsqkC3Ja7UrS0S/qO9P/wBM7+YaEhx+ISo4ych8cQujj6U5X4S5pVgJI5XqF0kQxySe9ji/O4SxCX0oSL+bOhlXW5QNHBf5ayDNjkhyICTju/EdxVS4FfnQaAIR1GINAaxLnp0QEC+2t6ebIoXaMgILkf2Sg1onspGqGYo30rrX8km+4cqdFKpkZkLEUUclCKoIvepWwv2xcTKgUkptQfC3jRjkPbkJv3bhQFG4hFCCgr4I9BODkoBfdqNT/RQk7kxYqy9nrQrwVDY/dQcCjBOJd8jtyt4EkfzEfGocJ0jRlzFcWHHcOkDUcSHeCrUz4o4XmZZ+9O0qL7uyeDlpxe8Ej82MD1B9PYgXuNKlKQfkd8EnsAAmyWR3TUUkHYln2theSpKorSeYqWZgMMs2Q1fIUIpUAnRUqTzZyIykrAFc31B1DSLgrQDQZnKe1JOLhpF7NuAB9lAhgbBjr3xIFNwUlBKElaVrg5kpDpGtIS+gI5gc6iMO5RqmqqdCiXHA3pwewSHaFjYjniMXXhwouaO7JITc6AKhQKCHWuKh8kOG8ny1iZx6XOUAApT3hq95HF83lpIVBi5hXc6JYCETfBYLqTKdQpNH08gc7qexrCC4Ga2hF760xEV6rFuPkoSLrpW2NJJnAWHShjuTbn4097bmQDcEO+9ibWQE0Gx/8zq0I3czqCQlO6R3ZehzEKKSQCBwJ+ytzopJAwiORj1TmbgKdtTRYzTttopB1AC/SCul713NhEmkzNJTwCDRwQ0T2zveFAZ1HxBcQEaR8KJWHtbSXxDcMhq3F9L0XshnSJvnRSPt5n9fHjV5fIhfjExlwFiQAqnqTwtTJ8WRzH9XmQ3BJCFp7lgTw+NPMwvMRDvsfSTSuBUpqB/TR7EomnimGNI7IKWQIGodD/CpoPy3Rk7rHqdcqLKQajEv1GfzHIFO7ha4CfZSOCNi/ESoyhkKRucoRBy0Ip3blWUcSidkHQcDyWojH2t803ehbHdxjBRSOGh+VO3Dqis4QNJaqWDSmoXhSqYu2jI/xKDc5mnKyGslzmntSEEyg7jc6opKoa3CXt7iYcU3N8YBHFQqrwo5D8VdT3Esu5AoAuL68qx1HURZAdLFQOCE1sjlCgK+aALzPqgLcSnKjvd6qaQJL6hETgS0fTa9RbjNJmQKMJuQvpnYpKbiG/U7aTzNLIP8XiKrQABo4n4hLLwrtpi9soFIKjHA0JKo413ceBIWJPJLa4QhoCKHELREh72U5qTsaNrfSlUsG8V1FdhS6HFKQw5FyjrkB4BJKPtevY/2t7b7RjZI/bgzHY2R7bgSu9xz8bIb/gPe3hjmLexJBqaL3CDJ9tyIwDLhZjTi5GA0qiNLUK8NVqV5jJmaR2SV2ooaA9vHVeFTSR7TMdonVqYqQGwAAsbioTmC305MGObtVU/UlTXl2A8Rblc/yj7a/B8yL/dWMVGxqEj6imiWv/VWSZO4FNoE5m5Xi29dgaoCLKgCgXCqhFNM44AOQHq0RA0KgJU1iwwwOyyAe+cMOKKFbvt0IEuaOPkKA0ordEXUBUJSoIcQeSgVbgBAuqhTXo8Y7YwCS4hCQ7p4omnyoZEqOsUQgJoFP9q9IoUo7xtb76dj3sC63UCEUhfGsmeZV6S1T9NkAIB1rI5qUTXWyUyxB3fPj870L8AeJ04m33eFHj0a/K2o40OW/wDiPhYUhC2aCFIaOBLbqDSnQDqapJcT+IaFqa0DoDCz7CP4pXyH2JTiHHcdy7QC2w1LQLG/20HBLktXQtDrE7dFTw41tb04oIuCSSFJ27l+laOfFuOQmpTaCFKMACaGjDISNypt4gfUt+k16YnqEYKWUEG6LrbWvUlXJZrSCV0uCgBAN0oTzubjIQHPKuXcS5g2qSp0sKJcW7ibu3BCQdu1DdHDnTJYLh3S3QgOKC4JKhFU8Kb7vgwONpE6kWykkJqHL8aGLlAPd1hyg7WoqEnWyULlqEFCmq8PDl4VlWUcGoQD0lCD9N/jTHBQAXBtkBJJHHgFopaxRbIilVKAaU7KlyFSyO1K2u0Il6GPABYqpCahxch0JK86GKHbQN+iKi8wunjRaASBrqEup+Nq6ulpXXR2vPmP4V38LLz8fI09ThPdG9zXfU17mlpcw8QbHlW9GnbYITf+YpqQTfglL8FPHmCAEHCgeJFg6yov4kCGm8UB+/gb3XT402TegN0A3FqHpXwWshkQAcpG0cA1A4cgoOtF5G29+QC6kcRrXZZjYwkJKuxw5M5BzKsBB4FDal9Od4F//q26kIpRLWqDdAztgBckIpcDYOC/bQmUb+nyACjrfYGkcalEjO0f7hT/ANKFQEg3Px5VvzIMktlgTvBBpodoJaCnzrGfKhjUY2RkT/4cYpKCwsNoPxr/AC/AzDkx4kofNkwQfp85boQg+heFNPkzSOY5JCqNUojSOldv31JA4LKCNpI6lB10QAE8BUkpmII2jaVKILFy3Cm1qheSS/idRjqQBawcP66kY2QslhKQCAEvP9pEJO4kr8aZJsMXe8p8ExAUqd6a3Wg3smLuJNFcdKTCEk81S5NH1QmdAJ/PjxCA9RoWclIv4UZIuxG18XmRFT0zfFeraB8DUsJttuPFEKqbEUwDbJIhRm0kkAfSXBA4p4UWx+WXr+dr0qSnFba17j++v3F72I8kr/l/tGPIhyn90Qby4DeM8G/IipY4T3sQzr1jqAgNmlSrekioyMdHE3DRolw0g3sKLjt81UVryGg3uONvlQmdkCOAtG+LULqSuqrQc1rppHglJyY/DwFtKEje9EiwQwkb8vbxLihCW4iiG+VKp7sh+kkiwC2U8RR7MWkBdISLBrbAlybVK2GprvJva0OEpMd76IqX/qq8h2AlImAEbjb6r3ThwoPD8hrZD2e5GRsRV4dSIgWkbbzxP2ivmggNvcq3+FSWLsdofP6eQIkW0CEgixO6nSNEcly+YAmxJ6CAiKOVRbo3F0UXqJXxqPUgbrfEU7IbNs9R+SYcf8vgp5cjSvTuvBUj8ROgNuIpSwF5043QqF10o9lu5G/SFJ3FbBTbwrDghdG/JzMVkmcIO5GMHJDj3D5nScggX4Xpiv7fUjt69soTtPFSePjT42vQOkAc7RdpNtycT8KYwkEyE93HhjT00kSgEFEKqtDdMXyxMu5ET+U+Jrdo1uqobNKX5BfsrzGsdGnL4hVUWK1HAclwJHcMaEgRm5AedANDc01krd6XDcf8vUlo75W45Uhi75IWZ4KK5CUslworYGZBYpEoNxzCDUk86DoAI3S/VqYzKRZQSqIaHfkyXQwweTNDc9zVFIJNv9b1PE5vS0grtvucAhuNakY6JO6T28gqW/8A7pqK2wWu8dY/LilyAW7lQoirpXbXtSMgQEoSt7DxNd10s8g7w7uwoFaAPpAJqafzpYZbjuDZtl0UEpptuKPZiIaT2CtzYLuIPEO8KayPHH54mlaSoQEdzLsVFgnKnRTOJ7p74Zc+kaCqkhVHFCaxpM+TPf7VNL+r9D2TlsxwAmbiAgkAPHUOS0xnt8LYwzdjwubjnH9bhgoM3NxP+i6QvBTUOFFKZDIdsszQD+mX6gUuVsvKgO2GSYYyJ4MgO3NLRZEuF8KikkDYo8lBLkG+1xPLgAddLVmx4s2JmsxGs9c+DIHp8qeyehydUa3UDlWPBF6YYmrhBkk5SdPAqVGlbpPU902hCgtQC5xnCxCfEVPPATKYWp6fH0JIHUrk0cb+Nek/cvs/7b91yP3F7bNi+753uHtkWRJB7tC93rMbMdN5kaYWhtcWNfvvF/Z5Dv2f7f8AuLM9u9qz41yVxMXLcT5jrubgFE5jnWXJDk5E4gcIJsgWsnST0hQWnhUkc5DQR/ZmcW/hUKhsbVFBg/qI3OE3fdyIRDbaHUe93A7e08OVk4GtxKIFsqAcygvpeuoLJYWNk+pxINgErevkAHVxAPxstz8K70lgbA2DWlVAIKipR6csmgYEcq6661k4/tmZlwDPXGyoMcN/WpyLgrUA4HhQ3lSFEg2lS4FHEkq5V+2u7M5G8AGhAAhIsb8ONd6Zy3U6N0UAaJrR9NjM00JI3fhBvomtNnOzvt1CHVdADrW/mDfTT6hdKYbEoTci4sCeZGlTFCQqdJCfCg49J1W2trW4iiUAuQUVNeixVL6mgSp0JTmTdVslqKA2IB/lK8CvJaHV424Lpt+2goFx4hdOVJchACSg5WUlES/OlAXQLooPH50B0vJAcRc2FkXwowYrjii4ICOOhAcLKORFXBLg4HUOs7RoaNSXfdU8E4ClpBcU22CgogKrrU+S1oajkuBcO0LVRm1RSoXNBRzuRRSFJtYUuOHbHIAn1qLqLgAU70zT6rbxKs2m5H8qjW1Y4yPE6EGym5IVWn7q3IXY5JuAVB0CDgHHjXuWNYT4wftcQbeW7pCDQH5VkYuTqQHNJCqA4m+lkraHNReTeA5AIAB86bjeoJuQUYQg5glCoJozK3t6AagkFVB5iu1dQOAaTtV1yUQgLz4UFySQi3BFlPDgiVlgKS+4HHVATcjjTzMCrlQrx1IsnClDgU1A+9RzoBtr6uOpOiJoOFRkcgdwKbeO1FuOHwoBChvytqiuAQ15GoBuSLCx11JQVvY1NCltVHNbqKA02i5vxF9CpVfjWRKhLEKlbkFpFjrbhU5VwBADbuVx8TdCBXjdFFj8kutD2+KYQYUWT6icvAJGT8UJ+8JW3vZQKXIAQqE3bhp8Kgjij/MXvNuQ4+AuituKMYhDYi0CFqN9UDqQOKX+yoi+2L6YOyFU3FgF1PwFepMzhEC1rcf0dsU6bk0RKfD+aH5V4VGiKczRQ0VvVBj29RBZGmxBaLOF7nxqHuhe2BD2zfFKqBuP8yX+NShliTqq8bIXdRCcaMkfmiwlsiDQ2/10qN5fLsuY7BqoQNptcGv00mP3u/AMXEIGT7nkyOsVsgbf4AU3K9wDYu/58Yhd3zjEq8AgfSHLfka3SSj8/SwI7RBCoQAFuicedTTRmU5BAdKuOTEeACAoCfCozFMPPA7kZtKDqnADaG1LIGiLHMAHdl0LmkW2i4BIoHauRGVfHdD3ES9ztuKhk7fdlcCJmk9hCQ4JELqo+FRQsE8cETljarjE11y2y7Si3stSyTRdtkkKydxxPqXACzUNlNbg3tCS7QVsiJuPIg/ZUje4JBHA0ujjBBA0uSLqeVNYItrpBbvWNuF7XoQvSQeCjQDlxC0oHeIsE6XLptBsFB+2vO85jbjarUv1EJqQOdZOLGW+gmyYHzQaOmDPycvdqPEA/Kpw5wLRJ0x2RsmQu4hNUpDOQYZ/IkWxHEOBJUgCo48bqdIb7LH9I1S4QkaKb/CoxPJFIY/0/SE+OgCkcakjLNrrGImxSHSKA6ol70NGw92QsICSAcWzIl+VS9p72GT8SiREVR99SxtGhBJKgFAEDQBwXnQsXJ20ktdECJyU0MlyF8h2qijFciqmvUfnThEDESS2VjkuIyoyCSm0cLGnsLLXa91iXMGhj5FeNORgklCI5UCg/IXFSbnJYB8S/SUVAFQUu3YY7mMH8WqknUmmhhDnSbWKwLoddo1NRHJAZ6lWSxLpEhFw2w3IK2NaztnaEYTfsW1PHdTljgkYzdE0Xabm4J16aYyCdW7GPLAbqquJGqGtr+suJCcCl7EBRatzGBw/C8ZCKFJAISnenhPe7ihxCIAE5gKtKxxgiBjYRd4VFcmoJeeFOyMiUHEfPucy3dcLDs8NKkiOKTHJ5MLASvSvUSCo3L8avHBKz6Qp8gCIgjq/mGlGJ0RYZEBjY4g4hJtOHDXmdaXsY84QmUm+TIoA3aoLc71JlMHchliaI8clwONNEd/NE51lSjHSLFxxPPN6gNJ7SK1rQVcdakPt/mhxBLkO+9zh623JrxoFh9G2X84ynuFm0oCVUpf50u6H1cjUOWGAnJiujRiaEADS1r1NLFIXROxwJeyUJdbdcoVunhUDpMaDp2w9uQgfpUJJ9UEI/pp0+GYYseV08HZx8c5OUXNJIAxSHZbi/RdONYUGd7eMLHy8ZuXD3rvZ6gEk5rdWOdqBwWi2EeojlVOANzoLIDwozQwdmVs4DInC7dARc8RUr45saI418eEqWtcUuHHVVOlCV8/aRAcYBUanUQB9QUKKmyP2j+5fe/YHZOLOM2D27N9O3LxXIP1Lbt3FeAW9TRTT5bJCs+QJ1yEa4lznHnucfmTQB3O7bR5FwCqqSeLh9tOm2mVPpmc4ghsIUgi3wvRZER2rkm31c2+ApTOUt0GwCrxCkU3s4OVLj72rN9OpDeBQWK0xuZmNb7mA0CBzjkD0hAJ3EWaWg35mhKZ2T5c7WtE6v2EAA7Q1tghqY4Pu2Q33+bJGL/ls2I8+3YGIApd/mGh9wJ8NKhzHxe3ZUPu+NiZnt4w5Fd6II07mgfXuumtObmRiCSPp3AoRfholh8aDyB3AAu8lOkaaWAH2UVJ9KChsHXVFVFsRQUENREB+ldF5gfbWM2wJJQABE5kfVtsnzoeoxNuJpqWohCEohWjBjFFzCMbmgRpRouR41iYKLMMNwKm53EckuCeNKSrihA1U8Td1gaUXtr/G30qlN00Pw+ofdQUgX18F0PiEp3x/gSB9wouGjit+eg1vwrRQU1NgqeJGhoNctjw04ADVbDhTXJxa1F0B43tpTTYIekCwHHw4aUzKlc2xFxq3fru2kbgaGJ7eCpLj6wg3K33FCdyUoJcUajgCjgUCIEv48adkcwAU/EQCQCliOFFqobm7SjgpPNNKOJdrmta8EOFlTgAikUBM0nGBB02lpA1U6kGgX5ZuAduzaS0DaT8CLWuaDsYBu4I1oQKUu0qiKutZMN/S5WA2w0sHAtRa9yyYCAjAAga4ruIAamiWHyqfKyuBLGu0COP1FQNKycYZW9rHD6SUul93NSlSNyUS4dGToAqbVKCkgCqCAhA2oqgpoB8aB7qXuLq7pJI4cKTu2vp+FfwDdqbcaJOQvFpLlW9tTW8myBqqfmh4f00PT2BSxIsQiuVDutTibqi3seWnUbUNrSRwBSyrYFFN9KRDYcrLdOOoodKAbiF6ksFJVGA2pwB/u11OpKgKmqUIo2ktK95wsuvSmpua2am5+I5876caABIdouh03HjUuBhe35Ga+I+ryRBjOyiCpJMj2h4Yi8SKDXboG5KlJlcfVIUDVIWmRxzfqscEk3OUTxW6EKPkK7sTe9E5qF2QACpG3cNdqLUPcEpibjflKrSXE7deVdt8xyJIhdESwFrICEKeNTySeng7gDW45P6nGsACoKEO15Vix9vGiGKmF2oMcA5a8c3aASqi9CAJEfTuJARwKHq1428SKcXRhPyRJqgVUABsSeNSylQGdgNkuAjgoRSrlsiKOJpvcjMfcTtzAqQBYIQgUuFYHulpZsDLc+RyJlDp27QUugOnKmezYXtuTDaF2f7hO4D1bQ0qTsRCR8KbkZkglkmg9fgRbhkDtflbZ+ZU1LFEEYnqJFUKpVEK3B4VGGAxmPvB8K26lXaeFSNbLFA+MeZFMvGyhFumtRCeQjFmPaM46jbiAhdamdmQNMMJgjlVTlLb1ZsoTTnUYlHRAFQ5FtSSYyboaa43jMWjCqaWRdK7b+65qfSE1IUDU2pW2BF5ND4IPhSeWS3yWPeToD/SPlUTHfikIuh9OGrtRCpB0+ddBA3285IxuspsOPD41EXrEG6x69z/ANEnw1rc6PuQlx+vjGQlhZG7jTjIu38Ahup5EcT48KtBHAzujI2tJkO4Ao5AVJ8KcWtAJKuAKSdyQIsDtQEpzGyRjtkiXeEtKQCBcIbpaow3c04/bnX82M7tTwKX04U573K4De1mhuLKFGvzr6u2xV3vsi24JxWg7pVjQgePzg4nRPqK0XREDtASRQvTaVPFw0aKfj4+MN8m0yuef8MQ3qEK/wA1GbMnjBli7skDy4F2AHeX2jooPCpwJBO7XHaCQO5ZBMui/wAaR4haXqXcEBuVGoFbgQ3tqfkNfjSOAQp3XFbxcVQcjbiajdjMCQPD4j9BI3KCpUWT50Xyve4vKxX29qWwJRQdp+ymSTPQA7i8KQNfGyipMhkYapMZ7nmRoqcvqRae+fGx4nEbA9qmTb9JLUCNdyqIvyTF6c+QCpBLrXQqHFads+tv92xAACRwKArUT3Sktf3js6l1UKCfqBpmMezGkvSAFW3cVxC8q78z9+R3yI4kOioLELuvoad0kvXsxbQqAqUNlHKpoCqCDJyI8afqCt1C8Ryp0bRkRPkx1jLDuibqhJFztPjWLj5QhkmZuEroF/VbNHX1So8fH8ySOcmaWYgXuPT6oorLkgkKtLhFI1QEJOpFixvHhUkccRidJ2HSysT05LVJ4r0haZMyKSRksIMsjkB7ZKWa7iDUglHeWdMaSMAEtLURQpH9VeWIMYixAyeBIPDiVNSxxyvEd4Ip9VJHUzbcf03r2/8AcftIGLn+xenm9umlDckd0hHeuGQNqFbAg61P7p7xkes90949wyMnMGSTBhuKINuJBYX+lEHECu7N5b/pfHovg1EsOHOu4Jmy93sDIaU9SgGgSwCfCoe61dhaMOLcAAS4BXDig58alim9RsLfJyMWBsHVtBIettnCoJiP0+5wbjgKpK3JC3HLSvOHaLN35BtnD4DTaEqKWVYRwyFuSdNR8BWMJx+pdA700IAIIKocsgAAFbU7cexvNscbkULYBoQhRaooInRz4+OW+oGQ0koqnRbbRpUeF7KVMyHIG1EKBb32ppUHueBfHyFiJc4Kcgn9ULuJS3wrHg29/HAEMUOKjdoBO43W1jc8adAT6Vvqe7jktacn3DCmsCVsreHwr2X9ne4fuB/s3tnuWT6TJz87c8e2g4xd/mIaSjA5o2gAga1lYGFBiPHsjz7ccvGjGX/mLMIkD3U8LrwWsjPxXZM+Dub0jDVdxUF20Ha133VMcgg4xy9wggCEANRHqB/CvUzuBX6WkAhRwR2pWsaGDFAyiSQUsAb3d9CpeknU7uDVFiost7pX/wB0e9g4+D7aScTHUFxIV7S9SAVSvcX98iAgCBXF6AuLi0BU2hL2rcoW41AHA2P8daP6jdxNlAJ/slC5K3m5B+lAAoui3olG6C9+Dhqg0r6P400goVS/wV1gDa1N+LvvAT7aPz/opvxiP3UfUAICVDSgCHiBwBQcUohvXqoIsNNALkNA419f2lyfG4F7UndHDQN+0DWxpuNsIcFQkgE2sqKqrTwriCqB7GldpJS9i+54aUZ8jGc8kuChrWXvtAPgE+NbTqigKgCAlOK3FOynWyVQKfkANy2tX6p100GhRynkSqivf/cfUndiYW0NcEFoyCNyJpy041PkS5PqmILbgHfWSdyk3av2VlY8KSYqguRFKBA1bIAq1kiBN5KqEUbgSbjQ30qQa9BW680XdwdU4cqINwsguFPGwFNB+lD1gEFEUNQW0FJbaHLtAJJIOq2JI51usd5JIQ6XAQcLVwDQnBul148qJBNiEFhrqNtjoKCX03NIJGnMG+v21tcJE1VxcjUUleIqxTqAJU30/Eb605ZwtjqLaK5Vrvg8USyFR4m/9BruGwBJBuQq8l8alBwhlZmS6DtZ4H+AGOdA2wO5fnUGDEuNL7hm+34jnFG9OdmMxC5TZpa1yi4Sv23/ANu/YfZPYI/c87Dmn/cvvk2Dg53vH7k9yfj99492y8lu6OJpeocCAgCV+9/ZvY8jFyfbvaf3R77h4RhMezFfjZjx+i9MdpDVI4hKyHOkxxNECe+WoSEU9Juo/jXcPqcj1IQoSELSqgJotGb00+XIwkZExP6Vtg0BDpQ9VEY4vUj1XZHV6XwKaCpIoYMYwklO9fJIv6UG5sn20JZljlb9IsLkJqnBNaiZLLzIm1FiOBsFqKaWRIpyk/Y06guIgGm661HjCWZ7scGOKNN3pcXIS2IU6rjxIrtSRgNjWeIX/wASqk/E6nhXciSVsnn+aUTidUIP8aL2TB7TB1BUiHMi5Fvtou7Rlnk/EL4yAlE8B4JXce6YRyyhZCRkeoFrAIoHCi6DHIbx7wWyWKgAJ4UT24T3OxCTrwV3AlRUDyVYoyGE6txQeokcEN141juURHIGRJiQBP1GLc+qHFgUaWrvGKaUp2yGWA8SCdAlPfHHYw9psi/USLqL7akVnblVd+uiIOaEKBUrWRmUCAzds3MbbqQRqRr8Kigx2gOEG5jrAoVMxW2n201ol7vbAmc5l5Vs0WBvY6U9zoZnloM3bQ7u39RvfU13XXb+NhAUDhuXU3uabuIcy2wcuGvAtrsYbJZph33ZGRkCNhiH8oA4DSu87IducwBmOTwZe97X+2hj47S1pf3EjFwo8Aut+FOKFzolXeCgIu0qqOH9Nbkc5ZkJjTpdxO3SyUDlRIXkxBH+YgJIQkEKtFz97z+RuQoSFKFUUc6hhxWJK1pGRu6+09fzvbSUsQLqqXotlj7rXWb1EsJaOkL8K3zgte47QI/M0FtCeFF+vmXuSQLEIVtYaVI5zPI3RyTOYbxGIqDdNTqayz7bgzywQx93Iy0MsUTAdCnBK9NO0GYnZG5hCHf8Ba6USV3t8kuVHdw+B/DW0LJs+q5HaUqo1CWovcwyA8yBsa0Lx5kUjQXOMAlECdfad1ahQA2jFGvZsY28RLqRbRwDaPZjmd3p7dsmZ4cLm4Uk+FQ+pj2NyVymPbL3GG5BD2/UxwPApXlbzk/RkSyokpH5XaXmqVO4MZIYkEzRP2kNhZDceA4Vt7ZSI7xLBGbu0vJwLSRW3KfNjCMkz5cKZBcdQBFqEGtB/fghMqqpBcQTaYDVHCp4MaVZ5ICDMf8Al6EN5EKdajWQ9g9MU8K9sAm5J5k05jSAzHJD5B5QylOgS7dfhTW+aIWusjr92UHuHXULZamhkYrmxCHyLFzFXdKqALxoO7CO3pj6uDSAl+BAqYSxkmNvqdXyCDcUciHQjhULogJWeoB2qTqpVAbm9GYRA6oOm9uLbFFCVY9amXsgK0EhBxQO5k3FRxyST47JJjjyF36nFZj5Q/U+4OBP68tcdOCVhezftWPPy3R4wd7x797s1mzL99x7nL9ixdvqsD2sROTtEm9RM/MLccGOaa4JsTbQga86jURGScEq1qtJNtyIoQ8zTHiET9+chAV2o03FiiLXdYoBDgIZncQU+Ov3VI+LGy5mwA/ri1MIKqhz3Da0hNDTosZ6y450N7KSdSiIfsqLKxIcabLxAZRhZST4LtzS16Y2QB1dX9Iowygw3OP3GhQC4lyBSu1SnwqGOQCYuyBA1zATigIgIF/w/YaxRFhOgdOf1GQg9YSBYtS5UaVM6NuH288+jnyHADbjCxAXX3O9QQRty9mPOFaCWk83bbAjbr/TT2z+5DH9sxsY5mOcUmc5+S4hcItXQE8ax/cGtMOR6dnZgyL+gUgo1wv0j7K9L77k/wCXY82LmDI/cOIBmOfntacvAwmk3G8oDyBqV+M7LxAzD/ToFUBwBUCxDwCU8alwE9Rj5A6nbhtBCNcjStwhrP8Ac/aXuym7i3Ixw25ALiLALYcayHPYfIQgAAlq2JKjgCOFHH9q9vzfcM53+F9txgS73OxLiECt2hSfAVL75+5MlozcZyQ+2qAjj+BwJXoFvFKn9swJBjwdSt3kgE9ICtKAIdK7gfJxJVXFVK6ra9Kq8DbUHgp41ZOlASo6TpfRbUQvI6g6JwGutDsgp8Tp4j5UHBbDqNkvcEfI1xK+Pj8KJ1U80Fhoq20pTYry+oaaqedbSn8wN+I+mwPGrO6QUSx1KkA8yaBUCYEgkEJyIRBZKk76/khQHNAJPAIblKQtH1hxKHgAVTS2ic6d2Fuh+oggO6XFFNyn2V+qyiH7DtYToF0W43AU1T0oVFiHNuu1ASvxpWoCh1IXpvoig04izlGxOpCeaBFIFbuSfhI27gbBENzWTjI3Hyc1ryDqXDaWqL8VU1ks9Rro7QhCSQq30rILkDLLoDrqAbpasjHZu6XWKeKqNFSsoQaEHReooi8rrTxx7R/gdeRKUjbg6cNq8rKSCPhQA16ip4pe6HQrwoJqEDQq3GtG/wCcUvwCFTZSL0u7c3iLr/CyVuCgKdSAik6X8ayTk5BSA+RACR69ydalekDmtJ3v020ILKNt0Q3QGvJ6SDpc7hzA00NHuShVHEjanxHKlDV/n3LfxPjalIkuSEVGIuihASDepgT55DUyFUggtcxb2LSBTf2X7N73g+2R/wCSN9my/wBxGL/3g4eKPTBn1Fq7UCgKlN9xy5p82Z5M884PScpzi4uJPF7iSV1qUzfm2NrALdWpqOfDSukmaL0qWt544A2Ohr3r3H9g/tnKy/Yf2j7fm+8e/e+TPjHteLjY5DCAXPb69wc64CkcrVkYGaCMjHWKdsFyQpV6NBBYt7KAKmlCGaL8UN9FQoSLgCoElEkxVfUANIPiCiFNFomKQSzYogDx0jJKOuwiw2glKBZKHSzem9REBqEBALQCLG1FsibFSOVoCt4oSqgAnSoxkACQghm0KPTFdxLit1+FBY4Q7cQNQ4OxjwBTXh416jfCnZIihJQJ+IpwtQI78XbhRkWPcFVCnxebfCpI2lDLZDcepuHAH8KN4UhiyIUhT4kHnzH8KikkBD4QGNlJaN0lktx/jUuRmwTwZE4SWKcDHy0eAUYL2nF+VSSyJFjIJe8cgBL2Y2+qjQa1G5QHW7oHEG9hZVF1FRFzyx5HfQIh8CBoR40WkhYpFlJIsCbBCgK/OvdMjKzsXDxfbZ+9HgAk+55RkHb8ma25oNz4V5SSRxKe6twChADrAknWvVNZ1f8AzqqLqgQU1gmSJHGMj8ScCgChT8q6otzgCfL436l+PHwp28FGt39oX4+N040bmQDomLLbI3jmUCEj7q/zj3js4GG4Bnt6ZTZH+4SC7QUUj6fDWsXK91Mft785ZIWnIb3PSINtr6rW3ubo1OoF7g3K8xRa1GSIHvjt2yFQG3hetv1RE9wg9XmrYQpoALlbVG53c3H6gttdQOBNA/RG2w8w8vywmg0pxW1+HEHwP204s3xd2VJJXKQLk7oRw/qpocCU17akiTRNqcvlTpwUa8HZD9Spe99VrN9u9ryMfHhyT6iR4iWVZyssKg6AC1B1wXkPfIVJDSVcSqbSop8Tn9P5AuqnWxQ/UBwpzY2bYykRewgndwJI512x+G0hH5a8gtjrT/b8XzYpSzILxCO6SxuwiGfiGg6aVtD0lkeNsgHTkuJUqbIeCUyXElfj5ONO3KxXQq1sUsXWVGhVLip83IlEmVM/v5QFhkSygNJaAmwAHhaopHsmbiyBcd5CH1MY18NDrY19DSJA+7Npa4om4XF707Bhix9krTH38gLlepVZARwCfI0IVMWU9UljKEowkqhK/A0e0fPZFj4ojBAJEepK/SpqPohkXudwAh6OAGvGxOooFphABMwjTkoROB8aCxdyKZGAXHHkEBNEbCxsU/ZmdrtyQpC66DWiMyNzZrg9o/4pqHpspCc6ibAcgkEHFiP5SkoryVO5eGlqf3fUKi5Jce0pIuh0c0rwWoWvfjtdAXFokH0sySSNxBv9lSY8hx43bu86cJdE7IJXilSdoDG2jzjq46hwtwJ+V6iiO4yBO3qD4kDkldyIdp0rSIjNZPToD/aG4/BaiWVqxwjvcyFVbORxKJzpk8cvaEnkmLbdQb6+C/OlgvixAd2ZD6ppXgAVS/2Vtjm2yMKw7nX7GriQbK1brep/aY/cMiH2vLmxcrNxHZLezmZKEDRHN10BSl7/AHpml0XSL55BUNFukCwWp4gBDIFGlwFIAsu62lGLvHz7kOJ0b9Sg6FRUUpHqMWLJUCAmzuJArEY5W+nDiebQAC14RNU+yjFM7InaMb1Gg/xWrEAFza3GpjHPlQZEQZlWIU7QFw1NhbWvb/3NPiYftXt3vrfUewSSua9vvOM+bs5npJQ4lhwnN/EB4UZBm4keM/H7Ix3Zd8fKaC1QTqxwHjUGPmTYuRMXAI1hABAF0ba450DH7iCXBphhwQN58SvI6ipDBN3O8PcCpJ/mB8ASESsh02DjZViMaENKmxZ1BVUEqVqbMnGF7d7TkNcMsq0kA9ZJLeoOANrVixeyPLckgNxPcypzkIKkMagDWp9le55kc3p/cWTjKZKmz/NRitIJaXHZcFedftb2n92fuln7P/bPvHv/ALb7Z7z+7cjEfmR/tz27MyBFl+8ZGDjjv5rPbY3bnbVdtBr9wftX9n/v32z/ALit/bnvmT7XH+9/233/AP7b/d2A078X3z2puUxszIZmWcDo4V/r/Teusg/EW5KU1pCd1nELoigINLIKPIIqm6omhuFr/wDdn+Cm/wA61AIF3lSLafE20pToGkq7igHUmpt/Gi26HajURpTgCdFTxpwchsiqiakBRyNFFCDlwCJYKP4mkRoT+ka6cqG1FA1W5LjoQa9Tr0nr+HT9Oq0G/hZwCqSi6EqCQaKIACOiy7r8XXSicljWqN7ho3aNAD+EfxrfjK3aQ1pV1ifEBCb6Vl5AVxcQ1PxH5JtRaA1xsd36qwsoQuAC2HL51Dge35KY2HE5qg2JLtpcRckWpzgPVKWIOTnODW2BFi8hDzrIg99x4/bvcOhzfbMqQP8Ac9ueA9rg6Nzo9pjKjkDRm+pFIA+qzSPAuSsgGTzB1NWwuqkrrrWURaxcEVALDhprSzj4NDkPBF5Wr9PG5zQ7dtYHPcWhSW7Wje4+CVj96I4xyR6rGO4ORGoQ4DgVvQRqu1VAVUXIC6X+FLLqLO2uCFPgUG0GhruCjRyAa/Em2leSAQ06AdFhq0G9A+oLboVVCqWRCluNKUul7E/eaRnUTwQEIbqluJpiKXGx+9V4LfnQjttDepbqpv8AC1TgIQnAqbcvlQ7s1vEWJB+kJcVM2K0Lk8kFU2jUHTS9R3BlJScAKuLYi4UKD800qfuL3YEONNC5MYZKABR/ZHMJX7i/7d/sf/J2+1++f5hLNnztbkZOKPeY+37vGVRW5riUBXbwSsX2x0GAw42fnZP+dpu91c7KhdCfZ83JK/8AtznOJHI8aljjAiJgLpX3KFdL26Vt4U5z/OdKF7ykY2QbIXOUEG/KxFStbIYnDdxS5IUDip+dQRxnJmkgaBFFA0vcUsQGgFxdfXlTvb+0MeeKLGnmjmyMczn1EBcoIJBKhdajjuRLCR6gY42lCgCBU+lF4rUMrA2NAZZDOpshHiAHEqKgBA9NLfutKH4AaoflRigAjaJu9vKtsgUEnVflT3bTJ2+ppTjoFTVpoBkfakBabXCkEOX+Y7f41FL7k2JmNFLjHszTkqRr0/63rDMU0M2VlZBx8cxKcjFxggDMkfK3hWQoMcUIcO25SxxZbdCmjlKD7ax3jzTEm2IWXkqfiC8ac58SO7PmQkk9S3AdodycKe5+8sIcsaH9KBbUIXUEae2PyeKjRpK6g+NSTMBfGGeYikjml0UeFRxONvzHRKuo5eFQNx2J3Rs7epOvVqgtc03FycrsK/a+cA/l3sCAin7aLSVLkYwqSMpHHhwIpCjNws+MWPBDXpX5Ej8eCQdvHd3PTDxgClCov4+FNbnZE/uDoVih9R5gEZQdmDT6T86MTvORi2HmeZYWARQR91N2jyXdHXcquktlFqd5auuiaABSOKjbw8KhEyFzlcWbT8SqclqEhjGtahexFagt3j4AVubFIFl1jTsqEvqoFTySSlre4I5MchfVCS7TCf5QPsqT0LZAyAFzslS2MFPySSChSnRvSMfi383HQJz415J/vNm0keYoui8AL3op3GtcndBVV3XG3XU/CpY2OEk0o/vAQQl0h+xKijjiD5JCB2uPH7E/jUUcuRGZc7th0BJPaL9dFW1Y2GzH/WuxQBnzEygzJZnbJ6VcazcM48eMQ9zBEXduKPNUjcJlJG4J4Uj3Dc8pG8O2JLEqxJe68dDQELO0dwgLluguO8eVvsp4ytkK9lBF24sUCKIRkdoCxKfM0kjVhDHiB6lAVKk8wUtxrt+SRJkIywJFjx8EqRWvDYpdf74yizTqCnjyoTfVObOXiJNZQDp6chKllUmOPSUpclUjTW4HGoi3yj2Oy611CX0IKrrW4ETNQi1ipCA3BvemxQTFrYiTK7vqO9IqhCLm/wARTCD3JpgOqH6wYwp3cld9tdWSZR6hpINrNcCYwUCbgCPBaf6fDdj4mLKw4OAZBlS4MKAzs7oKzh5UhSUWpWHsq8BwlyFU+DRzUpensD4AYdbG21FuiXIrJk95kbD7f7e0T5zbr6WUOTaNS5QtuNSe2+0o9rQHsyIzunOMVIVLW+1Kj7kILyE7gHEWVLi9MjZGYoo5/MlDj4qlyTpx0pSwuii0KoVcLkIQT86aIw5itEEu38K6KSSpKD5VOc2EzxQ5IcGNdc8RyJKH4GjG0SdrIIIuqEXU8QBUEs0zf5eRaACFbwUgW502SNO1fvTErkk3PSpKotdyPqPqux5y6EEKqaGoECeoKqBqApGoRoH31PlvmHYmLcXKyUCoxUQWI2gcKyZseETteQ1uRoitDQRb+UKT4VNBNcbet2IhXLXQlUAIqTHynyO9tgzCMfEL3FvtqAj9AF6GOGrRzr1HfiQ7DFCGlu1AFDkQuLhpUr8OYsjnlDXxw7Tk46ADcQ4WRb+FYoizy10OMS4tXb1lXAIL2K/GjBHmyOcQIjkZUbdoK6NABAceBqad7XbICBlzGMO3DqB28Ap+NT4+Rld4ZTHo3YVaCf8A28OvYBaysH36fzoXZCtCE4zXBQQRcBwPCsvD7/rI45WHDx3NHbaCS27h1HVbHXWthB3BSiIbldP/AAbieYThf76hGgLlTVbDiLkAH5U5SLFCL20VDyNYnFC5xtrryKnatbnWvxS55kJqa1CIoAHO/ACmqn1hF/oo9N+S/wCzS9C2t7kJfW/GiXAlS4ANsLFE0Tj8aERaQ4EBrbkv4gLwAJqTLybk6ggoQp6QLIa+pm3cTyNrJogtwp2526AlGkm40QkmyJpToIQjR9VupEOqaC96GMC64Ftm4gjiLIfCpc4LjZGSVcWoNxLS4OI1JK/fWSdpfuc7cSbOO5ygDQBPvrvsPpghPiSFKlqooAt40nq3ZmZkDYc73FzpHMa3hueXvsiC9GThvLSV5Ap0oqIK7g2hqEG3P+qvLKKA5Qiak+C/OtNHcNfzAhtoEFYXuPs3uf8Al/umHluycH3DCjBGBmPY5jg5jwWvD2EgqONEvnJ7TnuIPUhlcXyJ4F7ia6lHzuNUOoGvjV3eCDl8hpX0poVUO1CqlyF519T/ALHfdRUtK6lAhREsg5VC5QDzSyHwO4Ia74AgEyG6KOaBNCmlAB1tpciWKnWvG4IBuRdQbpekZGnL+pE1FT9qcNMP9yERSARdBzrvSnLmhDXQT9lGpk6goSLCiFOPHIk3qDfwAJt8EHE1LFJE6RU70spIapX6eahK243qTl4580f4fGIuVBB6kB8alic+Yd87iSE24oPDQO/jQEYyJTICYSbEgJqb2t86haQd1yYvwgXslgDUT1ZqSUAWwsqKVA4cKZ757HmD2/3hm5mLmnGimijdlRmB/TlBzdzozysaxYsmXtnc6COUkukc4vLz1E7tpeeOi03DzN0ONCUmU3UBQAAbqlR48GJ24JQZt+0Sl1uJBI6j99dtDskGgUelKoEBP4hy4U1ezEwlD3iRNcIhJT4j40W5mQfyiBGHA24FVBVTR7cp3bmkFxbuB0W5IBAqTExociYPIkhiI5aeeialfuqT1EfbkiiC6uJlLry3W0Gi1LkPOO8RETP5THQlAPH7aHpWGVhBO+ygZOp+INqlimheIiI97lJuAEJTkK/VdUotHIRbLiCtuB/KOelIEQERh3HrIUBLKlMjZLO1mO+SXHiRUX85bdSa3prnFgAvuFl5OTVDT3ROlD3ReYwFFQ6N+Q+dO3jc3vBj08LjrSxppEBHbkDTyYFvOvApXlElhQBzVWRbnd/Lc1I6N5jfsXbdNvFU0X7aa6AP2l4e+JN5DrXuCbg0BJsFyNLFLi6jiaIDumY71KEP0+xCKs8u7b+ggDuhgvKQNbA0XOlG5p7a6kRSdUUu7/VK7Zl7gQobt4Cy6a0OwSJnRo9+4iNu9f5rKnFK3vlEpFgUtwuqaAjhRixn5Ihce7kN9SkWUVAB5hBW1u0hqSPlkPzPiCDz41BMI43QWe8TpJIm388bUCeHKi2GOMyRtHaexB3yLA8UseNFzwSRd7gU7Rbe+iEEfGsV0kcfndzzNumpsDqU403OYeuN2O6yEjg4qlrWrKyvQzZLsYsjhZ0tMskmhExW4TS5Sp873TNYZ5syWXIgaDuMbrwtQAKccFLVm+5uyIIsDAMUeQJP8UJcsHsvx4LCdCdeFT+aGsOyFxN910B8EPKhFINzY5fNeFdKACoRddx+wU+FrNkFyAg7iJchwIug8Kk3Hu7hkMaQF8sIGkIEVBzqMuDjGWI90n5o4NvoQtRAxpIxW94FViJKEDSjLtO5zu3JG0WyQbghuihOV1qLtwu2hXva4F0guToFQLzqIrsee84D+7+Wp3JUYifA8khlgjjNqi8R41FK2N3cR3eEbwbg6yKAp4hKEIiYXtyLIC6xCBypfXWhKJR6hpu8IPVBdFBQ7Ra/CoxkRdpzWHtmFclZELkJOtNjlkbiw+j7vngYw/NK3AHUKy4PZfc8jFVrYfVwZJxzlcUCOQ1uysnPycl8IDJZnE44C3UqXgkj5mnTOXuptKFQQlvE/dUMmbfCSc5MP/UbiSWHbcG/3VE42mERSLH09QvTYEAhzRqbVGrbzEdxpIKEEdV0NvDlTZYZyZQNs0hs1BYEcFtbitCYfqBLOh7JRytvdp+lU1tUuT6cSRHKRuOoVUS9wLCsjN9wzMqHIxfSiP2eDEE4zhOSMk+r3D0Njex0qGOKACIjyrgkYpVyOJ4rfmtYAZPl5Ek+GhELRaygEoosa9O+LI7eOGuQ3QkXULZpGqihDDF2Jym0YhVd9iLoCUueNZGFKMQNIaTBjE+qJJD3EvF1Wn5kBxm7Xt7+I4KjfpQ2KlwFStdFBGyUiWIQ64giTagOt+NB0WbHFkvBRrNw7sg4LYguA41OZwIpkDfTr+E6oUKrUMIdNlnWWMtDCAASCqgABdTXp4IpowTBJIIcncNrNAQPxIdOVB5zC0ECGM7QQrfpuVbuJ0rIblGSN7Qe3kEkTzbnmzi1Ft91StdPJI9oDFaug480FOfI9XH8d1ceRUEop/8AB/tI1+HiKiBI6RbTiAC0aHXxo/75/iKLSUQ3NluiJe5tSFSlyFuQqAjncGgjRZSFI11ud4stNHA2t/8Aqi/wruJo0nagLNACn8zUoQzkFpFmLuda93C4sbUZ0k9N4ltiBpqgKir3BcpKfy6JyamtDc0ODSLBNpQkgGxvT5l2uAaRGQL8AichSEbnm4aoIVfmhWt3S0EC4uCuh8KdkT7e3AHEnclyqOBJQlalxMcerGJK8obnZscAWpxB/hWQrbbiXNagOpQIOK60WhfpcE6iVUizloEldxBQhU5WsQhFA+pINzqgQ8DctokoF+lblfEAHSu/BjmeHqGwNeLoVN2gbPGsc7gNA8C6Io2i4VpI1qY9KBwPSEVDzHFTVuIHDgpubcKkRNRp8RXyd/AUNpTj1L9OqDxqExedYliEGxKhFS68KMhTUhdUIJUENuDUFwWpojlseI/pp008wTHQvJaXEEqgAaHFU4ALUPchMPqcb1GOJwR+lW+0KC438CKVAEKaW4/CyGuE9wpF2k30PHWp4mg94kWsbcQCCvH7KiiEBIgFgpCqBaxI0+NQmWAdvXsqHG5FyhJCGp2SefKSuOACLILOOhTdZb0JJYSYrwTxg9QKWPNPGoye+IFTtEoQCim2gA46U7CcOlkZEL5OC2I8CLcaJhAYP7zYSTINFG5UVKizQXMQdXEREgtJ4oDRmE6vLlDZD5b1Nl/tDmgpjXAywKwzhn+LdG1w9WcdfpOwEN8ahbgRS43s3dmGDPIf1zsZROyH3KW3n7nfmaJUuFBOmbKYygeJLHgCoQADXnQlmMPaAIYr/NHbSyEqv201rMoMbKQneeQREbhAupWpfUZe5loJYwShW4QqU1tT2MWMOEXmnz0Glox+NB8kqWTEeH5Q9R5UxtmNLRdw0BB0oOyJTvmiUy44OpO5yqoAbxXlXR1mNTLMgu1Rw43FF8cju24GcRDgDZUUuQGu2LyBJtzlIKpc2KfChJ3tDMHqbC6DaFLuNF0iNZFHcsPURKibWm63ot0EZ1XzdCUsRcnhW8xnakUZBKaJa4BJW9Mc5pjjkYSDrcpx5jhUrIpg1saZBdIChdZE0ulSmMrus9yERH+jQfbTmtHcAyL7jcgBLXtekG8Dd3ww/mxcw23Dxqd+LLu7giOm7U+cJRrdabtgY6FoKRArcqE4mmlBGHtG5xf0xt0uLgIRpUxM2wMf22l6d6Zz4yS0chau3L2Mctb0gEkkP11A+mmxtER6+yoDtwdqliqVKz8xjgROHKDEG/ii00NQMYCwtXtOtxAIVQAFHOoySBtJ2oESxVSTdCulTANglkmiHUCTuAvYHUj+inK58W49tGoBuHDUEEmui7kUsC8eIXhSvb0te4SlAAQioTpx+6hI2zUSObuNbJvS45pb7KDTGciSZhagBZ2gzUnm1OetJmMZDiwHu47YTN2y7QkA39U26cKDmRCT9NuWXonhDmqAQfxjWm5D2dxrPLxm9SlbSkqiEB3GulsZcSO06w+PSQhc2tsg+pQZShMbRY6KtvtWgGlx2wjZEhKhEIU3G5dOVb3O7XTfGhNoxwSwun205Q+Qhvl9KCIKCV/4aY2YyOEsYlxyNydpAoOqXoMx4pSGD1GRJdMQpYleIOhqR3fcXlGLjHeckxg2sp2XU1G+eHuMPltlDtJboQLgjhQSOCMRpttcEdRCEWJ+2pMmVEakxQFsd02jpF7ippciaaGecGMTNOz0cBUkJx3NKLTI3RmERjyV3H1cfc/DqQbrwo9v6u8GEoBHwKqLkIK7rp3mEZEgiOOm0IDvVXfSEo9vr/TntKekpdNxsCRxpki9zuw3hCgxJbTkt6GyURIG8HHxcd2itB40rnOieZRDDIQP1YtuI1sf40e5L2GFceLI1NgT6RAoBJqLvLIYkMYuAeVwEFhUigRsBs2A6O1U8Bp9tFoR0Qv3mkNGQRxN2oagZIT6nId5Diod08NSNU+Neb6cGXJUyhddthfW3Oy1DJIvanyL8dq2KJpWFhjO9PC0AqgGSSWH8QUglp+CUNhIE2MmRkgj1TdpsWhSXDb8r1FknGPt2LjMOVj+raQc0TNIJjJAJ+IUAUGY8uN2Zv8AldL0BKNBKOC0HTERBs7QxU/VFSgF1Jbzorhl72zmdsk6OIDj1OuQUK6XruNijZGuTtkeQPN+oaoQOSVFPJkYbgblrN27FCgnQdXyJrv4s5/W+Vs/EHMGo0G0ltR9gufv/Td4hO/7mRtA0ttHGnx+5YXaZEDF2yWl3eW70GoJ4jjWFkpJaV0TZJ75AG124qqJZPhWU2PpaHnRLuUAof8Awnw1stN1QFebiFBLgtkoiEAIRwQkhAUPilEhq3AS6tPiNPtoalxNweYUhXcANaVSV4cd+uv9NKDxAA1CWJ5Wrv5WTHij8XdQoSpbtGrd3H766GXcLEgniUdYoFJseRr0/qkcu7YqEAcwXAFBQZOWEfSwKWo42BKm7l/2VwaSdLJpoAPAX+NfVcBC3cFJF0vwWnZIV5DboQSvEhDfahFGL287XIXFQQFTS/4gKyh6klSNq3bxUEAqle5QOu/0jigKcSvDQrWQYNX7nD6bDe4AH4JQjKAncW893wIDuC1lSO3Lo0FQLhF05V6ktRCn1dKDQ6i5SsGPPJEE+UEuFUEdIB4HRKwpIMfDc44MiRqBuG11nWF3ix0r3uHAx3el9YHl+KNw9tcSQcAHR243+dFAUcujXIE0ColWgtroSbaiy3IoOOMeIJ2lQvE8UC0lug7TZBxHCtHPJCm/2c0FF8ULQIMbvdlUQQkCxJC9VzUvYAHfA74v0ggXapCALXsmB7rmeh9uzMk42dmdIQNaXKDdCoThevafcv2P7riZuV7HkQe8+35M+Hj+44p91ie5j8T33DyRtc0Neo8afl+4zmWZ2ZLlT+Q7F6s1zsx4wGoCG738kRBTlKlqlzNVVTclRvA+2mSlDH6n/D21ve11ulGPsmA3K3Oq30PA/GhJsJjaCIZQbFSpsq7gKdPG47MiTHPcK22oSUTcCUT4mp58DAysYSkDbkbp8kZKIHAEAhp1vapN8hkyzF+qcEIGMSCiIm6pQMnd3USLtL6nGCJe6IReiOOwDcjrOJAsPBaaShdHtDQGtPdcRoIjY60HlxCuX/01J0S4CLfkaLHMEXYZZAD3nKDEQeKEcNTQcXLKeoydyxKcD/ZW9QQvjhYxmG3HnSzvLJJle7nMKEuPPIPOHajIuoAVE10rFmmlx5crJmlPpNHxdpQ2adF27UrDmlXutPfk1MliUbMbtGNTXKII8tvlFhIhxAenqUqvLwotYOx2p79wXe8MCkSkj6j/ABqSWYmJ5GyND9XSF7xXp8L0zdDsIAijibkA7muC28FqNyFpJ7YNx02VrvD+qllxwhJEhAKNWxcLHjwvUMGNK12RNq03lcCtnFE41u9OJnIsxa1TFZdAQoXThTJHzrpH51u3uJEQCcCnjUHunu8sUGVnO/QYXeb3SF3gzoXHq1CpW4lomBZtDwG+YLNOpG0DSmb+vIkLX9t58pxxwBpGUSsx+VOGMjxu5Bj3jOfMSnZh6SbE1Ixoe3FIBjBd0lh1auovauw2DqfIN7VQ4wRbaa/01cSSl345P7tCF4XBWpWdss2icGVlmOI0AOpIrYe6xpXq+AUIdRemby//AJD2mwMpVCCnLWnTOeIrnawyEo/TUlRpTntfudHKDcrKYkFyuoCUGlrW9Ae17IgFVW/Pxqbc4EPjjDi092LtAWUpqKLDL3QFeC+x6CfEFUrzQZAzQX8L2QWB+6muEm0hwLbEODFsNNFN6c8Du7tY08vcvTMqahak78u0wFuqAiJbtPJCKnMM4aFyEVSEINgFAU2qD1Do5HkkRu7BI3JpZQttaZO6FWLkCaOSTtl0bfy+yCq870+bIj7rzI4AgiIHgCTpZNaax0kb3RtTvoeZIFgigVH5pJIPclS0xIv4BKiVo7eOi36SSS2wBJUrQeHGZiBGPKEdyxRQLfKmiGXvqSZMktMf5nIID5B+RruBqFj98pf9T2AotzYhaEStdC/6Xf3o04A6Cg4SxzpPfHJ+lIvzmjVPCkYqyxAvK9vvXK3B0PKkZ5W49hiFCGLdSBbT51CD35NgAh7J2guIKlCPpq8JlVRuN1JBUlFUWp8QJjbNEva1Kg6MUgFBUMbNpbjWnaVJfGdE4lqjW9AFuxColcB2h0qQCtjf7amEEU871IVx7QDyUIabLY1NI8wHtbZZWqm4nVB4JwoyD8pDBHHqPM424tWo4wO7LbZLOunJQRYAU+D1ExE3538qtugUWB51EABjhoJh75Di0NQEi/GmxxlEIn7hRNQAvAH+iu1JH5uUiE70AxtOQaq/Oi6XbHqPIBCKQQovd9GL9KY8jHtAp0UL/uuOnDWpUjSGEY2PL7luXH9vyZl9LhlFLb6miZZoDJC4HIhCbSVuW8Kgye/bvgwFG+qBKdJxEuVsqVBL3hgn0oDlK/nqLm5VRw0qVmWTkGLAA9xlBOK0MGgCKC4t0TVawY55sjJx/YMQ43ssGUWtGDhZJMxwztAMhG5bqaMebtmZL5MG0huUQTuaoaU28LcBWTJLd0YbNC111jAH0tIBsbVFJPI2IhxBmJ+kOF1aDt2tHM1iM7kUT5lgjkJPpipK5nEKOAqXGGXjeojcQwg/pNVe5CeJt8aEMsvam7/QHEaFeIKdS0zvSZELLujZtarnaG4KglxQHWpYfcRmSufiuEeOD1YPcUAOzCdT/TXtzo3mTbKIvTuK5OCAX3zFs8kDUcDWV/8AtBp4bhQHMgUFLtyoW30U3H/gBQ/AdPG1+QdWNmZ+NIvuGY/blApZrNw6UtYfCsf3/wBtjk9wwcnHDcoagICHIlgWkUD1DGO4Fx0F0TQFVpQHFRxUhChtoirWp++iPUnVyEjUg3CITcHQ04NJa13US5oOpUBoJUrTere9rmqgIAaBYaeNOHFq/SXD5rpY1ZXbgLE6qR/aqRhaRqSpQA8UQguKcVpxxRteDt2ohPhcEqnyrJC9W0EqUJb9RcFQFSL+NdRaRkhzSDbmF4lTXv0wCAF8bNeG4X8CPvqeYI1WOKEAoj3bSeNzTi7GdlZTmIoJHHQcACqg0Atg1v2qUAPFBxowY+L5W7dqEBB+NiTwFqxp8VBNjZoyipIREK+K7bVHjjHWc4ZB9c3qA2XJJIQHhWT6rHIGX1ZW1qAlbnb+JyjWkGASAqEkheINioVDRE8IxB/ZDgSOKIupNdmHJQnioGthc/HjWRLgjaLBC65IcoI/C632VPII1hLgXE9XiionSQaAV0LeN76XB+ZWmh7nOIVSjhdLBBySjwW6GxvqmiXF0vVhdQ5zkAKgqrhckKLE1Jm5GXPLluxxjukkaAjRYDa1oaTtCaaUBER2w7iBdwH1AKqEGvKNuku+424jWu3jZfkgEXap9UmikKBZOVKE71lh5Iq6WCU4ZMImiyP0+LOLpmL9JH0gJx0FQnByhiPOBPBm5VlGRjrZtruAs1L1OO2ZIpIAPUzouVjhFJQkBy/CmkqO6fJZCvAWVSUQCtpeQS0H8u+t+FgfupzI27ACzzedho7iU1pmPkPJeSGNF+NhcWvTm4wBexIy7XsiMXbEpS/jUZkc76CN2giMicBc6fGnDKkI3gyCcBInxgJIFttAApuyIOjb1RmLjHwKEgrW1kbZXEPDCPKL2jkeA/jU7SC3FngEUKkENKiyFShdTTNCXlu36z2U2xpusUQLamxNgmnaOsSkjS4TgSbfKgyRpadv5Ubu7CORUm+QtTsb5DWAFkkhJSRL/dwoOEpVhZtJARw+xUX5045qB1/TgDuYrpFUqB1JTcktLWTBQyBOI1aikEjWm4mPiF2ROI2GZ5RFaACLkC5pzJwyd8L3sWTQWULt1O776XImynHaLzySS9qKNFRVaHBfspvXE9TvhkHHigBGvC9SZm+NkQeT3sgiIGQ3dC3jeopWSElHBryAqfAoic6dCWh0j392Vx+kBBzI1IqEGMyNu4vKxloU/m8Tyo96ElyxmOJekxO4kg3IOlRyB6OcpiZ1EMMeq6HQ0oKbd+5qdy5PC19aa+PbKNkgUg6BHeCnmaZktg7bXSLEvHmLA8KRsTY3s0X/AJXFRpr862uudiuTXmFVCBQkAWB2oTw8pyakXqM+aQm8+MllCJpRDF2MV57p7bTGVB0stI53ca68fhxUlLC1MhighgeHI53W/wBWDzJXa4+FGM/zd9vbOvcCJMbcDx40WEp3BsRBkEFiop5XvV2hjYZAA1sYB4cjdTUjNt5ZO8HBFG1oVvIL4U4Pg8n6WtDiTt4oeFgpp2PL2u0XbYUudotuGhGi/GnjDeMnFMnYnmLQ1gIFyN/U24ra1rfUE2YVA1UG9tKue81/cmY8k+UoALQl7Faa2V+5oaoZIQChPkoEAIdT2gErbzAVSxSxK017WkcJQqfDp/3jQK9p7YxPK+O8ZHBvJCDwutIWdobCdusQ3uVADwosDwsZ7Jm9ODGD9XjdTrX1zGSMFUtEQbIOHG9RtY9nc18tLrbTj4+NMR8PcY5IVTthRxVVUi3jT5j9Y9RjzX7YEtiCLnchNS40nmZE2R3A1n4oU7rXAnRaix9g9PF5ksYKFQLAONyrjpzpqxwRuhPmgIZgMgWE3AoPvrfPLOZgoxImk3Q8LAfVotFrZSwZX50Jav5SFQ5OYulbpZDI6VfUx44K4pJVqkoUcQF1qFSWQiM+XYlCUa24sq6ilTqcQ5AhCWT6VQgV3kmPZ2iNhCFvwA1U/KnHIgn2FpuALKmnjTxD5hVe6LWIU+qOlzb41L225kWMFlyMK3pcpQQTmHUpqCNKimjjAiJ3Y4v6bKOOjtCS4XPzqaTIt2yXQlAvqiBZpGgAqGPKDlhaCUAJINyPiTTZineyS1YSnqWtUXB0VKLhjFYMiZfV5rjklQUJQpYG1jTZh3nyRJAW5EDQcYa6jkDbXWvUNZMZjsB2ktBiBHUApXTlREHpZcYTGCaIlwLtyELxcunOg2V4c6OcjdsJHt1kaPGmvtKJD3lcVdktflfqS4m7Da1YhZMZIpJXMZLPvIw3KjWgaFDb76yBPE4viAJdN1biy6jaqgWojsne6Fyte4t3BLO9SSARWBDjOPRCI0JNljcSTfqQ2rKcP5yLcmkbtB4f6Nvj/r9//gx2u+l08DX2SzpbqU5GvbnzJH2IoO1Mg3NXHBDEQlweSmlZns2Uz1UM+FuOGA0OwCFO5ulzrX7gwoAuPi+4+4Bm38SSODQXFU2gUqKCQNQpKIbHRta6jgeB1S/heusX6lO07l29Scx/RRAADtyNDeel78KakhDgFe8Jd27QgjqKU/ZuLSQXNO1WEX3BbEOPjS7bkjpvomqaa0BdQ4dB1CjmoctMf/C4BIQgqNT8KPp2Jkgkk6XJ6gLr8qBe5nqlP9pCSluNqlyGu/xRBIU6OCqTbqU1kFVJa9APxISiXQIaOwkXKn+0RcFSoRvyowQKjQAwJf6iToo3ONeoycVrl/LYC8tAUXc4J1IavitJGiLtI1cN1ioS3OjDiKhCknjpYnQ2ooULNxRCSbaKSTdb0oB1KgFBrdRdLU1Zyj7AH6rniv0mof2v+3vZ8n3j37KGW6GDHe1jRi4LHPJJJF9rSeK07DPuK5GOUyvb5it2FC3d+IA8edTYmfi+nkUbdrWku1BJOpBJ+ysmTEwWmLI3A2KBCbgHRBfwoQ9SqCCL6adQF9gBr/MMPCyJvbYsr0/r9w7Hq7AqBcAKi6Vkx5R85gOPNCdC7cOpuiBBToyDCEHmkAgzooYiEonglFIQrepD1A3UkaqEWhJEmPizgCXu6Ai1ggIaDUmXmZOVkfuiD3XsQYmCvosnGuN1ioIaRcigI4jAZbjbkm6G7coi4TQDnQh7CGC8kDdRezmkHQH513XHIMkgAEUB1yEAVAUaaJ3ARxD8v8K6FSnHillreOhr4tx7ciC5s3RQD91PbGHOdI3RgBRSv1apTMYP3MMihdD3AqKq6NrsKQ1j1YhOreBNuI8afM5WunJAbzAKkoSSpSmfQ1v1tc4Du9EaRqB/RUGNK3ZC8M3uP1CO6N1Xa9ftprZlBZBkBm1+3tjVve22IB08KD2xtOV2ox3Yz0jqIM6FQUAqUCOJ0kOQzqiJC6EuI5arbnTXZWeS71Hp4tymHJidYAkjpT7amByNyntxRxu2xoi/mWQqPGvUMmYo/MjAWMJay8QRXmSKJ9N0bQ37AiIEShufCGtaDLEA9xIOhCkAELwtTiAX92Yp/wCnEBYjQtdbxrDJ7qPiPWtockHo1HEUC+LY7cP1CuLtqgEcbcqa/ddxUtP5l7A8kKBRRfsR8yrqQU11FlHPnRa2Pss3h8W/ml08DypzS4Sxud3XR+FgUGnGpGCMFvcD9oPb+YCmwqNbLkDuFeCLrY7SlF8kiSGQiPj031OiIBrRcADFYownuNmX+0ttfCkY1kYJVokQyAgbXaG3jUcMcYmkDvLYzXzE1JHUtY8vuEJigORuNkKAAiJzbIo52NY+P7V7V6HBhjYPT+UJfVBwD8gqtii+FSnvo6Mdwk3J8xR4uaa2dTZiC92TqD3GKVBuL2rc7vAjH29+NNvDbYg2owmJO7GH73oAAOVkBPFKgjSJHt3OjJNmG1zrZKa508iyOKRBSCSUiUnRASfGpWyFHgb42zB5BcLcNAnhanY5j27XCRjyPNJKkjxC1uJ3B5K9tASGgqp1aStRgMkaB5w3oR6cf3nAG9FrF3lbuRjN6aKCoCUQIecP5923JJvpavUB++HHgDJmTRAntRkAqEBV321IxrAxkg7krAECW1a1AACKcza9HNQERhQkdnDSxWmdlmWdwSQ9zpU3uFJIJqFnpkmJk9Q+SQEuIAERgWxbe9OcZGEbOlwsO6dQEKOCmg3GMgeWdxz5wbZNwbBbcuFE+WQSN1twDUQ+Xp0mmub3HdhwdLjtR5ljugI8KkYX7hJ2ylgryNAPphKWWuyI5oGJvkit3RJH9RtYbvvrdM1BNKOzJGA6TGFyjiLKAtqax3SAS5mvdd8BbVKhHeg8mYziKDH0JRQdx1ICk3vU+S/ImhMmP2mlSpn/AIK7wqJkknZdJEdwnKnytEINi48+dSeUFB8ozIoA+Kh6J8a850JIJ3TWSyfTFqimkm2mJnRbIHFSgPIjlpSODtxACRH/AKQG24/iP3rTZIxMWy372RxI0CAlAPsp0bIlAQpjuVchbKeK+FeW4ggiGXsp6g3AIWwt/BabsmmPayljiSwQXBXUXPOu1L7eP8ybPk94DITHECm6/iav31DJES4dtDHppYBy6NK6VNKxcYwHtRMaoxW3BJUKG1kDvfQCPUNAVQjT4qDUOG+Z3ltbjyEpkHLuOq92hq3+FQsIe6YIk0ILifpK8rEfbUj5gJXyZJa9k18klC3eLcAacYrb1cZnAmdZFUkBbBK7xYNzoWo5xLXF/F+oUkDSu1GYA6XIPcI6fTmI/UluHzrdL3WwhwEbGA/ry+zsy/1IKViNjg+qSUl0WeSqAArot05UwSthkYYe72YQDukJJcRxKN00rDijk3iU+ZNG0PHp1RBiEEteNKzAR2Y4twZYTFzVudoKEoPklTxY5Jxvb8eNrNAXOewbnEAkqTzqSS4a55cLopJPI6J/4rEjQ2KXGn2Vjewe75743wvbiMfNlDRzejpciggJWV70JJMjIjLg2HHcIVLicQEOJ6kUKPnU7ppjvzczPzMqw2j1biUF9q3oJYt+kgDagRFF1N6+lFugJ4m32mhEMpy9V9XtBKNIA1F6CtcgaRZpIFtVsQXHWi5qGygEbWklQXbkGgqzSgRy3KkG1wtmg2r9SjnfhDksCpbpcBKDjt9SXNCJclEA3IEUca6Xlp6SjgNvHQr1W405F7/dbt1XtggqOCn+FdgODeoA2AO0lqgkjUkmsn2bFBLMOQgjcCQrSCSBohNZUPqvp3IpQkKpW63NZKKUAP1KEul+LiVXlWybIDIZA3c9yIqfSrkAA40c3cMT28Aekyrej909Jf6Qdzb8ayTt2wOBFjt6uQagQE1OCUACBdEGi8FAo5K2bxs2wsOF9KWT9KASfqB6rgW4rUnZaB6lpE+QfpACgDaV524rUXuXteRne35uKCIPccWR2JmbXNIIJjex3UHFeNGTInm75KuyiS9x7hJcXF5U7i776RVI0ddxIB/F4EGshY1lIdyPTt0A1dWXhyIWlZwCLHIgcQASihiDhwr3L2/2+bIx8b3SFsOZhQTkYrXQZAyCQAbEnwWh31yJAA0XugQBHXKD50JIgZJhjj1PZG4NREJNzp/CoZIpvKluHIF+z8OulGNe5JLk3kNv0yaIg+lKMj/Kb6gCbah/S8CCE51NImTLikBvdI3MJdcI4BDZ1bY3k7CoM/6dxBJs9VJN9dKlkaB3HREuU636goKkkU3fDMZHXii3ERdk8CQFXdwNHJf9EExa+MhR3AdoQa7R9lGddoYu17rGMcdrSEuKyt7t0bie0gWRSARcix3fdRezuNf29rWP0JPlolrr91CPM7jchrC6DJj/AC1bb8oB2i/GmuY1HsG8oiSyoplR2i/dQDou5PkFkZYSfK6kBSPWtzm48uLJC07oZnB/eTWfUgNOtenx4njtO72RK8MPnrcQ7AnpUNeqj7EbxON0xd2xKCAXDaDqA7iKgwsdrUbPuIufU93rUFEHglCX0+wG75JmqNykbbEkOK/ZQEQx4o936Zb9O3zlQ2HGhG6WOReJCglb7eIFCIhZHkRY7ksS4oNx5C4vUE7iiyOCIFC27N7EFKj2QG/aAh+ogNOhPACpmsZ3QXd2RpI/LNitvwpw5UDIdiIWXuti0ALrb40x80sn1I4kbpPM4dkoCfuFEQ9LY02mXIUCTiHEAgW5/ChGbvXeSLSBFB232gLUgK7XIx9ipNtttBWjg/eIOv8AvNDqbAD+iv1Ln6KI2bTEtgqgE9NK1BE/t9yH+ZLi4CjSnrfuhIwkfbaupIvcG/yrH90jiZ7j6P1AMcnld1fLXQq1pPLgtGXLZHiQ4kEGExnB0IVoM0wQZIU2rLEm0mbbHjHXth/JbgGka0RZGOPyo7A+mKdSDQ/ZRKK4xzHtcT0r9gKVEXwd1wHbcqgFWXI1BQ/wpsLYUDXh0bXkyTbuBb4E68qcHdiMQi5DT2yirwPApTY5HSBwCgbVu24QcUrvuEhEn5qExnTmlv6aY78x0X0kqNqEWLTqnPjTpJEIc4CTt+V5o8BYA1Mx3cB2WPc7rBxJSyleSCi4P/B3uscUA2nkaYHxndIzvslYbbrdMo1W4tTIcWJ5yJxM50MCySuljQFBxvwp2LlRiCWFO9DICDEP7VmuKgcTUXenIDvMhdFx53O0IgoOY3IGPMUimHElLEklEN08KcCwgx/kMB6S0p372Ra8sJM6UmN0QsYS5AoIIUqhqZ71YgaHEBeW3QeFPDSjZANQRpzPwpWNYVeSwOB3CUePAHlTi5sDiSksEixju8ALC4NF70iaxpbMWTm4TpuSpunxqODGZB7bDFDjifHgL3R5kkbO2MxZJR+qydac6SctvqgIt/zfgv2igsXecJzkRdo3uACdRuaNa/y3HxJ8nLzopMqAw48mbL5SHvQQNBc3al001qXF9wMLsyWBmQZsd5fj8JSF4Slb8QbVlz5OVjnCxSN8RCbZJdAp4+FNbgNhie6cqwt7oZqjiCEuBUkz5YY5N3WEUFDZOGvKhK53f7SOlOtigRTqD/RRe76A3+5sAl+ZRQNKOQ1Y4ZEBlgUWCo4aIa7sTAJAerD45ViRmqtwV14VE5CVA7MCgKSf/qgUcWgGu6ZcWGUDoYlzcAoltx++pdrO5E8H1DpukNQEAtt48K7gnHpcz1A4fq3e33C4o0QFPGsh0DCMTb5qKo3FpzCD4E8axMjaZImznHkztzgMzEmu3VDuARD4UQJcrHEOC3df9SGlu1qldE461E+TvTQx5AgE4cSpU8bkD+NNkjHdlabRgEAqCqEhFaDQ2xuiUuiijlnPC7gCgQlLUXGOSR+0wvbA0F4DeloYjXGTP+C2rCGRL2JZfb2pFOCTig22FpAfG5wHEKpprXvMzYla2Uk7MU7S79UD0oXfcUqPKEccRzFjcTYetVN2Hw0bdvI12MZqymbcDEVLSOG4aK43FZnu/vcEOHHhtynPkfkN3Pk2O2kAnaN5rLkb0nMzppyAi9t73dq+m3aB8v8AT1D56g/P/wAMc8LnxSRlWOuDuHJOF6ixczLysmHGeNmNuf2I0ajVJKBfnXeedV2rqWrwOqikLi7gg5nRRRIvchwNhpzKG9HJg3EANDg4tVhC9KgK8BKU6FDZA0poh0CmnAY/4rvBAIcVRBwHwokEuBHJQVJHC6in7Y2FTtO7c76uBBUp/VV3BRrqg5AHw0oWd1Je6WtY/Kso8NjiSo67LaxH0jhXuGQSe/llogBKDkrbKqi617jlTTBsl1W4bqHNcSbu+NT6ODSUQg6uct+ZFeghak5BaF1Gt7oBYVAfTHKBJCIQ5SR1KhC/HlXoDkyI3qbuXaCdUFwp+ynQ2FlCKu4DW4siffQDGoQFUmzkBKrW3IUgW1IQWARLaCvIKhOKLfnppT4RkjcpBseI5G1lF6xg3I9S5wIL+a8SLqbWrtwlTpwKamwJQpbwpwlXuHaGgi+t7Dmv216SabwAJQBxJ5KT4fChlRPLnBrwqAfSSgJQ2WkaS+VQciVLWWxaPsoSGyghbcDe/K1HMIAK8f0xysWxVoJuWrUGDjRYs8EWS6ePIBPqhu1cjdE+yoTkS91cjyZQLkrYOS2tlrJjDezKp/TE+oUuA4uKFSmmi0MaSVwjx29kRbVxMdbeBJKlKMizBPJHqAHrHx4oSRonCmer7k2IydJocYnuhW9IhmRCXO15UxBsLpiwQ97uemUq1SRd+1KIL9zRcaKdCQbprc1LrO82lJsTE1p6WonEeFOId09lz0f/ADBW8lKU15ezz7B4N+4HXS635eFO775HR9bmD8tJbm5P0tQU1/c8ohWuc06kXFr2JqKZkz2kuDXzoobxAJ0FzxqbHZkJkydDdo8s6+aZgLqRW6YSq+Lszs6SjyVBRdL/AGVKzuQStlewQxJueO0fMDVKE7TUiS7GxThHuudyByA6MIX7akbNlwY7IIPUZDchWyZ392MOIgJ60KCo4U50KiKVv1ylSOTUTpvY86ZGxgJY87Zi0IEBW44j76bsHbY3td8feDEpW/31CZd0obN0FAojUoO0hQg8aIkmmeHaobkEKiC4KW503tjY7aOyiu74vckBAgW3OiZVlc4mRfzCBIAqRi9bS8rJ0CbUw6oVAVU/jTcfGggghbH+oeweolz5UvLMXt6T/VSZM8kEHpwCkfcO5E2khSAtKxOz2NriP0+4LZE1P8ax/bcaF8+UvQ2NT4orrKRxp2LlMZLPORvG5eyEB7KKQoRTUT1h/OL2D+7JIsGrypkjo3Y7g9G3uvJE+ylPQyKVzXSNkK+ba3NVvwoxOcHGN+reMJ1sttVWoj3ZywRenhdJDHEhcliURAAl6EgSbo7e0dCFLL2tRb505wb33P8A5FZKCoKm4sEvXT5LYmBuvlsmKbuKknj8aAHbc6MgKP8AlyFdNeNZEkflOiABiiu3q111Fb/miXCIuo8Kcu9rJZt0Z29J2/UA4gBa3mbu7FVD2vLFtBqXO041sBkRiTs28eS2II+elSlhVwcgi2cDcFUFgluC1LuMjXvu0HzCEF+nnUbdmx5P5rz0AIA4FvGs702DH7i/Nj2w5U2P1YEugOOQhU1JlZhYcmxdJL5hUqfPkGrSTagMlxGKT23Obj/kpcf2i1eNABTjRgZSliqi6AXvralx4RKcgd+Z5IenIoSEUrR2M7SNQJOoWTQjjrw4VK2K+QPxyQrC0IiBChIAtRJe9Tr3BdpMiFDY7SL/AArayMRSufvjYzIUdCbgoTpJ0+NHtPa2WJZHgkISOAOhNkqN08BMeVNve6F1sY8S7m1QDRMbe4279wg+q5Ci2pNqEfkCWUnuskucZtl1QOVtYohgyfX5GVPHmJs9DgMY8D26fDkYNHXMokqH3H2yfN9rzsLvRwe5wT7p8YTB0U5jkIQMyQ9D4GpPVyzP7OQ97IRdS4lxcXHQPJU0BBPeXzXbOtSddyHgo1qPLZkyzlnS6OMBb2cqhRYfCu1FEkQhaY32lMMgudSDuU02GV4jYCRHyVruN9KkkhWOYlO4P8KgIKI1Fc6kDzLCNpljhG30+6xRLIUXjQGPGRLEABkOI0/EATYLpSPkcIoj+Q49QPC2qBeVGSJuIJyQBKRM/HUbShKpYffTsQTKHAHI7t/1CDqwzxCnxp0cXZjAacckEhSb2cbNdzqQRTl8gt2ktl98dQ1TcBWL6/In9OfP7eOGZEwe0ns45bwTbyrbmyZTcbJewwC6ETvAyWu5I37Kjk9tyMc4rshu10BBRNs7cYkFC5bGgyZkDHOnMxic1AUG1HHHuVJUJXe9FLOGOWPuzDto43OIApCHnesbKjlmjmiyMfJ9tyI274cSaJwcze1CD1gKte5+6+6wg+9Zu2bL9yaA0Gd5/UZOwW+kWA4VL6mN0uOZhtljuNoCXRSXEijsIYyNJt0u31FzYekK/JENQMefR9szmSIEB2Q8oRuIQtO1Byp/7UhZEfXRsz/dS4q7EMUisiUOIabWGpWpsxwILnAgL0t1boSlwB/4tEFgqWAXgBypShK+KEcrGtDw3eFhfTxpAtyiLvHNpPOvywFCWTjwsUWhCiEf/NfTkdbrxpyfH5ABEH203HB9SqIC1NoJIO5TryoiFEAUpbY6xARuh5UqNRAN116TptFlXmKDnhASQ8tCodALKUNOGSXAuCnagRbhQn0oa2ptA4bC4uUahAWkuX767jQMTGxtoICG+rh1LuLRx4V7jO3L8nGbuPSCPiCRc/OsqL1f6b1tx8iiG6KBrXuk5O45RVAqhHEoqC5A4VkTz/pYSd1zZQ4lo+JP2U0+ptuClt1QoCgulqx+kZRKq1BoQoKAfhBHGvyBtJJ5ICeCKAi6VkEXnX6+CpdG/wCt6EBAG1EI0PErqTrwpv6YIpQFbHj8RdRQP1AuIKHa5U46KBW2Eja5dyBFBIahcK9v/bP7a/b+T79717gv+Xe2+1Yn68jDBBe03a1gAJcTbWpMf3fBnxczFPosrHNyH3+pepjwf4UlzKgUOUEJbkFCDhXfXzVLYwrtAVtw1NlrNWAHsRHdooS5X4Gpe4OxIcpYkIKhLAtuNvjzqKUy7pTuBgU8SQHJotRMHefHDCT2ZhYIF6RayBK2jDxDNmQjshQMVoBQtJNyU+a0Bke3ZGXJkACHHByIcYlup3BwO1rhbSg8xCKXvkRdgKoT6XEkgjbrUcXfC97cDAA7cl+w5VadPjUUnd2h83UIkd6O193Z0JHO1L2hiMEMPdii6lEdmnQkTzi9OZIyTu3miBO1BxVL7gOFRjf2S9d0khPbDgHXI4btKRmP29354BPaKOIHULhRRnadkXBvb3FwagKeO6t+PGQQVeHK0EpYAlGHxANqdjPa17S0MmcCqEsB7Sgmy+NRdmNuQMcdfcSKQDQWULYfNKlh7sjXTS96NgYI4ZLjp8AgPzqN0kImiiaQY+5s4IDrcNdy+2oms7JaWuAkBcDqrwoVTwvxoFxPqG9yZsegxv7sTA2JaoU1Mi5jXH6jcmQjziLFDy4VCYNsbYjqcju+dINOKBw486czfHGyVe6w3kKcz81qBodJ/eI3FZ5flIL2/wDOiLuH8z7K8lABpeog7uPYhC/llYwSFJWxTXjTZS50c13PvzuAYtCL6jSgw9qPraIRp8StgN39NbXPfFI0b44nqVjXUuFt3hTZGgNdArnPVFJGiBV1rqGwv7Zia7WaN3No8Kcxgke66bQLtJIOopsr+4UJGyRUX/0/hUeXHkGCaMGRszQDpfxU8q78kkuXNmSvlfIFB7r1BUIoRNajiaRJJEgOlmt1uBxqwETEUv7Z7nEam5FdQfKZOjtEFRpt80IAOK8a6MfYYodhcgCcg46CmNL8ftJ0xNAlxS4G5UqVOnxppLhC5gCNCYylRbd/rand9/ZYwjcRoSujdviRT3CbeJFISKQEzABCSqaajShPsEXQAyQs85wiRSSqgUsbGRPDFcBpJcn8WoI+VMc+INHc6GogQ/za2KpQPZiw8WX+7ZP3e1LcLC1VCoppzU8yNZ3uYDYabitiE4aVOpkfPLGjelYzCP7lpLdSDQc1eytrpoVMNroFqedhPV5guspBt5WlhUTnsBZsDPOYByN+VjrStjbC0GTzFQBTc6oiceFTMZ5mhn3920Sr5Mmh+FRvc7of+mFv8MoGoUgqKYGSsJiYIAo3H6ihtYggDWldER1KINwbEV1UgqFIsBWF7N7HiPkyh52SwmOINil1mUpuASvc/bco4uXlOPpw+AAyYLmAeQUKdQ/jR3SkFpFviE7PFSF1pkg2xujnsq3VA0gXuKeWiLcZRs3XG4nzAFKA125I3ysJn7gQ2jZeMrZL8qgxW95jpWTwhoTwQu4VMH+Y1s5Hav3gRe5QoAL8qL4QsDYT3+81fNLjpZCSPvqTvSqxnczNkw7YygLNgQa7eHiKLo4Dj7mCTs2MjoCAhlubEFeaCg3HkdJBFjocqNfSzGWP+2ODqEgl7pmgAlsGILDYABy5aU+GNhjcEuehdPzU1oMfFCC83ZCN2RxNroV1NRxRuTtXY/Ry2BUHmOeled35Id6ICBra6ItN7cixxdXaH4uKf8RrtdqCOXvGX1aOOVtyNMTbcEhNeVdqWPp/vJLgZJGpTQGsmTK9z/yZuHFuxZfT97I90yRf0mMEPoWkDlWQzflDHcBsxEDScoEHc5VJFr3pWiD1A8303Ugsn1G67eVepMnclk/wpC46OVx6lGq0v5T5HB0hjsOZAuQEPKm+1e7OkHtDyqHYSZnDt7t4O5AUNM/yjIjYz9PIJiA71GUl0GtlTgFqWb3Fy40pV4DDFxJBa0Jf4VFFitmZApjmlmae5E3mByvxulSQslLSQkUkIN2odd1rjnTvUunb3LnpUEjja1yKdllvWd/dMyi4uCHOPW23CpPcYZIs39z+7QZXZiI7uAyRv0STDp2bS4WSsnKyZ5ZJ8mV82VO5xPdk3ElFJQN4eFf63/8ACXvPM3H1WIHhwodsc/EXJT5Wrzyh1tZbBETQ246irNCXIXkqcr0OJUHn+EW+VM5Lf/5BRXeoXkdBxqD4xKnLqKFNErHgGWQ4gtIs1UNzZCQQdaxiMlxaUTpBQGxFyq2vzpZ17uWUJLelt7bNEKnhQHfcgUuRFUniVJJNJPkPHEEEai6LYaa0HEo0P2ne2Mt6V6Qy7gTrfjWVB7a0kEkLZn1dP+8VaTz0vXZyMo9/JwXORVLtzvkbaVk5BySQSdwJNtxQ7bag8b1j4Iyd99GkKQWleVwOZp3t+A4kPaQqoRbY5bXqBuR1Na5oQklAUCfUrhuotOidGv0kDTjaiA51rABnAol9DrQXp16gbAFVIJ++jqoCoigLu8F2lPjRyHDqYNyN1ANlAJRQv217f77i+/4PuXuWV6Pv+yo8+5t9a0klT0AjjWRjsQY+9ytJ02k9ILuRHDWvdv3T+7PZcf3E+4/t1uP7d7y2Jr3ewDByZMqT2oNeEB96DkJF761++f3x7N7KfZfbf3D7rFnYXtgDE9vxWNZikta3pDnELZUWj3Ha6cDt4KR4VMiF522cdADqiHT7qzy9cn6iVC22FSGmyJrWbLj2YGtRqqpLrn4kmo4/bo8qXOmgx/VCdo7eLmp5pgubIKiGE6aSX8RU3uQRqDqqCnRDvxSd6zXE+oBspKkoCD4UJJcgyg5G2PvFx/TaWBJup4VN5fmwEDd9LkdtK8rg6nhUUpn7omyQCce6K0ENsOkt5869vjGHkvOXkY+MIYmPe4q5GvzhECWtJNybAanWszB9xx2wyjqyEcJFBCtAdA5OkJpQy+1ufJEglIeB6kEgFrfBtOlBJIB3vCuGSDckBEBBPACuiIlbPsfyrlP4eKVG4sjjVw37UTaTdODbWqJuHiP9u9qxZHyMh6MqOPLEXm5KvU+eVsqAmjGWljzF3Ci8BqQEuTTZBAS423RnZD2gbSTAFVIFqIblbJZCr4B5sIBPVHYbtOIRDUMozIceMH08TkJuTxVbeNSNdKEiTHMmIAI3SJ3FPin8a9QwQxIAILru1JLt1/Go/UNnngUSTY0E+w5PcsfN4BbnRQKmmkONF1eV2Me4hiNgQNSAADURJhyGzs8oNSJySEK5wGp/jTs3ImEYM+RFj4rQTN+nGk0IRAVSllZY7UiTft8QbElaj3dAkPlP3qEQ3I4bUvTS2RjMZoPcnILsozg80J2n+FBmQ6J5KzeWvpzuNiSArTf7a2GJ4giCSv7kj+ympGpIoqdz4hsikjPhqioVB41C5oUAjzPy9tj5d1IT+NB2x4co8yWTiVueN6cHm5ae7Fe8pTtEKgU1vhaXR7dxUg5fqtOyl+kc6Ep8tsih0nEEcC38Kpw5UHh/5zRvdtQnmn9lNKMsc75i3y9u/wDta7Rf6QaxoMVpGS60YsAAFJLi+1mhb61DiGfGJy5WshyZMgxYCu+oToNwIRKOPiS96TGdJHICvoD+HyJEAun2U8yQGaVRZ6GLt8eICDnT37RJG8oCb4xsqyg3LRw8ac3tsglUv7rFJib/AMlL/VTfLikd6buP3kActFs77lp7u12iYg14ci9dwShsnhTo8ifvtYwROkaAm1SgboPCnMapAI7bQSgQFD99SmQBhILHIktgf+VollpUsn6YhO2bKbc2mmta3qLe4jIySQhsmgpHEluxLybO1xCEKdfGmtnMcrZXgPVS8hOkN0+kVshaH48XlrkIZRGEQTJqRW2L1PQDNKsIQABWqQUIoNmB8157gB1PHjxqQRbGgjtwzQk9CBT60EqhFvjTGvJiyWxRE9pTf+UagtKfZU3uPtmZD7XlT40mIMmLZJPwfKDEATj9Jt41NmGXIyJZj3MnIlLu7NLovmX040S2OZpAJOh1Kr1Haq0MLFY4/wDUzd0ghsZsT3bhaeJnWbu8kAGYyAEDgNRUDIpnHup5WkuMAu4kFNTdKbmNZJNj4gMcuV6Z+zv3BjnmVNQuop7hNtM0QdCJAWFNipOQOWlBm4gBok2tO8WCqI/5VF1qcRCBewMiFTuRzgCShChTwqR4MU0wgGPM6IERhqAkiTpV171JIYijO2YgbQiLkRx/orJLzMWDzdnc0VOd3aV1gumMJj3CJXx3KAkaiot7Y+PcjA7ZK3j6lVR8eNCXtt1A9MD2m34rwITjrT9+N2dq9uThkghHIFKEU0wFIo/72c8VuClyUFtUqMh/bPT23gqpCHcdv8ulSSynvRg9+QFWnHdw+0nhUDOyO1EVBt6gKFU8LKPlXcMXed5wP1emTIurlQjbx5Gpsjs7Joi3tWCEIllGgFMkc7c16vaxo8oOctwoCGuTtBtsgvbmq1E15UXcGjwRR8k51hzhPcPbcVzQ/wBvy4+/GYjIHENMq3JNjwqKHd/lPuXrGsw/a5HCKGMAIWnIBRea+FGf2tkDo5SY5s1wG4krua4EErex+FAsyjv/AEyDICIdfkFoetdv3gHthAEFhdqBEK072z2cxe+++Qt7bnRva72z27pVQ931ODjyN6yM/OzJMvLy3v7sp/JAcVHbaoAA4W/8KUGob6cF+H2VAPgUTWztt/Ba+pCpN1J48bi5NXL9QpU6XB+40UG4/TfgLCw52peZB+51LxrwVUr8XD+XUaG66Vux8lwOJ/1XgSbHlbmtfqPMY9qFyoLaOut1vQIXa1AOo/hCbilgQny1o+nyXgFWk7y620ryQEU9014GoLl1joFQ/TetuS7ztVcdyBwAC3IO4nU03Iym/pfaGuc4G5LiFCG4Idt51kYTwd8TU1UlpcbBip9PAcay2wAtxfbQCrgDdFJJ0dc1kluUTih7gDu4aWAtr4UjEG4/ApdSTyPyrGVUMjVW/wCIC50QVinUdRLRuUqSR1DS16lkcvADkLXBTq48K+hWArvWx4KAQt6dJOHNIH1AoUUuRCDomtqBDE2aEtXiluJHyoy94NhBPYRqk2J1KFpB0rvuxyVJIBBKEuP1LqutZDJ7ljkQhyE8AVtZU8Kz/fJPccbHhxsp2L7biFoLVxL5Ic4uFzwXjXuHtydWL7hmYh6btDSQFT8JItQP4iLizShQAAlRWfvPYjN1UgnkCTfUcKnijkbulyx3nKE2ooaP5TanNEe4hS5ziXEXuqqUC03Jw1hcxoEo0K2I7SAFVCk02SQjJycvz8jvq0gDQbkNg0/OpsqKbHMcpMFkXEBIVoUFSnHnTfTk9qUXdM5XY4W/qzxBItzWjiMkOPEYO+Jk28ktr1fbUvu/7V93f7NmSez5GDmvhYzKnzPa/cWux/dcI+qadrtrjfULascDdI2KDytzjORjOUu3ElbjmqUGIBi3MEgyCXYhAuoAAIP3U1JBNjod8kICkni1VUDdwrtTrp3wYAD6dpRQS0gkOFF7WuESt7TiVUamyprT+zO9249QMbgAmoQq3atK1++IAMlllYWEyuaoTtiyLbhUW6P9R+pglJUN2OB13FHLXezIoYpZiRCSPMAtwAGqU6Bhx3MiCxnandjBFk+lQTUoZjpI975JGlZeCXBUKBUrHidjmgzQ9waIvdBHiTyNWTGc8HuC/a0O13caFBUioYzkKAyQyzSgJlAEFoA/Dey8UqWUAgBdAFAKJEJbjxp7ntmleQSXEoUYNeAJPPjUAkduhJORCZgpNl1FRSRLsij86J7SbnXYuo+VDIix/UMdGQ9m4LE03jUXBcV+WlE9vsr9fY8uW1gSDYgLeppHTCN28EwDSUAFJRxJICJRRwjckkgjToAKcFU1DCAWvlBIssKcSiG55UTd3f8AK27Stv7rTXxp4aO4FEpYfOETgAt7KlMxkjfFdJLwkBnmqr9TUheTK3eSTHGiXTTVCPCmHbGm2Q7xr2m3TwC0Mx7Y2OJ2o+O/Pd0m4HwrgCB1cPgllU/ZW2N2SC5n4D/fWJQaJa6U6bIy95aY9uO2N5Evct3QQg8jjUj2Hyd+zd+YDHZTzQ8aKEuaZGslsoMYuoGlhw51O1s/acJlIlH6h0Omv8rj9gr9OBIDETufdCgUjUJQXzmA/wCHkP5Z17e83Uk055ft3jUS/TIiAaUHNmPqnxIy+q+JJQpr4UyNsY6xs1/vAdVNydVWnm/mO7IYSocHBXG6Iq60VRjo/wDDyBO6YoihhITd8yaD06DKBKyREishX+Yk/wAaD5du1q9nuRju6m5APED409BHNxSE9JKHgRqF0rIjxXpPEC57SSIu3qnBSlK2UMdsafKasdiCbOuqDjUmI/H8+U5PqMknu+pjlcsKxf3BbapW9z6SBCWype+75FtOlQwr0iVTrwJBVRfWnOJVxTuzutGE0CcNL0hIkKE9vcEMQ+nQoF1+BoTYWWfb5ZG9pwiJkBiP4TY2XlT2zvGRlBZInFxUPQoVuQAKfkiZsbRE8zGexUFGmI2Vu438K9u/bvtH7fxvYvb8bFDPfcnGLZcb3bPvGM2QAKXOJX41H7x7h7tj/wDuBy/b8LEw5hLn40mGV73vESpBjloslFuO8ZOJjhr0BaEii/EJQQoUUGNj7zheQxHZLtk4f7o1SmSRicxORjo7BGiypyaa7fnB6rvmMnY7Oobqm6oPOLjkjip+ngDcELoKdFJI89xAIox6caKimy2ve9B88R3R/wB053WkyAFTawqVnamJlXvJcY//ACRe3DhUW1xZ2iAiqjRc21FvhajNEO0027UB+9FQKKklkOyLvflE3W53cEAW6Wp/ck7vdIm0E993AqpsflRlkgORFCJxLAEINlUEKtvlXdMIMO2D9NtRACSpCI4oKMlmOfH3omqEEc5RLnX+FBrkUCwboRq74JTXuI3Pt1agamy8PvrJymSwsZiugZJG+RkcrjkPSIwQqO8hHmJwr8x3w46XT4cKDh3GuCbUUEfNQQ7jTJMH9wZ2QzaIhDmSuljfGNpDdqlps3U1AfcvaMH3IRFeuYB8g0Is1QVowY+Q/wBkgcAOx7fM4Ht7SOyXN2m4N6fLPNJI6VSXOLpHv3FT1O4lfural+HP/wAJ1smnx1o9sbndVzx0KhfGivO//lpXlAOFkC7QluWtq+pg+Klf/wAx5qKj1Tc0cTe33pX+vCtX/YytAPn8At7UU46oW6cFIo5WBkBz8m42EOuCQbAmx/jXecDlYx2gEgooUFNt9wNGHGJ9SiIhKbmkXAvZba19REoGrg1193Aj6kprbeqP0jckbuJ3KPqOoOlEb3T5ZcG7QpFyi2Xci8aycHGmPrXNc7IBkAIG3hq5CSBWRnN/V5OVlI5N3/taqpJJK7mfJaP7W9vAdlNcWZLt/WXPV7i8BSCCdDU8s3Nbkobq4eBTlW64XiQGuGqfZUO5CA9qobahCXKagF0c1vxQEBxClULSlO9P3Cv0hP8AiIGjR/Gup2hBQKq6IFuVOtPO2Qg3LTxAN1HBBemhhWcBdEAa0EC9uHKvzlcoPC225Fz9tHHJPaKqUNkXqB10NbHCyHaQCSAqDgoI4rXuXtns/uBhwZvzibfULuAa4ISTep5Z/PyMgj1Clxt9TnAlSiheZqGYuLiQQShT6QoJ42NuVHGYAXjDc5CVUkqV8QK96z/bsSTIxfa2wZnu+YWN9F7VHmyx4+Oxr/okkEkmgVwXwrIUFuxWPlG0ntbuso0EdRH31ke4R4vcCOCZI9NkjFyFPqAliClY8eT6QdoHsxtKltku4anbzp0ATtk7SmKDoVu5Na8uAd6ZQpRHBUVSE0rtyfhb5ahdxUcF6jaocjK9q9xgx8zG8r1GMQ3JHioCWvwp0ckRAQmM4/8A1GKAQikgBDqPCsbG7nd8gzpD5H6i4BIOoQ3NS48MS5OTM0vkv6QJb9IoJdu8Si1LEI5WnvksjUE21U8iRzSkkcohH+GI4zkISQiBR8kqZhl7bX/mNuSchujQvANFQQStijxfTgmZyFTYkO1upXwpvmeQVHnMBim2yq1C0goVBrJ7kjWBgQOkRYhoCAAoCGodYQjI2xs6onOUrMCQpNuFD05leJg7uSkjpDteoo0A1HvLdv1mdx81xapTHHO11tQPcMLASJJpASPFrjYI4HVKdCB9QBYyRq+TvHdudQdajiJ8qV5LTEdiDgEW9dko5oIjijBOgIOoCL86bAwPnJlDza+NCtxEhKlRekdCJBsDsbIgB7bYQm7dZHJofhTv3Tm5OLDhukHT3B3C6UHsi5NrcBxqVjjGZ7HGVPTlqnyJ9bnnUb+nbDkEbUVHcwQoAps0LQ2P+7m1Gh3Cwtai2xZHIT4RJonNDUbpZGK8ERSxINNfBUFRu7sYZs7e0A+WUvuQ3JPGiyRYAVtuSw6joEBcnE0xv0zglN45BE122Str27WOYu5ruqRURBoAK3TKS2zJNe0QpCcFLjTnSja6R4ZI5v5iNRBcGxNDZCXNa3trAXfmSjhyDuNSL+nTo2KQhA4BQQCdbJTnBuxuwNc3QCUWQaD9QOHCpG7fIkRha0bSCokVRfW1TufF2nscGb2N80D8PPlUE785ncyhJ6bAx9rpou0FlE8dz56a6VDvcWRPPmsCxzBVAJbqAg1qU7YDin8UmwJvGq8T/A1OGx+pkASZnb7iRPTbLAmhaB9lTljGPESQMfDcoOpLpetz5JQ4HZZN5aNQFsCtEt74e6/mFSDpw4trIa1UDxvXTeQLnwBoSu62ygjHl3pEZYjxvbSij2xuLY3N3Adsvau8DQqSEpuIyeFhd1j1AMYi4EBOJIsDU3qc17gQNz44QwxeKgKV/jTZ/eIMzMxRiSRwR4w7ZMhTsSzHqJavA1LPLhRxxugLjj45De6CUBBaFUUx8b37Y40nx8j80MsoCICRzqaLcQyV5I1ISxsSfCk/T47gZdsc5IjsUPmWRUouxo3HKB3Nx5Ze0B3Sh2/Ec9RU8z3QPdFNsliYe2oQEl3jf51EMh4LXDtRhkY7XNZf7V0PNKj7XY7cw7ZiBW/EdJKlay5WQzQ5EwMbopDrLdO1a4ven6YjooX+o7PS75hUK8qw2wtRyb1DVJHgnAgXp795Y4uPqJpDYyPUdqADiUGnKtk5coCkE9x5H8B01GxJxFARJEnS021hF7J99MkGP+Yehzxcjh5aHjx+ddzKi7jQrWPkJ6lI2xQ8ekUkBd5di9STY3BcCVQrQiSEvQr/AHCjkbrYU7ZKeMO1Ol3hz40bd2S/cd/9MNE6qllghyIlJWS/pvUnW3BW0IDJPDLK0OLbdeMDfTgT91Pxu3P3IkERKDH2t1IFjvS16lBj7LSe2e8qWCKNLlEA50JC1HgOa5jl+A6fgKMnEI0A6+FuSCidSpufjSAX8P6qHI/wFyfglWVSdbgXCniq1f6lH3E8Rwq1ioCcdF/jQTeiDX6uK3IRFrut4E7ukW4W5lfh/oPBNfvP9H+lSnK6XPgCeANBDsZe10uqkkKFU0if0ldbclq2qqvSSCQqItgEvQHPpB8fDX+NfU34q7l4PCV9ahCpS4Nk5o2rjk0fSqFSOBJU30oNCjnuBAGo1286Bv8AS8fY0/11i/5fkOEJ3LjELtU8SefKsfG95yTi54DXKGkaoEc0W2laORgaDaDkxkHaCFA6Cbhv3U5MaXJ4qSDYhF3AlQVo5HvGXhe1YpBCnaQhJBaSSUIHJL1lY/sjW5mcXKMxxLg5u06l5AQ/cK9x9x/eH7l9vEUe5Pa8A3c0OJc0tUuV3GsvG/ZH+X4p7bVyi0uLiVaiOO638a9yz8/3Nk8+VnKSu1EFgl2hU1onGUPBCj6STYFS5BTnXVASg0cf5tEG61YwaUKm2iOXXxQ+NYmqguBuVWwNiqNXwoafpiEC2G4BF0XWmr+AuJ2i5CkoD9JCUUx3HUlxIRyLdVsld5bC9tpUcABoEra37iLk621AWlyE2NUPsm1VLUN0C2rJ0UKdyBLj8JAR1blPUEu0kcVcgG0FedAGIqgAnsgGiEcFSgPTeTqpVbBb+FqywoMu0mIdQFukoQQEQU//ALaYPuLIP2jH+7D+8zgjExRlO99fijEMx9wa0ZMmH2r9gksBulEuLI3icuDnEAOJVU1UEu41NFPM5uNNCccx3lOSCeabhsF+FQB0kGzv42OJHYZtizomXlKpGwa8bVL6T3IzRxTTwb4GqDi2/WC30qfjTWdsTN7YMMeQ5FJTa9bFqm/zr2X3H9zYRnwsTOAy8cL6UEubZBcoOVexey/tzFxZPdI98ubPjyuUe2ENarSbAtQhRejFFG4IDOInZBOOAVBSyhyjRda3OlEbpGjH7yrko4KgPIJyqOOKSaGOCcQdtL5VvHQLoRT4o7kEpE5NRruJOtb5Iu08uA7oKFETbcXC2HxrJMsc+NNjflNlYnfIRSG3W2lSY0U8+PC6HvtjIQZLprBotZyu0qLDzAs0AMBikf2U1kvpx0o+mWUdg9C+dCpLTuU3t9oqGAO7Yx2uERki3yCWUXBJCbL/AAFGYtMLCe3FCbepIkKuiAUlXCj5Z7nkLK4gEeCAjgENL5vY/HFIki9xCWmyuBS3KgQzIiabB7Du9N06DVQePJa2ubI56dAXyi1lwST0gm3jeiHxgiRC8gJJFILtSy6caZmMBLpiivWSUxhSRCqC6UkCRhwvG6w6bIUsgJvWNhOyHz4sLARiNf8AphK8IhF9yE+NPkywY8qL6S8duPqXg2xRKfLAYo2Sr3F/L5kcdTTcfJZtftKOA/TZI1sRdpOnCnns95gLjI0EiOylECKDW14DjuUC4EYKkBoGiLTH7I4d7WjuyESeFxroaZA0dvzZASf726XJuW0soJbjsLGQ27plcQ/Uc/jR2yGN7T25YTYt0QbiLECvTgDQaDcSACTMf5SB8qjyGTdDoiriFWZNANa3NHeY6MiZ7tzZICtiNBrT5cdbR9vIe+Mkyj+ULxB1pWzxztf+WC4DtJoENz/XTXeX3Y3bDHaAa9R1V3T9tbYoZJ3l6u7Z7iBL/BKHcgYC/wDKe9Mcol7gqdvKg/ej5AICE1QIpKc6fDPtWRjtLASD4oOFNb0A7Olz+lbpowp9JqWRuyEvVpbp2+CgolFcfbELbf8Ama+coPzpzQchrI0kDx+Z3Hr+ULqASPkabsmBBUz6Ed7gi6Jxp0ShzIh5rY0N5SvSQgPibUNp7rtz0UlSnx4i1SzGcDIjbvk3gK0fhBI1AprX5MfndvfFGbThDcckIqZ/aBHRIHr3doZy5Ifsre5x7L0VsabtlkRdQt6LZHMu0qXKCWqqWVCB9tdt2rkKlhXtyHYO0hIBH9dT4qNlkjhIjeSXx9uRA0EiweOPGmTvdAZGpG4sKkIbInL7KmlbF3S6OLvwvUXunJUApkh7QcvS1TIFOqhB0pW93p3NBnkYVtlFvx+lLlKha/yYpMzISSYkmEoLt4jadOdMY2UZUTYO+8kgk7VBMp5nlrRHYn7UUV5WEICVKLwRdKZIHulMTw2Bv87lUAghVbzNRuncN5YZTtiVDIANq30B51H1WfKYhOB5qA2QLYFU0pzSXo36JHkpGoAC9SqSfnQDi/v4/aRn93cIXEiwNrVGXE4sQ75l7KaWKlVVfupkXn7VTetx3yqgp9PFKb23ksGj0UNyfpaoTiK7pmKggya9WXy/pSpe4RME70ouh2oQAAEW9AxxH1EkRngkcpQFAVGtvjUss2OmF6kHv6ZIIAdc6FXfdU/qBNJF6gmMlLqqaIoao8DTi+3ZUMIHU4r+Sovolb2Arqi6JZFPFaAXzE5BU4AqnGlRvz8fnVr6jiV5ogB4VxC/LUVoTe3O3/lWnUdCAbHhb41e6HgVv/HU0HTdwi56B1bx8dFouxoREwHqbc3XnxJpSNSTbRSANCvKlKqFKANRCeOmhNM+Lf8A9KnD4/cbfbT10sEv/Z+NjTeyEiP4bhQQLqUcq1u/vQNWoiFLa3tXhwPK910tXDTTQFFNvGvqQcLKNbrZabYNFy7cepPpHgad1aDhwPhbQmgNzPFVKJz6raV7f7V+7G5OXIS6MZPbY5DuRpJKEWJrH93yv3jLjZKMBTJQA2c5q3BOo0oe2+2e6RZMziCd2QXNKnadznOXqSsjbkQ4s4H0iBouAACAXCxI4VlY/sHuELSq7TGAFRAikip4cT32f9Q8us1qC1kS4ta1T5Lfdc8+oW1lcpNtXak3ThTYoTmZWZlERDFxLrrqQD9Oq0J8zGDp9q5MGe5ypxXQgroaQj52/FZeJIKWtSaRbmkp03sLIt1ruK09Q22Kjx5AtrF9umynbeoaAhQlwp0FY+Tj5H4R6oIFeSA1RrqaA3BDckk7QD9PwJo/WnDaiXVUK3AoAvvcaLyt4G1NS5JRpTXiQuhNOL8Yhroy07nWK2JO1EBWvTYYXpcgJKBVJ1XVKCtLmlQlnfW7W9yLrXae7e5zjtUIiAnjqgNqmEc+2WfGc7c1VACqqobVliKTcxrQJGpYlekN4olIh7n83HltTknhRDDtcx28ntqF4X5inNnlETZSksYIdKihCRwBN6kHqO6/vBsRNtQTYD7iiUGvl1VIEQ+QbhzkBIWp8mXFLwLBCiKgJAVAQaGRku70ZSDGCKRbch4AAffUEX5QkGSY1A9WEGm4lSCvgDUccIO8QQFveFylyCdQhqGSUNkjVJXA6kWAt9JLW0JMWL6ZwYsVdpGMgBQjUgj40ZZIQqd+O6bsax3E8xy1oRADIKAgT+UxR1A6izT8Fo/84wo9P/qAAPgAGj4UD7r7Ti+9wjAfjMEuRJHHh5z7Qe6ExkKYDwufCpJ8gwZcomiEsuOE9TKDqoQ7Q0eAtUZx4ZowjgHIG2uA5AU9W1bLYig6KT+4Cd1Vsu69ySV+ZrHgU9jIBEoyie97fIOonGDdXFeFkoiQGF6fmQk98/y8fqQLQBf0mG8aBUu3cCE1HGhDCe0s2OGOkPUL+bzNyfnS7miKyNW/EiQN5Eig1rJ9xaA4Ag2BNyhQDklMi2yvDY3lWSBwRxJsLBaLd2wvakcTxujJBUAnVV08aYcfHgeXDc52QRtiyY9ZeOnKu/JH3XMk6zGnZ7RsFHAE3CDWuzjQiNzbiQ6eOpRNtAQGaX6fLcQAoBJATVfCtY4pmN7pK9slP7naLGmNYHxuiMZJZ+X1nQyG7lOoSnRGYZbwzvzFjCIsUA/leNXjczaskReAe6QAbEqhNPaJF6jI7ef75St9QWim5UjBJG1/6iKM91HJbI7UiBV+NCV0UG8ntTbJBcbrAAIlF7ArYnl/aWwtc6obU78biQI5PyQTFo0BdpU28a7WTD6fJDwZ4XkeWrfMMxVATwShtZ2saLrQA9xVtZbhRUeQhklFy42G9dOSEfxqXKiw3EJ25WaDRAi22qPGt2RDDKI3dtnmO2xLdQD40R2Y5pALSC7A9PkDegH9LSQ6RzyAxOJaTpbTxoOB2wgiSJVCjjyOhX4UrZZjH9Ue/wAsElQPLRSF+6ocd+bBlZUZBnnwR3MENlQ9rukWIOtMEb90XB50OqkJYBKL4EZMUEnGIgDivGpFtYIApjDUsCBqaDmvV97xkABWruWxUj76i2qGujL298kuBKAWVSp4VkB0XcMUJAk08VbodPuqJ4DO27bvl3bsU9KJrusnKjs7gaB3EEoWMeA4tctEytG3vs2siCXKqSDe/OnNZHsepIeSOYG0LYAVtLA0IndbYff9RvcVK0AwgHuEjcY2xhSAo4uNSuDHbjBF3nEaiVAnJAK2yN9NCG9JQmQjXyRyPFaG9qtDztAJHlAFELbLzrI7R7sIDC+JrkKKUmBJunFKlgbI+TvJ2CAQe5/sOvhUuPLNBHBMkgDPzZTCgcAQEBQJW6TvbJbwbutO4AAoH8pFFpUltr2jlBJTWwQUyPYXo0SMeE84y6DihBqUyq1ziDt4mSJDr4r8K7m0xkPDXOjGqEAfMEoaEQZFviSdf+cLFSEIJXhUriAH6xA7Sida34rw4CmGb8vIt5CEjv2BC6BRf7q7crbxHvCQEjEsVC83FU+NRzRlvcJ6Y59EuNPEaVOvZikYLbtQtyWoAhtURlb3ez+fCV6htJIUkNVwt86zJI8EQRtzGnCjBOScbGsuKUIKuKnilOkYxIYgAXA/VkPt8doSiGWaH7EVEKqT8Aq05kRLuFgOtT1I4rYfKv8A1Au0XA8TyrjtBJ4G55odTREhKLrbpOpRFpX3sEPgCEcB8DSlg/s2CHwdpwo2VxIT4AcLUokO7T70rjuXXh8vFa8zlxv/AF1ccVBGo8LmviE+3l42ohEIAPHVdeQFBPxhD4cTf/U0n4Rcu1Op8KVbqQmp5aEKp0pBrx+f9NA+CqeYJsovaiQipfgqfwNJyINlPBLalAOHOkSyqCeVlseJopZdE+V/uruQOe14up3AoboSCNeHjRZD71mxtt0My8gBQp4ODCled7plPFv715Oqm5K6/fQdN7rlvcQAH95wIaAANHJR35cjtDdziqWBUkqaSfJPHi/lwCgLUBOQ9oQfiLvkqpc1ifujN9t/zzHjwzj+kGxMRwUu/MDmnf8AahrJ/dGB7Hiex/5pg4WB/leJs2gxtDN3S1oJRqnS9PLGgBSFcSTuXT4ffa1XVCeq9/E2tRMBuHHaHOsSD8ybGhlY4In/ALKgA/2UuiDlUPt+fM70oa0OJerSQVcu463qDJwvcMPJ9TtHpVGhbZpvy+8UBjg+nbc45vZvhch5JSkBIBIPZcAM8Jp4OA/hRDbHchVG2GhXQXCc6CrcFbJpcr8DTg4RlALotkJKEjVKAxicncSrndLQ0i7QD0qorJzMudBC78j6Wt1QhfwWqeGDJuBJ0ucEUKGoA63woyI4PdxUIVKk9QN70v4d2qrdUJXSvd5fevc34c8EcT/asWGOR4zZQ9Cp3Ak7DxqZmCUYCZHxzi6cFcF4aUQ0OO1oCWaXHaCG89Rav2/Kz9wYHuM/vPsZ90czAaRke2ZPqXA+2+4uyCduUGtXhrUTsiWcMlHmwIdblStlLhXd8+F+NfUIvAIU1ArvR9iaaW8QKAqp1W7VNdl/VNIO/JOHCBAPpHTdFag5k0TKO278XTY8LcVtXciiHqGlqXQFuqcE5fE1FhbTGMf1E8ilpJttPwOBqi3oOgPckN10GTACES1nVBkPm2y97zGgkDKICA+G3XhWL6efutiPqJelG5LiguE6toP2VE0TCFss22aVpJjSUA7ZRZQV5Wrecra6Ah00UC5DcsRS9hUF2q0p8Kk7SRxRj1MUStk9KyQACETpbdy5moi5vbeg7ndaCceSxKLz4VkR5kwlEMvexnyJHO/uFWtKKrYR/GiTL27/AE6kWK9lLr/GmhzIXdroikQGUi93DRV+ymtjbHHLAm6RRdfqUXsRTUdKwK+PdGQFMgUjVSPhQgMQ3ydUk5JAMP8AZtdBrUTmv8kX8shzjdLWGtPgZNucR0PkREsCvBFN6GHDKvqka3sDyQQQCulERSOzWwsEkiAh/wBIMqjiiV2rzA7p4HcRsJaO5xAHAUS4mJ0azBr1KkqvwH8RSdw79BDj2TRCb6A3qSTtRzbJvyZNZfi65uaJdIGn1BcGx/TCidAJ/DbSmPaj8oBLBqZY1DQgSwqaV6sl7n5bLKFUkgfTcCo5GM3KSyfegDi7kBpYVNAdzFlBkN7AnW1jYUYmTyTwCZYJZx2u5/eFYuQ4GndU8kWRGkr55PN8o2IJNygtfSgW9UVy8r3JO0dCAdDevPaOwwg9wAdrYLkAaElKgxCIooGd044gSKONgCDvTILkU8jttkgeha5yiUi2rbFw++im0MKWS1yQCR/L/GjBvLnIdykqhITtXRF0PBKxmQxdppBgyGTygtlljuO1xA8flTpZ3tc17nQt3n8oi+llFT4o2jHlV8YZGhmlQ2I5WqLeJvyQHNYB43NjpWQxYgyJJFG6UTbyLHm5pN+VSCzfKje1/wCIRWHEG1/jU7O4IHAdLr2BBQ2KpfX7aExdudGiyQk7i0pZBuVKU5BUNB7siglUVeI5cac9oeRkEH/9lKCbg6EKK7ZljcV3SCC4lsiFUsFpji0hvc6nGzx8NLKaa3qYPzACoRbA/BKle8nsY0g7Ykk82eUEjvQxIoZag0ZUrGvHTDK2/DTVQQaKqA953D1HwPAE1FvkyIR6gwN7ijclzfmulPxomTTOaN+zhjLw3DVaAZJDIOzvbDeJCwoYSAVCHwvW8yTSE/mRpsESp5TTqR41kCMN7caCKVxBuUCKSfhW9QG/TKywjW/acFut1NPkeN+5jGRWBYgUGYAEGpnbkijILWKsoY/cilVQ06WI7YIi1zr/AFulCITfT7q3sHZYIyJn/wDNKpolgVolry5xAbH8LG6qbUNN34mP+olQQYQEWwpxhJllAsHQFrXH+RoOjjpa6V7U3233Y+/S5Xt+P7rly40E2Hi+15JUZfsGVDOTuOCdJRrUre2kTiJ2AlAiki62QW+FDvSdyaRDFCSgJAHELZDUwmjQKL3CcPSFbjmpqOVl4ooSY5FALviATuAJRaiMv9ruqoEZOjtpuVVByoSNln7v+H7abhkqLH/hBrYWmPddxX6YhwKDiV11pzUuOXHilR2OhW2lgn20qG9/48eRpvHbrb6bDRdSCPuru6cUP9Xwrvp0iwUqVFtCdDW8lF0BCqlj8aHK/JPG54mvEWQIgufiv+kaXJsq8rcON66Su22mnjfWtOPA8jzTga5rzuv+ylB+4f1UbKv3eIooUvptOvjcXrV33/1/6LfeTrZP/G42UItuFkHzqFCVVQpQEELfmba0SCWvaNVIDT4H8RTlReWpuLTY2RCVtqVq7Xk6objw4cqcUKNK+BBuQOAQ0UUvJu5UsSpCotxR7OT+WqWtfULbiKxw3PaISnQS7pLCFIJKAWrH9v8AdZ2Y2aHIctsqG7RdCgCkJyNQT4U+F7gUKbHD15QBujXXcNau47fxesRHFFagapoifL9Kp4lqDU6kjQfbWU7M9w7rnK4AuaPpN9CoVErJx/bJMLFZHqN/U4FQeppUa/FamhjzMh8SjFhQuK4yq3Qqg5mpW5k30Eg23an6twW5ArHimyPTNkcsuVOEhjO1BfiTbwvUHppGu17t+gKToOK09rryhSLroLoQiEN4UGFzQIj1EcSqNbbma/cWR/26/bLpvZ/2p7fJ7h7/AO9e4yIExIH5z8X2cqBk5DcaMkoqaV7h7XkZUWY+DKkg70G30xdAQ17C4EneEIKcaDZYxJFFDARGATjqmpI1IHjao90bhitcB0qXKdCEUpuPjRZHFFAY3AkZAO7KyL7UGrSg+Fd3tdqbyO4IFRQ6yrwUXqV0nmBLuINjYnRQi+FCTeBEoHnlFJ0VxdZVsldsAv7W2CVpJCY56gDobrrpUIhkEb7JC4JikNVWlSFCWtxqWMxwtibKTsVNBw2lLa1lNycjHMsZdjCzhKQwlMpCBbQINahMy+o82SQldp7ZG0uH4Qa707EHaQSRAlCJLQkJpxU8KkYW9ACTYrAEJKkCIj6+BqGfbLI2eJ9pgDJqABt0NglO2CHhGYiSuighya+FA2je+4lKE8uOim1Dc305Ms3dF0T+6cEspShkCPubgYN5Dg4DQBQtkFN2k99vnMLuHAwka6VFf8Ijc6QHeFIsBxFNIie3VUUgy6FdvE1GfTBr9A1nQQCFUW4DnWF7vMGtwZo3jHZIe0ZY4ZWmcR3UEceNDIinY7JcwtY1hA7hIAa0pcpoamy5Yhtc6YvdH/czEfkzLw5HSmPZFM5zwjzr5PF19TaoZoFhnDhj32s3RW05mnB8gkmCTyaMPyGoUUCXERTyoI9qXA1J11pPMjkiIlgEZBIDF0C2CGu5J9Y+slqSnf4m2oNFkbXli90uJRORVABtpgJEvRtJ5k8TtQaVBuQkyvYwPvt4doKqKnzqEFwDbg7vwdtZALoQVXTWmdssMpkJaxUEspQBAE4H4U2DJewHcoUpEJUUQgWBJT7aV7kZLABofJI8BZG/bXqc2RkUm4dthVsf/wC2iW+4jWu/nZ/ocOMyKhEkpv3I0BJ3BfCy07JghL4h5DG7xogBFrkU1k0TS6Sfud3uuHki3pyLInOhuVrhMrAR3bKCFA1ahutQ5U8sckmQC9kTTpGCh48F8KG3yWNH4FkJHNRoSt6e1rgGxSB0Me1HPMniNdai9THLtWNnQC+XuEqB8NvGjHiYhggO9rHzr3lBTzUAQk0Sx+xsyBxCAiWMBb6BaZDPIbw7t7gDddbcQQicTTjj4jphjjuPnja4YoSyEgIpT7aeXMPUriy0ZcAUVWnQO4caMLm3sVAWJluNipX+FI6WRwikPmmzQR4G5vUryxeyP8QugkQgEFLLpyruMMZ7EJDD2iQQVV6W+3nUZeNzXxI1+vZlcD9SWKqNajMzGSztjPkyEdjuglLgngaR7YI2SgFp7p/OB6VdyaRxqb1UfnSwdyTIQgWuu0cCtREt7UBf2wwkLLENSoQqPsp+REzvME5eyWdGQykpEkENhkBVoNeY2xtXylJMSKQSL2voaMRkcgKEp22xxaBPiaRkrYyISHm7bHgPCtr2gDaqtIUNJ/vh4JapN07XiMJGl/JAAdbRLaVH2DImwFrwi8kK8SKi3Ah47EnVzQq0kIulSukycrKz3vbAzEyMf9E+PIjXKzDlC+DkYRtFwqGSWPyg0iSTiTcNLhYOLghJ41ICshkvIz8Ja4oV+RrbENj8U+VKhOMdyNS6klPvr2x+D78c/OyoJ8v3DEIb6jHdCV25ZChCCEHEVm+zY/svt0vvWVnw5EH7inLne6Y2Ou7I9o9GR6M4pbxBFTA4fcU5CuX/AAam6gpuBdoq1CztzmaHQIbGyu/86l7rCZZVMZuAhPEXtWwQtZIPLKvBBOpVeBNYnuE+JPDi5OJLkYeVMztRZ8MEz4JZsfXvCCVuxEvW0HkAQbbSCuqEAU1pVLc/kR8TR3aJ0/wI8ClFkakKvLTUJ4GiSCTy/gON0o87/bw+a1/ryP8ApaHDw8dfsW9doLtKELe5VNOF6P8Aw/xNaryXXUL8h/4NNf8AUgGyLR2u0Nwb21F7G9Dbb6gq62K89F/8Y+f8Kia9VAO0g3UBNx4DpN6xSdxUOcPA3VSUB0rUaXQc7m2hvyoBStypVbAHjxpQ7ml1+VuPzqxQ/A8PndUrQ24jcBonA+NBULT4KpQAE6rf+NeohyDjTAC7VUnRNqohqEwZwa4cUJWyODSTqWjQ0TPkNBUYpyTHtvclBrZSp51kdnIb6c23FrhzbuBcVCcEqY+uaVbxaSxFUhRoSz51kzSTLDqgULcIoutzRVyLYa2suvAUFQIelo4p9YBQqtbTdF5j5EEXKaBEWiLbFvwTSxTghtWqqArtt+PFCbaWqfH90JbE/HTCQomWSgLkuSPGs3/tp/2z9lxMf9w+8+3Z/t0nvULJHDFmzYXYWZ7uUcBeJ5AXQVPl5mQO96lzWk2a5+U92TO/w3Ocb31Sow0TFxcYXRTXDQTckAfZwvTu0sUMRI8ppQtCAuXR1xwoMxCZ8kDJnEmQQ0OjH8xcgsKUzkg/m9jda4Dgulk8aMgAEUnk2Q/xW9x9tPifFB2oj5YKr6lBt3X6SG8NKDjL5oZ2YhtCFOognjyvR/dDPbCfZWZEGI/MzD28s5Uw7/ZwcR20vaDxCt8azHj08cm5vIzYiOAlIaCrifupZMjCgx5Orv5K9tuTwLjYqW6cFoS4ObkZImhMEocrXZOWurS1o2gD5aUPNmflKGRRBJBPDqEhAIXW/gtS5kuN0AkEAbYhuseRUH51D+8B7HkYHsDkhwc/IgEEWUCvadiL1NBAuSlZGLOwRZWPNPDIiDzQdrk1ChFSntljjcMbUhfwEOiQfzXqMsjWULMyAsJBsjiim/hReZJ+3sszQ6/iGo6gnwotkkYO6e8ZmqEMaKBrchKawRwiQvVWZAAEfCUHhcIRSzDtsMokx+w7cTNGRckrbnVhBI/uGCZFA7RQjRADxtxqLGkyJC3D/La9TG0G2vE2oMaX7Y1fqGDwseFq7MmwBySzXtMQSiGxeQKLHW06mG6C9+KEVFK2Uh0low4I4hpVycQtTv7ePGXE+Y5S56C4AKoajZ+oc/u9xth0+FhYAceVM7hMLJrMmTzieWpG0HwoNjQyyntzyyORQ29j+EAa1LGAYwB2o5rynagt2rAKtO6gIybujuXs0sLotdmEAwN3bi8k92TVUsGleVO2vEhtJsegUm10CEtpjdyF4DXuZde3IgQEChH3AWuYWtlIWUyhXbQ5QWE6LTvS5AM2zvNilH+HQIF4cNP6aZk5g9W2eItYx836VuVYmxRwtoKi3R9r8cb03BkkdnAAgi/jT/wtEYkJul+NvE8KLsgq58Iii4NAJBACDXboTemP9yny5MFo6xiH9SoQAXBsov4U2LHxHhweyODHxhuc58tmFBfq4+NRZeVG3EdMmSzH7zfWxgjiBzPOnNyI5d8KCWAnzEJ3equNfhRL37mM8vqXzUJAKjS1dzI3OyDkGP0cRIi9Dt/PEoX9SpT5VIC2QnqZKpayMR/3PY4i6L8aDnPeXWCsdYEK4eCAip/aRhNe2ffvlT80SKfNKjZqNK3tx4W5LpCkYPTJomigDb8qerOpkylsSlTJZwNvpsnhSZrJWwASv7epspi2ooQE342qV+MA1svlhzvMCD+ygN+NS7oC5gYIy4q4SC6mHaLG69VARvmdjzG7Z7STLGhIQAhNbcae5hWPoZ3pSpUKblApJrtuka7sdThDGED5UO9EVwHFONSd2fII7Plyog7kaAQodGoVqRxkgMU4iY0dw9w9saRacTpotRxTd6WLHAOIyYiOOBeqTtcN24ffanbWvbIqAgp5N1jmJ0FlNOadrgx46o/LglPAQkgk2NSunbHt2IVQyLIEsAFQOAoNIUbN5dEWiwt+ovfUW5VJslYWyTBjA1dwC8Alh8Vrthp3RyEOksCUIsOHTTHNA2iXqF/gikagH7ammBk8tp3vJCOsitF1GlRSTLKGnb2NyqoOnI7qPbKOIKshKODUAPySo/OOMw43ppBtUu3IXKCFU2HzpsUzmwxu7oMRQbin6UFwU7VKpUzY4POTJgmIKrYf4R1rlL1KOzjTST7QA4X6QRfkf6qEhkAY1O9P9KqbA8VXihoY0WLinLZIrcpxKISpQKhsvhSPCi5O4FF4KUGlT4kuO/3EvYGYT8jJl7ftkf1O9NACmutCTVvAougIJKJc/bX4lVUU89d2v30bcePAhL6eFF6+JBHH6SbVuv3F26IdLWsLUoH4hZPttc6UGxhAi26Sqm6miUJtqVS1taRrS4pbW/2aLRDQo0unNVXwoGRx1UcRooLUK3dVl8F1+e2m2IK8UX58v9JuiffVxb6ipKBNVP8AVQDUuFJNlTUk8hSX6lJbpttay/8AhVsf2IBdTzSrQyDXXwKV+QL+NFS1QSgUqtghPFKaSCrSHABCCDex1RfnWO+xn6QQCjXhwF0OifKk3KhJW/1EaEjheiB0ofAm/wBwSiEIPM/73LRbcq1eEBJJKnj1HiNfsrQKLWF7KicaK8hcqbkpzXWiOegaSnG4I50FuTq062JH3V51yXKXD6iACQmovUGPMplGU7MLh1FrctFXaouF8BXlhsDptMXcoI5k3BVKIIBGuul+N7hKgU8Vv4tKpVv5eWvVol71IZfq0i1W6IQQdaPABxtqBdvC9JGjZCRPFPo4ry0Ry1PLJOBMDpf1BAF7eBNH1IHbkKwPah9MAtiNFW96i6zHFKE9Qikpa38trUWQSFrYpAYmDz91ypINg4kczrTpwHMe3zu1u2Eg62BBITgFqUyxzbCB2Qo0NlIFwB40Ye7sZ2VcVcq2QXJDipNdnd3GOb+bt70iKPzVAGnKskmI9yaAY9nFcZbesQfSb2Sv297R7t7hjD239qe2H9u+14UWKzFe/GLi7dKWNAf7nf6nElONdcUMs+kohxzuRLEkohJNzzqIN7Ih7HbP6YGJCtxZS4E13JIcb9L5bIjti7yBd19Vp+c7HwpXyReRkDcZMSUv+kNJQjhpWK33KP8AQjKGZLBjoY8uMESyw7mptUCpf2Z7CyP3HP8AcPaY/bsTEGGGw+yw5ETQ6eYptDscjyyL1PM2CfMfLJvfJBcrGm7Jc1dxHEpT8R0U719PO2WHIEsbbqZHHUtJ4HSnyPJaWyrDGzm8IZN3K/woEslja/qMZ2k5JvcoTbkLUZGkDcWpEQsYN1FwgCcKUsaGBNw9P9QJOh0C6CiGMMEPdALSFvYXS5B8KdmzSlxA9JH7c2IiWTuH84roYCLE3Sgxj5T3CZWO5pxLuCGtRvL+rvBYj2weDSSFStw2kr094p27aRUrXN7psTHc2uC0pypp7JBeew1bTaL3bGwINdyaLv8AZYsfp0WxQroFTVaDmSRfmeUbxu7MnC/G+lOimZA9sXdY19tvUfwkcqkOQ85PkPkiJjTbcL3RoVHzodj6nyq//lGEjQEkEELTezCO29/bj3nZINVK3DW2+yixj43RNYnbOyUCUrc/US4Or+7A2FXaSg3UW0FN6jIyK+77TfilGcbB+U93l+VJHxA1Q/fTTiwObJKSXSTmy3JsDoFtW4oxT3CwD1BMo0k2qgGny+FJPLvY0juQw8O4QVUaAp9lduKNjQitdCV7qG8XVog+FBoD/Tk9640TXfqTenXR3ZVu2MBZFFuKKKn9xyurI9rLIsNhuFkBldIdQ5tkupo6E6p/R4CsmcwxvysBrcmJ7yAQ1xScFLkBfGp4+32YO64nbfVxK/2QQaH0rJMO27TtGyLw2km9b3P6DP2CezrqOCXqUCIMx4hsGRuGihABc3JqZje5veFYGwKB2+d9tv4VO57Zi4wjtnXXRQF48r0THJNveAuwAIUCFEUAHnRmnw3vPcKStasXa+GqkinSEsMewtIAPluk58T/AEU0CzY4Nske1fO4Kt/p5caiEsBNgWEqdvAIBYBTwFSRMlkOU/oEUW4Rd03KlNoSpCAZHN2LMyySOCzAHXo++sczxd2OSGSWNsZKpcHcPvvxp0lpDHGDC9B5alVChAlBhkdGZEY9px7SCxQG4DilZEZike3tiQbgWyBTY90WsBTI37mtekjHulSKZ7Ckbgmm0U0kvcgO97CsaqbIoBtQa6LZE1h3Oa4gkpYFCqGpI3MYzcwPZz8NuhAI1pgXDCMV/wCGYIlmgBErF6QGAHuyS3xboipcuP8AGoh2wO67skwkoEPVuBUCx++jIQjLwRv4aILaWIraDjv7REQ+oofwoDyoyyFqtxF7o16XbgQ0Ii/ClJ2y2mhJxyiBbqLKATUkve2kZA9OEJOZuQgtanQl9UrzIbhJpJSALqB+kGoaVS9HuQnsl3wWwOg4gCpJJAkOL+TFo4GwCnVwI51BGIJj2G7phYa3CqLgA0QCA3qNgEJUhPCrJra3IaDwoFtmnwOvK1Evm7auJR3CwIAKceFHuX+q66ixBVDXd76dVy4KjQBrx3pQyJJNm1RtDTuO4aonUENERxh4bcm/EqRw/FXbEXhdG3JXiBcJRdoi8kvb7VFd8KqhWqL8+nTh9tLIR4eKlTwsieFd2InspoE1FrfKnfEj4IeXA0Pn/Ch8/wCBpfsbyuLnjdaQoS4HwTjZCBwqPn068LWPLjR3qCg1vYounMhP9KN1q8I6igBuFsbhPGt2cVBG4hAjl0sPxAWq4Db20BASyjxSghUA7rDbxBA4C9F4IRem1mg8bIFU0VAaEX8RP1JuTmKLGuDk1fuKEBDcgDU0v1ajggCEKFX4UFKAAlb6qhG7iVNFFRdbeB0S1E8VcF42PPXhQd9duFynSU+K13tQSFHIApZbUCBYq1tlPH5JbWledwRWnw4oidQT4GjEMgvF7XJUaHRLOGlTxWDSpKqQAiH/AOZLDnRyF+lUGWS49SheIuTanEnsOhap0Q3BKXOgPGhMYCVAJmCaLYAalRyoSxruJAdcfbz40h02Ptw+pB80oldi3cgCg8AEvrQj2JFGD3uoru4uuePxpkvY2ktb2FB/UhpC3u6w1qeX+5dtGRDAVByGiwHgEC+FAumk7ICOhKEHIJuMRxttKUkeNLD2vOjxl4AKiqmvzFNyZgXSgdjFiCpjXCPxUFyvA1LLPIriXQGK6EnSxJKlaM8Q7bWH0/a4Za6kKoDghX4V24nhGzHZoCCeH+7ai/tLGobKFKOFzt4Kora6JXHIDcaJpJ9M46kk23W1K12jMuUS6AzThGuxQCCEA1OgqTotLB+axPIEZ1TULy41k5M4mlkjGL29vBANsyDVTrU4n+vvJKAvZJQOb0ogN/tp5bL6QRxQ7dyEh8hu0m9RRwSNgUDdMi+rl8UClvjwpk2Pmz408YniiyMQ2IPRM0v00P2VK/uEEmaBpAP4ACFF7km/xqEpAzIkmDTxi0PHTdZfCnRujQAmYtUhodcbgF4hvwoQwlpI88+WPSOsbndqQvGpGRglpJPbBAAaANztyAgDldahf255u0AwthRMpQQpWwDF+NRsjLmLsDiwGSTKJuUAUtKmlc3YSO01l/LXmPnSDJB4d0343ahU3VK35Dkiij8mMlZZQQFJJCc6c3Dyo3NkZEQIwAcQOHPUknlUYEgkIUwukdxFk4m3jRcXSRu7a9ptwpKqeCL9lWPdAJeqACLJASyfhI+NR/T1FHsYAI11dqOYrHc1k2M+4kM53wbdYtpBQrRx5HklOgYyPCNJMgOl3nxtSCYRMjSQxsJPck/FCDwU0AHCNhn7na/vg5DoT8acWQtjaZDHpqhJVeAK09pjLIpDG/Y/aT5cfmEbQCQKETHyMjMdnkK3yr3QBGp41kZWW7IzveG5XZhwntX25uLLH/iC4kq69MLWnGka1VaRdpKixVFCVIC4RMeRIUIV2lrWAqWNgjic4KBoqIUH+yow4/mnbBNGlnX8lw4pRY5izhf7n80r8bn+qu9cYuUQJ5GlZcWRunTcJeopzPGwiImQbgh2gI6x1IF6n9o9pkOVl5JDcvIjvHHELgNTh8KcXNlL5V7qbjyWxB6qH6d21jFLHG27nxJ2prTml3YAXqfuSMnmDqqJXba7tAgg6gafiGp0qJm8zskHaMsJIjEtipJNtftoY+OyWOUT7Mcyq4TzSkABRoAulQ5HuWHie6e95zd88uUFhhaWgnHuEVDU2OzDj9pz5I9mHNiMWBz28JoQAG7tFqaF2OIRNLNE5rTbHlieSSEIBBI15mlbKJA4HaQ3zrEoTZEHLWo5WmaJ8gEZe8ANG09JbexSx01qdzzkRDvY4Qad7ahS9g7U12JXBPTmSZ35kSyuVAEXeG6mop7ysORPjvBU/h8q4CWReVqkJ78jezxYI+Gm0IKlkmfLGO8FAUsuRf8AmBqdkThMI4EilaEBCBQVXn9lMY3ttLAiNZ5Q4uaHFACooMe1jY3MALt5CsNy4DmtXChv4WJ/VwBqKVskYAjRJOt3bIQobXoTsh2I9S54VVVSBYAU0gNPecRHFPcEL1E3s48OVPdLH9MJVLp42RSDoldsRJCP1B71ggW4126/dWztY7lPelyenqLrgDpK2SiGALEs41U8EIB/ortxuE8YI7zAUDQqqdCGtJC+FTs2w5TsINOTPh5Pf9tyGuQ/o8ko7cxbi2hqLKH5cONaAqPVNOQiHhbXnTgIenRyFx5IpPSKEcWIFeD31SfpUkOIGhqHGDxDi4mMYIxBjjq72nq8tFcAdOIrbI4M3q87SqG9jyBW2lNDvpU/cT+FdRSMSw4j5cQlaAH+hOKXvQRO8EsSo0R1kuL0JQm78bbEmxVBpoK7qWb8wA1EFkRK84rCQu46roliq3++iYrgqUK6G9kVCAlcTMEKkKiJYqUGlq74JJBsCU1JPB3jRlmupBIuNOJKhSErZASYAiObbdbR3IAqqUZ2Gw1ah04O8Lm9Na1DdQQLcVtc0bpbiFW/9YrS/MlEOim5tQHGw8P/ADFJLu7ob9RII1AsBoQlbipuhv8AEXQcz/o26HxuPuK1DfxNlQA8bWF6MMP+Ide44ctycKPd3FpN/qPjwWxWtoLUcmptoEB0rX6iTxK6ApSIVQOX+1YqRc+Fea5CQ1NCtlQ31KaUYcnbizAArZLBGq4ABCmleQENwQhAsUs0c6SZbkpxvqCfmKAeh0uoW5UceVBtxx8Qn/lXD7f9lWRQVaAmvEnxoBoQXAQ//pacaU6tVG7ulrgbrzRbJcUsFnbldsTQn5WK0/vc1KAXcll+dBs3NpII1IQq0rZALUz04TvruBbrZC4DU6VbcOk9i3MjULbSibKPmV4hOOtPUp+Xr8RxTTjRcHKhIPCy2QIKVL8nCwbyN0VedRsDu7p2ukn0qlEU3AKVj9vNGPLJmHtQDQHJ4kgqmqrU8LIDPNjnol75dhktKuQBUrGxce0s7T6bgmVOAS5XHUJobUcWWOZ2VDMTPAohyDkoiixAaE+FQTQCUytH0kAuVfBFIv8AGopnwTeaEb2VHNbEWXbf+Nd44xgR2hCgg8Vt9VYsszuzE11j6nW+rtePA8KOHFJtMs5CgNHqoiEsddBUlp2OI9PEMgbiCCDrycBb5UDDB9YWaadfJDAoM2O4gFG/0VivWNnmuLJMRWc+p2tifuo92MRmUqS5Eytn5qILIRUDJY/UzEpF6d+oClHBCXOaKjjd5O5JYoyPws+oKUO7+IoNaQ6QdcMIbw/vtDZV1qWSKSb08qpAjQHSodpAKlea8KhjLXxwCQ9g/UFDjub2wl1+dS75HNa8osyvuTeIAobfZUe6QxRylJCCEdiBLK1QSaIbjydmJZHvgvEOlQ7cFKEHSpAXbSVLSVETQumoRRxoyxx4r8rJj7J70Xdf2TfuwAGxH/MoGaTuSuU7ZJedr2sh+2jFKECFH/h0VOIuaDhvb24VaiLENFN9HD513nxPL+2297A201vzqIiHH6NxBFk7hCqdSo+dJK3pdIFdCbAfyoVKLankSANll9O6PsqihbEcLa1snHeuC3Ro0IXhrp8qigyJIm48W7ZqS0orgQLkN8a6AgLO+q9sEKQCORLbeNbWktBDNz+ntiMi6Kt/vpD1zQlGNKKRdAqDQGmvasbXozadO4L/AE+NRTiUySNm6nM4XTsEG16MTpxCZ0kIT8kKo7wHNKeXIQX2vqCFXtJohoS9sNGzqv5iA/8AKVSKgaDDGXPXcSEPHqVUTj8acHNKN0jbxPDs/SUp4O9kgI2r4DUiwW1Me55kLgsKFe24jXVSCKM+VIjo/oDWqXc1JsF/hXah7hco1UNS1yRy0TSulrDZCQgAI4oRelZFukQAuKC/NOR++pN8Lg1y7o+k+OoRFNSnoGRINzOkbS1pUHSxCU6TtHUF6g3PystFNjGCcuR47l9CYwEBHFeFYs7u92MfNgyWuKbDGJQrlPiNeFQmGVS1rmv2lrnBzGtcCAqpzNY+LDLveoMpYTpEDKSE4BnGwr9w+lHfxG5kkYkt2+6xA7TxGvE057xtMgUsAG1sZVBAEuDTo5Y3IG499PNOi3UloNRbozJHEN3aeuSSCbEr/vL4U/I7sM0vpx24ha0hBTaFs0fNaO0g5E0HkBqFhMg/OATgCL1EHtbLkwZEm+ZR3LgBbFEK3qcMMRSE96Luq0BxBXUgEjTxqZ2O7a+QhYGK03IUNQJ8xWQcgv7Zf3Ws6dzSgKkC6E02ENc4vAR8h6O3a5RUBA+6hl7XwYikEOF3OCNafC4XxoF7du25d/zGkKCBqiUxzb9axsKjx51GJnCNzHMnL0djlCl+I0F/CmzRMfcMTaAMY7gG7gop0cymOMkEG/1aDX6UOlCIR+UhcCSC0AkprYkH7qMrcYTAfTNANQ3gSFRdDwoGOEQSzB02QgLgiFV8FAtTWSFGhQGNsP1B4NFjzrtdIkC+WQQWsIRWgISQL1HHGS6NmPsUgD1eMm53iSXcUvU0o9JBCSFCObwIROCfxoAzGWOQmOCMgtBUElQdUHyrIRpAYVurfBRYppSuYiqXbgC4fyk68HVtdYn7Af6qIJ2PsAP9bJUcwQtKorCARzUoQVqGJoNi4E6/xubilgZ+e66CzURp8QRShD0hQjSFsp+6i6HbBAHXLlUcDcE8a9RAPqP54K7g4rYFLEUjrkWX8KICDtuCqUIjtG7S5vzKaIoqEXK2+ZuR4Vey2uFJUAG1lUCvWmBWkEHpAAttVRw/prtCIAIvBfipBK0hUX4Xdt4prQ7JPUSgJK7QUaHAAAuvRJUKUOoIAVRZdeVfSPsFBdeGtjy5n7KC/MpoFGh00FdqH/EBdk4I1QkAhDrejCoZlm6hf5VVSpv99cOk6k62W970CNdUPSCEAv4hPtqwJcSCEKEXXUoCKcXmwaS4qNLagEV0oAqa3s5d2qDWvTtcuq2vtuASqKaYGixXq4fw4UgG4aXHPUfAV1arbmRz0CEGh1xjTx4WTmtdSX1uhJ4FOV6JLuoW2gEnh8RVgvFQNSQpUaC3yWin8uoPNfCk48biwHA6KppDooUcNEVCvOtRaPXQ8eNFd25V3AIn9kL4VZAiCxCkaICRYXruTapcKHApYGx50FsSpU2ahW9ESRAuQ6OIab2PyruEiUvi8yIKbE8iinT5V5bS5QC3az5X/EdKcgvEEC6BRtUjTU/Cvb8eKODFf6YwmSJpIydScs/y/wAKiGc6aKG6ZAJ9N6jwLesbgPktfqlX8/dCQXem0CkqS0rfjUkQ8uYI4dkqDikghwI3C41pWvQyQg9wgpkKiI2fgfhUs/uPZhlkHTFCoIMAaiYtz1A0ImxDzCSWAIFxzohVF++ie16mWXsQix24vG6fSmp5Uj5n+pGQ5zfT9WMEJFyV0brUjWF36v8ATuciLbqubhU+dSSvbLJ2gGNj7/pwXaW1G5OVdiEQRwxeXG4qzhu3SKUvp4mo5Y0i76iOXvg+aFBUaYxUfA0WNWWXGCd3I/KcUIJErePLVRUDWDzm2kmJ8wyDVtrAIPhU/R2XBZxtKFxsCCvFxN0prgzHLIts5iBBYMrt3VSE2tPzp87z5UoDSGARdqONA6yNuSPsqGIxTdjvKZIpf07kttIJUNeBwoxwMhxi2MAuahlRL3/rpxZLHJ3FaGyMTUfym+grc0+a0oGjoBDXaAlECBKLO1uVncnn+skg3iDVVQv3V3O5K7mYACeoIhB4Aa0Nqlv0wSsBBtqvzrtvA3ouxR3PjZVD6UDql/vf7to0DQFJDjp8alRS95EDSEQIbtG5S7WmK1hiiPZc4qEsPmddaI7YVrRs3cYDoAgQFRYUGI9mzrlafzdEDuA0H2Uuzun86ANTcG77i9/FOVPdudI2Uo2K9iChB0OvChsCzyPO6MoRCH3seY+2p5n5DnNjMcjb+b3HkhQvxqVxkEgd5hisvc1uQikVj7WISCqo+URgcyLoqqRTnPO+MDHayaQ+b2/Fwsq1vG3beTu/UZFJANkRBRUDbtDXPIH5Y5FTx+dRvZIHFk4AHDp1QpxB+2pNrPynxkmYL296IOPOhExQ6MoXxC4TVT4UpkLT1eAuQh1q7/v1/wBRS8AACEtomtXdbl8rIAi0ocR/zLW4G1lrY38PElEW58KdHIwidVtfgbrxUV3hE6MA/UAL6kk+O7WndxhDIyUQpGSeAcAoQX5E1BhZMDvdMeF+xu15jzDC5W+abA7kt4VN7L7Hht9ihnc+ObKDTL7jNii80MMzSmPv05mnzvvG5fzD25hKSSbE/wCutEOm3bWN2AagA6GRNUOoovBPYSCZrZkafxDUKQhutRBojyMh0JDpCZNCthfaABzoN39toWdmiA63UqEJtpWSxwdmSygR2jcndJuBfpbcKlqDI49u2ZXmN+rwvdHMcjyroi7afmMjdYHiY3X74U3priWRKzuQFkYkmRbuRU/q41OMdxY8gNPcG8oCpKDVRcobU7IjcXtBNnkLJFGbbQtjfSu327n6Ad8gBsvggFFYCGA/U8+aSBfbe1b0Ltz0AQg/OyVBHNIoEjSj9booG7lUcsS9uELIASoRSlwSAaQQoZNs1wXbkG1LBbrQjfaNiHu2QlCSD8SUrHZ2TjQTWIVSo4kEFFOtTmL02PFu878Wmm0EapWa/wBJCZZcVuLAGn/AkH/GlSdW/wAaXLIaJi0bkQiwVwH4dyLQE8TptnkCYKAhREVelKETsUrxQD/C8StgU11WpsfvpBgDvwZE2o8EAuDolPf3zJNL/cBSCDqgAGg4WoA8bIq7U468qBV1yLf2rIVqGTpe9Q4Nn03NO4KFG9CPnQys6eEzyTCTsQ48OLjANSMBuNjoSrQOOtA+oKOJQ6kFSXC+m00FnLobuXjfUFqqho9iwCdQ5EpfTjWzIxbBDpchSpVfCgyD8ggCC5O4EcdEWgFLOLERwS5QleDVThQ7cDiGELzvoVQL/RSALzsD03Crzpd21x2opJCNHPQEfete4QmAaDaFQ6WTmutThEQCxbxQa26kISh1IlkBChLa7OVBQU0FusfcqkeFAkNB/mB047QTrr9tf1EaJxoWVxBJUIU+rq1Uoa7IgF06wAftIvQJYRc/N3hRX600KLpqeKhKGhuTcoAUvx5Ubrz+ZHibfCtaan8hH2rWnzUJe/MV2Tt+gXVECDh8TTQqgFSL/TZUPGxp0jS4EbtniF4gKb04PagaQV1KGyX4kBfnQAYEPAooTRb6inPQnRpsiJ/UaH+4fuDx96ULWL72/wB21flHUp1H+ugreAv1Ko4HVaZtuXH6AtrKg5lBSjhrY8dR40HKbuQABAmmhQ0geiCxACjWy8VWiOOlxwRLkhOdbSO5ropH3868z7ToGi97a2qJgC90W23sbr4WqGRYY7GB8sKL6YAhzv8Ah+2pZDfCDiBkQlXZPUVUaqCL1ujkhlhb0iF3kZPpwbAKAQg4UAkEsc7h1k/p8Yn+dbBR4cKnl/T/AKadsABBXbbcUF3grwrZCYO12PKIc5VH/SKioDxoZMkaSxAB6bT6VB0tAIura3Z2OncB7UzVcUFwVCWIvURiIiZFjrE4Egrfj8alAMg2DzXn+0NBooK083xpD3y3soVJIsp6V41Jvlgia0AaA4zQCLqm4k3+NZLceQux4oRNFp27khxT4iseN8rpZpYu5JDj44RDoQdLjXnU0m3I7Us5gXtbkjCaBVaRt+yo8fEmBkaDkRhxHU1COo6ANb8qibBLA5skJcZXJcq4kIeRt41KwTY6xu7uRl9gRjExkCBput+QJJqaALI9xgd54P6lX+YVGgQr8ql3FGRXLyCnCwtcAG4NM7MXUQ1OoIjOvy2gooHhWRD6rvxGYMj7DFGSQh7gJKgN8ahllQyblfvQI3hxsqUSivOqIqIUPJEAFNLARK1tr3vYlw0af6678bRscQJJA5O1JcKhFwF10o7u8rCUKIt+A02oUoXBeG9DvTklCeB10NzQkXp07tkUi9rKbaV6cyGJv5jpXlo/KX6bW3H7alIO/toSvEqBucURSorLYSDuI8kkgd4G5J4GpHxxK0fW5x/FJwJfdAK7Us5Y2RdhZ19t0YQAlQdaBYQ3IMg27XFCIjxWyoK3h0LC7vOjsirYxWC8LLUUQSJ8rwxjf7ywXwFiKf6ovg7R8x/b0K2QcVSgwo9zX7hID2ltpwKu/poFrO2OrbHJsOOOBBi1JUqKY3uAtcyTeddsWlwigLoK2h4Y0nYHSIH9SIU5WraHSTN+kjsLEQSQFKqOF67xHZfb6zcX6T8/uphdHO54f54AIBKDzSCvStRgtsev4g8USwAPhTmt/BtcoIUrz4056FqLtTjz/jTHWW9tLFUK8qabh0nBFQEoVGp/qpSRt05A34AIQp1pWt14WTknwpwnAEzT06BdQWpex1NZm1qw3VwYTCwqU3A3sDRc1pLSVbJ23enJF9ShAJ0FTPLnSBqF0gseoBB08F+6t7I98brG4Pjdf5gab0tLSsbQdUUgxaEdKammq3twiFHLqIhGQWtIub/OsVz35zsGXJg/zIYkCZ3oSNGuzD2hkggf8NE4eFPDjRH0hDiJTk47D0zzng8NQoLA6Vhwe7ZuT7Z7N9c8uGSJe8qxmcyguOLkKnOsk+2n0zJJTHEipKWuNtFaCP41taNhlhAmgDCXAm9kWxI++otgEMjI+y+HuF0rYowFJ1u6gA4uJIe1x2Qv7RFgCARcVIkKuepYnmIwLwXbf/bQcxUUFF4qP60vQ7nU2IB5aCWuBI6QC0khq0XQuDBJsJ0SQtFkDhqANedYM8WXvkfIPURIe/jOaR1CwCLyWoNym7ioRdzWpYcd2poZcUBhjS8iDaWlbgcimlCKUgFAGTpu3Bbq0KUd8KJgUNIRXdWrStkstJEMoj/kW08Ai66msdRj48H9+TuJO4uRFBOtFuzIm7QcWnsCwcpUDiUKVBthGQAuvioKgm5amp5VPIVVF8W8Sg04a1LHDI07ip7O5AnJeK867pB6iE0NtGm3MVI9Vs7+n5qFrl/rzqEzKoHEkiwJCm9yaivcHyChciD6idUbqfhX7L99i969yz/3971me/8As/74/aU0T09gdjxty/2/+6fa5k2Z3t/ujCQ4AqEQinTqNxVy8TdA0NKAWOlbEOg8L87XG2lc4Ham4KeA4W4gVCAfqITQgW1TVAtdrHxdbOy73JAVGHgmlfp4HOIUp1AWAKuUakcKb+kDQU1cQA4qFJaVuvG1djIgcTYMLV4aAoNayNmK/cdxHUVCBQEsChrJjd7f9TQAhQ9JWyHVB40lyjivAggoikEIDW64KbXXFyRqEHCuCW0J1UjW3E0CmoN+bfq/4riipAJBbzCO1cTdasoaEaDoFQIU0JNKSoQEnq4LqGpw5UQF/D/vXsCeXKrkj5n+utoVCVTgeO8qhW1FSePBRf8A4uP3UVNyRxIKqLu1HGuhx6uRs4oDqpvTRZW6kWBS5CG4dZKhM2SYYuaqkdwQlj8PjRhTvoqWDSf5dChsKKlUIRQlyCSFbxCcaW5G48T+LW/xHwr/AIvsHz+NWuhW+h/8vhRJ3qLAKU0RQSqgEU4kH6//ANSnnkFK/wDAlvlSKWlylWm5G0k/TduiV48FREC6rx1ogr/t0ooeKiyBbiwC0k/TddF5gBL2UUG9kpKEkcUbcaH4gaUQt3NTkQi/1V3MddoH5oUNaQbhB8DXbY2CF+SQ2W1igvdET4ViY3uGQcLGysntZcoQtxIADtzUFlJCU6PG/wAJjTJHPtPqSBOGjN3fiY/7EroXMisVxAA1DdpNgFbxolkMxkAIE4nYjkam1Wjb8qhiEYMrsU3I/wAKGrZQNSKjgfH/AIwK7mMkBQCV6VA+FdmTvRt2lqnrTUgXuL/bQE8qiWPaUTHKKFABS4At41JAesgL3J5SU6VNj/LQkx8hGd8O7dk1KqeCkVsEUsjpscQyENBxjoiHh8aEIIDB5UjYB/1Fyk54giiWxiMzv9PFJA6/wU6CjFIJg4n80ZFinUQNTpW2+yQzzRRxE93/AIiCqGgWxTgtG4uGR3Yh3LDTS5+VF46nS7Y5Ib9wngEXaQgoPe2WUMB7swQX4C9gBam7xMxvY7H5okAKLodbcak7kxEyY3mhQIUCKNqAkgIa/TmFwcEeGAkhq6iwP2U6V8bHFBEzZpjt4lTqtPYY1dsHaIB231DrC9BrmC6AqDfapCGxAPhTYF7jgsfa4KeCIhRaZGTI0scqou8AKltG2ovMO7bGjO2UI3gaELurb6dzuafLgQABfwKUpxyVVyGxcunijanlyceSTJjJGHjxkiO/5pmU/wBdOfpECUbHcgmyaUO4XK6TTIU+TqO8OJH9NPHajYyNJYf7wHucYyU01oT/AFFp3tMdu6Ceo9Z0586eXMYyN7hcdJBPJLWTglb90L3/AJklzG4RsCDsKqu+FCPKnORGjWAx2edw3J/aTnXZZjudIGJ3QgegAPNN1q3ubsk37Dcr03VFN0FC5Lpel2//AJYKj5Gsb20QwTNJkJdD0ybF1K8BTJciHuTBV1GLIYgiIdQP41I+GENYrQoUbCU0Gh040YX79ztwvdRrqiIgoP8AwqS4IpW3ioNfkj4WPyP2rRbKPsWw+AN9aCi0ZtwIB5JzrqjIKfVqOVuRFMCSFAiqLXTRCv8AGtDfgV5WQ66UxdH3JPD5HiUoZGwNa0u+lEIRS4aA/A1O7veQXKEsZLjRujU8KIdI10jzftlJLFQCCAgDaO0+Ux1+ypjJk8FKm/21FtdEWAujFuAIF0sCSUqPY3tJ5EzpCsfbkFjAVvyqVrY2uePyWm0bnjXieprbimp6eJzts8IdOf1AOocAFLgVtWzLLpYCJF7ZsCCoDieCmlZFtMJ3iW2xqjpT/nu4eCUJHTbJA4ea1R3DqilLcPCs6SOXGhg/OknKhznPAAAtdy68KGLOAx0XeYGEBQ0GxJIRLc6nEDTANgRgJuQgKOCkKTwpmJ3m48hZI1zsoF0UytLuAF00rvMF7vuSpuQQl/8AyraO72nG4BOpN/FBUfucETmYcBR7iHjeShcMYytHc1uQTeo/WyntxvUsXqFh18E5UOxk44tjjsDUr+LUgpxru47e/Oh/w7Rpq0ndoBrarlro7rkdIB11TiK7394UIeFU/Ijp+IotQOiyP8ROU0a2wAICXHCjEIgPcp/KxyNC1dfAFv8AGn5Puc2PHPBjF3p2/UUVzgpIaXH7qy8L2SZ0bQCe+rVcCEAstgLUJfdJJ+1knIsSqhVJIXbtJFqMnt8XbaFUougAQEcONKv5HTeyhyXVV0WtyhstwribiwRCRwJpASgN+IA5JwHh412YS7dYgIqBBxXgPnTJi0ep+kE3RvBocb8PglBqAqiz68VQDitXABKBpQjgDqOfA0rIQFBIcSXfJEOtQTyYoxYGhqoXOc5SDeytDlqDyIkJ0AKJqLOstr15+K1dPpKIB1HpQEWq+MwXQJ0lVsQDy/hR2YrGuBariAVvZxseFZYgRs9tvSEUtIUfbep4JsUZWwAAkIm5VKopI1rJl9qx4yHkqAAP7RAXW451kQ5OKCVKfFTcNQaJQKAAHUIoQjS1dZUAKCpVNQCmirRACAWICoUIvpcUW3IkRdTYXVQhWugnxtYfH4pQJ6t11VNqHx40CgB8bkaWBRF8K4lTy1CfaBxokFuxERSXJrzuaag5KoXW1hegdxI5WBN7+GlfpyU5p9RIUfDWmNQoFQLxRdSDpQDD0/VtLQOSgKQ4fGj2LNdroUW5R2ligNqFupCPtOiJzr+UgCxuCiqvxWm9KppqUUkLZNKl+BSw/wCW3nqeFLtcLJZ5KWTwuaIsHahfEKhQa2or/HwThanbr6EMF78LJpTJZp4vPxhNBBiptbuF/WG5oqdGrYLdDz4Wr1kCHIhAbZNv6iAhQJ7BF5UsgvCpGnEq5Rcm9PIVWrvUhqLfpvQUqLdI0spNkAJKVJJj4GXlY+GVzsrHH6X231Is7L6bKlPiGPu7G0S2QEaBBfWo2yepR8zcfLAAUYx0RyaA8K9LI7vwgAgix2HQW0sb1FmM9v8ATwgjtwwqcYXCk8S4nWmuZ7bkB057XkqcU7erc4Ebj061GGvU29QzZcbSgQ6jSi9HN4Xbw1sDe38KiAx/pLgY0791VpBS9/glNkOIYg0qSn/U2Fzw6afDsTHkIdNEB3vVIQgt0jqKrWSIt04AO+AWyMbHBKqCgcpt8KjjkTGHe73egatiUDZ+Tj407IhgMc7FhXIBeLqFHBVVDWPE3zRsPnRjYMVoK3XiSEHxp4lEiDUuSwItCo0JVflQixz5EqQy7iJCDx0Idp8Kb2/Ml88RIF3dsaA8SmlRROJbHL574TDfuRECYhNQQENSwPh7bDJOcPsqPKNjAC6ykKaDWEzY0eOPT7kDsQhBKCB+Y4mo5JG9EilyECxUlUCnav2VjmJ28JdhBOpUFeN6N3RPNxZfgBdFrZv3zRBJd6R3IJUIUX4UxyKTfaDy5n6rGpXOOg5iPiFIupANdMoItuYWkHbYtQgpY8a6XEFUAX+74q69zRe1pPRucpTtg6ceKU6Dtthy+53RkdZaiDyEQKSDU4bGARZ+y8ZUXKKL02xSSMQOyHle1JErFI12uFr0+HJsWqTrsF9QAmqU10bFEt2FqusOY5W+yilz2o427WkXW/VcXNMs9ksT+q6hOIF11PwpzjI2MzHoYqrqhuAAPAVGC8Cyz35ISeYBFdPQGlBvP18wrwOVbwYGR3Mzf+QXWi1KpzrI6lzC4GAMmAtJZRbdd2ooxt2bor3JPVbcgKbV++uwd0riNzrkAFeeoStpKWO3kerVtbZGFePAFNCiret0fJRyCWN73SvymcEcv28OfhR8tAUtYEjwChaV7tuxSqqg4A63tW0j4KeK2QJSlQeCkADkaIJszqkULwX7ENS7WgtcHNAHSLhQTYKakPb5YjRIgLDdRx4aUJJo9kLQQJQjUePygvMEXoQZGS/BxHyOE+ZAhBIC7NqgI4j4UY8aDZEQWlwm3FFQOLflqOdRwhohds29ruiVQxDKdpJvegJiI3RPVjiem4QACNLuXS9HbFO9/YPdJETNT+DVAiUvdLotxkycf67j8njcX+dBXZD1O9RaIH/kCLmHGpTO4MZGmH2h2zH2yQAgVQq66rUvopFJm2RsBKEAntkG6k1JkyY8jw49ERPdl8wq43PUKVNwc0BjyPyl+oH50XsaGsB9I6VN97HpBTlrW1uhJA7nXJYJ5Q421otZsPAraxJaV1F0Ne0+0e4e750+F7BBPD7I17Q3Hwu6DPL6VLO4A7ltQzmKchy79pBxsou0JAOoH2msSSHKlb2p+xKjiB9NwioSPto4mXKZGjR0riOniSRf5UyJ+VjY5kIVu9pAcuq8wR9td5vvmK+eUITlGPc1Nty0OQEc6myfcvecFsMDgpbmsDS5R/KQCNxqbF9lycWeUOy2xuxXMUoBdpG42PjUpxsrKEYDgQXlyAkqVBCi9dyWQyTSKQf+m5hovxOp4GgZOrc8xFg+5ByB5Voe3ccjuIQNC6qlKg27k7YFmnS/j419Du61yxqoI0J5KV+FKG+oAW123Q3AN9f4UzdqCT4BF8BcX+NAhEFuBvwcKDiNSEsQCVJv8BWP6fHImKgNI3qEOqBAENY8ssBUt6nkK1Cbo02JuaxoIInFvSXlArigKusbfwosZjhjDddHA6Ai1hasOD2f2bOyRlE4Tsna8+2kBSU6SC+2vA16j372M4eKdn6oMflAvAIb+EBpJ56VK30xIKncGrwVWpqLa1l8EaeKBCDZpuQLfG9djPNrhPxNQI1HFCtqHY/U4yoLEt+DkHA6VkZ0OOkyE2A1LenqAQkE/OpYJolsdQW3BB0IsbUqINCLC5RL8TSyHkU0uCnG4ChacGC4WyJryOnCl3lRwS+g+kBEC2+VG5ABaFAKnSyGyOraHWDrlyN5Et1Gn31ucSmqfzEHUISNK02tK8Oocb6c7UDvc1bk2sCbGwXWiQLoUJ52+1pooQLjqJ0KJqmgpEQ8ALAaHQkGw419JPyuP/OgpCBqFLcTtBA1FqVtwbng4oqlo4WrROGh4JYldQtNBsF4dRTjQIabuQOVRoNLWRulWU8QeetvjRLApIC2QAqhH2XraeAcAt0VbcKsBfUhDryKcqseGi2Qi+mtvvrW6cRf4EHWkR2pCDVEFvE8qeePUovbgKAyCvHinxVvOg4I6zbpqPBoR16y8fDzcyDHzNsGbh4/+Gy8aEKPWu1cfHWiTpOQqaonS25ugFqY6Rxk7YPkXF0sON6hjmjMMUw8yfFun8o4k8udY754zle3HGdknGm/xHqOIJNrhClCL29pbjr+p7oXJwS4AoEQEOVNKhE9y5TOQhLg5SACAbixvQMUO8i4nJUAApqgUkGu3LGhP9wQFKXWwFjUcggIWJO0US2rkTW1EenLU/LgG1pKEEFdSEFSynDyQ5W91P04GhxDu18OVSCGMNjm8jKjhIQ5OgQOKkIeHGsrEEhmjhAyCoCkAAkW+k2+2o8huSWh5MzY5fMuUZt6UIchXwNdxkx2g+YpO7GJ/Nmvrc28KL2vUyK6MxDzdNSAEUioYmLLDFCDNKm0NuRYFCrinwWsrHGHDN7j3jP7Pl5EJLMWDt7M/wBtmNhkOyWqh4GgGy+ngKmKAAlCCpAB0AS3MUciafosSgT0pcbKBcqfsqN7QRLLCCs6lQQliOelNYs2xn18PS8CVCEkj40wsK2/PcVxr2W9wruN70HsA3keaGi5C2NyihOFOAsUHbT/AOo4Anjb7qDmqpQGIJY8Te6EhaZu62hQTyOoXWvMsFHcASxOhCoptQh7oY6/be+6rqDzAIpGkBzy13LhdCfgtSzQTGUyLH23O7dvgeLSKcWyEtyO5BPGVQiyFdAnOpe9PvdoHkje4A9zgNKRgV/18g2JL24dNZG+ZkZZ5kbn7jES78OlgBapY29vcb2QxDFI6T8bfE0Hdqw/u0Xtr8dbfdTiNxneRIx7vLiUGw8Up25DkM2zQvLLNc4ee6+hT/ZRnA7u/wA0gJ5o0BPgBWPOD3caNCXIkmSpJQCxJHOoJnyhg7Pmp+YUW1wE28KdHiyzAOH5n94l1BJCinOlVdxLNZHAGzdPvovcr3ReSoJubaEjqQ0WGyvQABQCRbSmFv169drJ4a0zdGC7VjlXRFUagHhXaHiCGA/H6jZEFF5Xq+hLm4sSEKXqQcXoiDThdaYJLXO4Ki8ymqNSprnZscJAzhZNNSq1O4xIXANVxTw0NrLQbHLI6IKXmQ6TAoVW3SulPy5SsPYEHq3jyyYiiEAISV1ouc4oYn7ZU1jIWx26FKdPGzHD4uyuxWSFw5W3XX51ERHB5uR3xGR5ndcVJO4qOkfNKl2uRgA2Tr1YvCZVt8K/MSCbGLZZ9l9uonaBew/jQMCDFMGyWwL7m+QCqlqfM07yYOzFtLZ4rh5mCju34/dUhcIoREUYWqQDzJozscegBqgnjckDxNOPcP8AdrvVNoKyBdNxWolLUEZ2RmwFlBbe9nLpTzs3v29yDce2Il/vV4nbU142ArIY2AtiKoR2XWuPHnTEJ7QQXBDQrl0AVST9hqZiiMSkd+GQWC3HoxcAJrXYIPZIXuY4JGierKlN/MfdRlxMhrCJignn9OT0kNcV6kfUwjnma/Fh3SBFDskLcO0cAbJeoWM91yICnmxhVVQUsbFPurIid7hPMxqLCcjJ9N6fI23Tm2hEC5rpfzT37eAIVQHD5mmAkyJYxKTYXBBIQrRk7gaPyxELn5JYkAVE+RxaxkgsiG5QKfianxZpMeQwgenMGQJwmTB6i5Co6/y0o9uILbkVTgVIKn7aBkaCF1UAgnS6qKDSQFI80FG/Em4uW0QQhF0XQA3IcUUkihtsGkDywQ0nmHa6V2e2Z9Av/CAl1UmsbEZjuaJPqc4KE4gopLlFYgGOVLQEIQltrcxpTcfHddRcqpBPiNQTauz6X3Aew4LmjLzQ3boVIG4dSgcNKxfb/ZsB+Nj4zS5o6SS7aAXAoACWhfjU/t8sJy8XKwh6rEywo2goS0uAc0NN7VkYwxnZP7f91Lx7HlEH/wBreQTtLh9QQ8eAqbGQvCOMj0C81LRcKKamOCgRDxtrrq0GvT511CKE+hxJAARFANOVcrElBQWIbuuBrb6qyPdIMcktwD6nkQC5w2uAA3j8R8K7QCGyqumgW+obRVEUFQSicFACFBQJUqm0aBiFALaldKJ2qQLWv4oRqtHsg7ibn+nwApIIPVLxIuTZpFgm0VjGbFB3AFd6dPIIEsKA9JvT+U3ULqoU3pPTu72o6iNv4jdE0FeRjbiLEk20UooFWxSnHiVKoNEGtCGbHcUUaFLcXEppShzgLggnU3Bsi+FXPF6r/vePCrcSQCpsV52Tl8KAxiARYgG5IIBRpvwpCimxBBNrqANeNdOoup0AP9JpUCrc6NF15kha6gV5rrfwPD5Uv8yjVTcIRZAAQa2NVzTyU7UAJJ3c+deYWqgcLAn4NP3USV7iInz5/Oh+EqnH5EcgK4px8SuqIqmi3cVABsLhOBGgCClkJ7th4EAqAgCLSD9O22vVqguDqUNdolHQJ5KkqCRZeAutQRMlAkn1EAMpuEdYi1taOdnQ4rGwtaMdxKqSjnOcy6hK9NERj4R88w8262IC3/hT8fBeDLkAeolRTg6KS4agj404S5AlMxO5xT/BuPgCCd3zp6DygGoAUUfzbjwIqKQRBpQCN4IsgBQ6qvjREe6GaI3GqobqTYblqVGQiOQNupJ3dNwQCQST9tJkyu7ZkMXe28E0QhbutU0uPjeZH+U4OReBdc6mpAAXxkLNpcgfSV16QnjUeRhwkduHe+JyEYwcgKsOiH42oSAdK+aWY6RAk2TiQq16dkaTCbc5ElJjtomouutdMUPdfPv83TskdSDdYpwr1HdMbF8uArH5aqSSCo6h8SK6AHJOB3f+nxdSR8CB9tY8+QGthlVzjPvjyyOYiNtpXXRKx/fc+Kf272/Lngghiyi0S5cKgHLhBBd6c7kNY2TgpHIT2JcUOPeKkXM34tVVdK2NyHN4TENJagQpZW3X7aYMl4jYQJIugkKiI/gRfSt0mRjtUqYwsaHaql2gB8a7j3rYNIa87dNbDwodjZ2pQ0lwCXRWtCoBarZgaZPUeQ0dcSfSQUQFBQmZMJXH6pS9SL6AEWT4a11S7pJfodJbhwTQp4UfMZI1/nIJB3AQUvYfxoOEybW3ZbinzUVIHdXb7Wx2xPMBtYFQCv8A51NICGN6dz1O0bAAl7puNSYzWxCLtqwosqLYqdFWhLOQPJ7WoTu/3TQnA/ZXp39Lh+b5lxobfZXZc5/TD3BYIjSOQP0ipt3clMgE0V+jaEb8kSgQwOjJB/M8sxk6oba8KA7aOkmUwqTDKP8A0ZvwXNdp4TdESAdCd1kIUIE8KlilXzA1wfdQQDawBunwoPDUCIO4Ctj4EcqXeCfxi62VLEBN1R/zr9dhpoCh4aUNx+iygBLcxzFFsw1/LJVP4I1QeNOkcqxObtiKhbnUC5JrbGO0ily2BHDRVIFLIVXgEtZDuB4+AqyC42O01CG+vyqbuFFgIc4aAEKCAOVSN3GdgQuMupS7XWRNacTE8jf3jEQ16BACUVBavbPZvYPbQcvKIxIMeNqjKuLmYkhgDjej7n75PE+X0wn/AE+S3IwcPIAD+zOGheKcqm7np3zkHfCEQGNpFjoSSFWmOlR+PLD3opDqsijUHgajGQ6DZYzxBdN9mucmjxT2+mmdEYRDGoA9IBccQooKPTJ0QtjG7vhAqm4AcSvhXYhB75mHfG4SBsWqlSiBaLTIJHS+crEABKN+ZKffQ3sfEIfJOw/FFJVVIqNrUcVW6NjO08T4pQY/qcD3NtwhFjcIoIFPMLlZ+Jr7EIlgoNuGtdpQ1sjPMiVWwbSU5lHJz4V535URgaXwfiCEBU5mg+R5iO/00kuQtuDSQFRrRyRayoAVEU2P2SCHKg/xepVrRwozeRlQw2bK36CSv4ggCofGjCP1UEc/eiILmK4qNqdJ2rzreXmK3qZYrgi6DatzwtejGZyi9+KQj6lFxpcNHzqMJCpASRo1PG+hJpZXm9sWFORUhT+FyVeLtF4MzSdAttQSi3ogmzbWt42topoQmMNUhzdHEXNl/tHnQy4+xBi98iZ5Kg5Dl2kN+r40QIP1ByCPUAgYACW00KhaDN3qmrtXgPiu35c6xYg7UOc8E/hS5PIjTWoRBdwaQAUQElAUQbhWNk7iDuKH+YjggChRUMtrFy6qjQVCoqisX8S2v9QuOnxT76hgiaBke4ZjMHFQkXc5oNuG5da9mlaSMvJeH5YB6QdrehUBLiST99BsOIdgWz3Bbi5BBHOoyGByhwKNvuQKARcgeFe8sA/9z9twXe4YRG0HbiMe/Uhbp8ablI0HIYmWFCtd9IUcyda9RclChBBRFttFtKW6j8N9ea6G1ZEE5G3/AHQo3KAAEBC17x7fkKfTH3HW52uFha6i1ThVBIKjmluYCfKuJJ1uoA/4vlSlxGnTcLexQJwGtAEhqIhPFedlSvTY2Mx6auUjcBdSSAoH3VjZmfjxE7XW5/AfSEHOne34GKwQ4/SoFmhqKWoFJU1fHfw0aCq8NEr9TgAtJP4Q5OYJRbimh/tbAiataR4Fvw8eNHFGJG1mUVUtG7gTbxNTz4PtsbTGCNqFr9CNR9SpWSz0zQdodvYHIG7iU3J9KVkw8FS5vwsLWKqla/YaIDXKmrrD5ILV/MRYC3Sv/wDTX+4SgOp3JfxSrtCG2gb4IhAOlJdwQqV0RDyU01QFsllJVAumgSiA82sQ0AHw2kaLxrloTf6QLdK2APGiqDS5GnL7zzpfpIJ8VRLHkK1Q2VtlHjSgNJc3qIQW4IguQ74UD+Zbkl3EqeBtUEu/W9gD8BdRrz4UyaUm/EKVXxCkj+Ff5lKBNFA0zFqkdS/T4C16KwCHGx0J3Wvou1upt9lRx4Tx2UPqJolKXFmuKlSChAoMg3GKfUAuJ6eDlJNRnJgAgxwRCSlwCBuIcbjwrHYADCB5D02qhJW2qKl6MY4/moenkUVAqcqLgA130hdXAKFKqRUUZj7o49kD1BRTuB0QU6LJlHZxwJoht/xOmvM/GsiXHh7YcPKFgUK7gCh1oNIMUU0YmKT8R4WCkijPismi7P8Ai0srsmyAD6gCfHWu0JCxku6YsNxoWg69QXUUwPKOe8wsn53VXEFWinPewTmaITRkEWc0o5wvo0cONSJJOsQbfTy+JSwRvCgVTGm6XzgbbJcOhC3cQii9RNnilyMqMz44yMrID0wAB2vbuw26ggFeXGvb8T3TJnyMf2nB9FA0JHF6UFWt2jXTjpSTSGUdgenB/KAAQNI0egFAY5xmy7RviIs0E9RGvD5VHFumnFkcT+Y42PEFu2p4Vl3C7oxLrfX5JUcfrSYuyAGsJQLoJi7W9SRTuR0s/A74V4jwFtahm7RH4ZWkp9FgnDav201zmNRDujAtrqLIEqd08RkWIdh0advHyil5bXcnyqR7mMgH4mtCXH1GSyXNOe6GOPdD2fTgjv2uM0yhWqdEqd/bD+557ncHCPpjhLVAGi+NKsEkT7OYfuaIzfjTmuM/ddDZxiQaoALWaPCmNOqiIhbnaEXVXOAqWZw3uE4jDlV1gQFuulTdydHs/Lx4tSp4pzSmF7S6PYBaHupyKkgtQrTpWjv+b0uUo0yA2uhISk3AsaxI1UOER1O0qhRfsrHjQz48j+gi5hUAbWrqeNAxrsEKSXFydLarfnQvOI9UvwsApvahtUngl/8AZUhEd4/7wHQ2IBC8VoF2v+pvbiKVptJ/XYc6kJlmLnObZSS1PBNKS3DuHQovPUa8KVVU8lI+JpHHSFHHgD9Q04kUTuPUXDtBS76LFbBF0oOed3kAdom5O5QXHU07b1FkR6Ige0pOqoSbGsH3qXEmyRieoZLBAkfqcaZgjWAEhCEXmtO/afsOL7g7KnMGL7l7hmYzYB6Zke1sBPUe4CddSBQDo4XZMgmUw/S1LlSVVAKibBGAOxkSwtNwj7yoNEC0497G2HHa6KSW7DMwoQCbkVkOexSYhyjcIxqeIJ5caexZ+2ydYpyRbRFBB41OSdzi7yzGf8SNBu/lKfwoTBZoJjslbJbt5RIChpUhoITgKyGzSE9rV5QopsCSi20ot7gYUh2sW5G5dB/51FGBsXmE+RPEU9m6aXaNxCKHK1AEChBTsj2v24R4rwevKPpMclSobdTfSps6XDGRhYrMdzs2Fx9PiZTrBpFi4KQq/OpYc+PtvlAhliFx1Ig3FVBNdycm6dojc4YrVHSmpKDTka/bPsf7f/Zvt37Wm9p72P7zl4Zacb3fIghDcXObjoHEvN78TRyjAInIve4BAoAYFQH4JUHbhcMqLRkyZAKq2wFj4LpXpi+c3JilP/TdSlqFVBWiHRNiigIlhk3AbnLx5By125JOdjY+QvAEkKnCiX+ZyjP4balVsFohovq62l0S4phUjw3FbG6kcUp3d3Sm3SPG4cGgkKnGlgU4Q6eypx9410WwaftowsnJkUborAAW2gBBwqIlNLoORDSFQ2CciL1jTOhVoLVSwKoBpdDQ9T+QXBH31uAgCAVitx9HArZEDip8fHwpqTeqmxACCm5RyG7VK/acOcSIcjOYU/DaRh0Gh++vb9zWuO9obikDb0hqEIOV6ZIxMUOTzHlAQRrtVAT9lFzXN7bDZGgg8SupBsTWeod2cnA9z7RiALge04gO4bLfCsqEbQTme5BqABzg3ONyQbAJQS4RqoFbpbQfSn306bdZpACLdSbG5utGKW4XVCFT6fggNfuMX62uaWqBqCvEc9a9w2iwa1Tq5VslkItQaWHW3KydQUIi0AdrnOdcoAtgnEAAN5Vj4EWOHZJIO53U1LNDWp0msf3b3eAsY1xAkLChPBqH6r25UYcbE9LoAGgHpbY6a7tacPT2CFqga6cVKlaTsN6l3KQo14G5BdpXpTjOANyEI/FZOFPxsnGslmhobxVCoX5058+ODjYqlCHC4KNQ2GgrHxg49ogq4hQDoQ4XGlZeT7fgtd7iMDe0tiBPSdyna3dXueLnQtx3YmaN3S5oIKo1qoLNp/xPHxPGup2h+XLxpR0rf+ynKkc5CiA6IvjwWkvtPTcIdLmxQE19tEwICbEglQEPAUNSE0TQkKDe+pppVEctraafFKBLju/CvJOocVXxCVYKOKm55ovjV2qnLhwvelMu23C5PNwCm1R7EUqAFtfULdClMEdpfp3kDRUutQRaNBBW448bdS8qwsTE/TmRvq8idECL0tDbFy1GYwMZpA7+Rz0uRp/HWoJsf/Cr5I3IXZSIjgFuRe/Chln1fYgcQf8Ap1dyCJx+K12XQo2IK6An4Fuv1HitTtLYseP/AA8A+oEKpKcmnWrHqO5bWsEvyVONAnzHBd3wHJEuEoSxTO7uoS7mnSxFx4UO7JMHOCkWcgKKNdb1K7G11l/lQaWKjTlUoVsjYj6jRNoRDZFLaEG1fTknHQ/VjlbFb/iTjpXfx44GICJbFsWLb9SnFxty40skvlgII0QpINb8F+6g5uPBK0BJYY3O7akI0h27WooJPUSzscu2QjscXBZuYYUTjWxzSrnDyACPquACbhCbVIyOWGKaItMcqLMTYOBKXTnUDdpa6ZSJCFT8SaXX4UIumeFTNA1wMRBXWy7SD8FqM4+Mdz3FhmJ6lNz4FaAM5jbEPPkmQBGhPKII6lCV3sdTDL17yDwO0XBVypRM23txn05JYdbbS5NbmoxHF5lmvhUIYdXbV4g3tXca/u9sDc1OYKIAostASxQ+Wh7bOaBN1kO6iA4tdfts26ypuR3BwQVGZXSB8vqCWEL3XC19dEtUAeCGkd0Kvb7oeNV5DhpTJUcW2ksFikReHFAaHu/ubocf2eCXtMMbC7OllT8m5Db8DdBUmPhb2SbQxoymiaNddu4EI881tTo+2YezLNHJEQTLjFriNOZH3U94fG0yv6n/AF2lC8ESx5LSh4ZuTszp5hIVG2XU/YtSOy5TtyHpFFD0ntEcwUCLenZELJNhh9KTfHEfYKhF1vx504mNDkM70qKix2CfGo3s7kMDT3Jdikh4UlOAtrpUfadYBHAm9kUk8yaIRQo7fOS/JLJR2xmJCA+6kBbheaA02GFkW/tEhyj1M8p4lNRXR4bGnw1TVStGJ9rqnxTX7alAaNxvZSguNE5Coyy+76xyJ04pw8KSJ6jkbLz3IVUUUH0vQyEiyqUvfSnY7S7ZDuJa5RqboeLVozZDOwx0Y7T9Gk6IQBYk86LoXAsb9R9OQ8EqHAnRBT+qAQwkGR28g8+lNTeomSSCKNxyZpHNGoivtTiTamzxGCOJQHxAdTiTqQQLEoaxs93bV0xYkWOerYu6ztAh42NSh5b2y53pWugCYokUgkCxIIXwotOMMki3a3LLOUI7zGDreCeAqSNsM0ckXbliOgBcvUeRBN15U/2xv7fhk9/mnPqfdAQ/1EJkNxub0/xtU0z+6TFMO3Ja5doNvO6VK4psdqJdSikd2/VRke2HIfs8rYpON2+AAVQKieEchG9zih1BQDhUeLK2eTGgcJ8iLGau6IAFoJCAJyVaww7EcGjsQQ4cDkGT/I4IEc8W0CrWPjPwndycq+KcfpdoX1Ls7EeoIYDbnWXhwx/pssMyIslCQcec+W0BNNzOdDtzGMY578pI/laQRrfcB8FogZE8fbIm8/bBY6bboQD/ABrtRNxi+byZpNR6YhHX/CbkihDj4++V58rIAcuKNw1IFl1vU0kiSyMnIj75RbaAog/rp7HrCDaYTklE8PibUZYbIh3G6A8+QSi9jBKpBBKi978TT4pyI5QFliUcEcUKqpraQUQBVQgcgLqp+VMggj2vx55pPWWGSRLD2Rh7bgNtQbkXVA+5CAAKl0BUUT3xKUO1qhQSiBdU0WseTEzTm+Rg5AycYE4OBlzj/wBw9tQL8FKpRSYtbwx0VF4KOCimy+6Zqo5Bj2KBFCqeppA+VRwYDRhkhMYNc3atwTxVRXnZF03WU6AApfQ/dXsOc3I7DsXOjN3AHaXtI3XsK9nyIJXZByMVpBXzOloUkE2AJ+KVjFwMrsgfpAqnaFFw4dLQF+yg0ZAyfRq4N+oNc4nVE29RSveMxmR6bP8AdsST2T2yBzwAfccuNxc1gBJQg8BpUkhchj+sDTcVsNV2uP8AXThZCAw3te6ndZBWTOP7sgbi21wgB+AqOcr+mITRTb+kiv3GcjUl1xqOkprrblU4UpkoioqAhFCG1MlmcAXAgFFatl6TcpUEMOPsF/EAg24rfWofdc/Hc3FaWOdYEKAHG5ChUtX+X+343pcbG2taCpRChKlNypwpbtDVCpxLuBRflW30x2gNO5CAbgG55pR7OIPTldQbXQBQeZrM0SNN9gTfha4AHKsmFmOXQMYAZC0usqkgoQbihOYHqQBYAFqhQtlJU07F/EdjkIG7au5AUulenyC4e3ZALQ8NsFBBYSVBF69x/dfsnt7/AE5MQb5ZJ3EOLnFBZaz/AG78OOqElCUOh/tNOtIFcCLktRDxGgGtWa88/M5fBa4u0Ea631UIFQ0xCv1FSeRC6nRAaJLTfcikA+N9NRUGJAnemXFi9URhgsALihJDRYFLioNsxn3OLU4EgoAtz0uBpqBLlF1KfhJPC1E7kVD9J+46CnbWptNi4pc3RblyJRBeHXRGj56/OiguPFf6K2A6dXULrZUJ1AWkPmSjgLBDZePLWsZ0koLISE5L/KAiLevbxLPaAOS5DUCgNGioPlWHinJPbG25ARbWCG96ycIwO9c5MoLfUIoHMgaCo4olEMPUYNHdWtih/pqJSSY26qjxZAAOaH7q3lVi/LKWbrrYqVFR45jOO7sfrpMVq+uyrpt3AJalZEkusRVLAI4FoQBRU5avqXp5iFQ5R/ZGlPkkClBpcaIVKHU0Y4lAITXUv+q/JKMRCdoOhkiDUCEFzfEg86jEbEuUH9kkohVTYVI+LcO1YSzlUVdwLUC/fUhfCDLDPPBFNOSdVII28F/jT1i7SWdKCPSiwQbbkOB+VCOFJojkAceJJ7ziLAlbU3JcTJkxeQN68bKGnQU98zeiZWSxxAdwqSo4gKaikdEuORB24tJsYk2BQgpb7KDmM2Qz3kjyADKNR0g2IKLTY2zEEN8l4OmouAPCo4XQO2yTgbSCCo4nwJX7aDO5kRmUHaIUeGgIrRcBKijGMEmXdE9ccloK7rqR8eNNa1ncjidt74ucNAhYly5Rag6CN0j0SAoRi3F92h2qVqMhpe9zvLinWSKUMXuqQFaG8NKZLDFK+RrkaZYiIgNDCvDwOtPCNb5g7Jf0o4fUFst9KSYDqSONLlbknihou3DtROlG0W1Zw11rEw2TDdEZEKjpmuWgg8SNFoEMlf306W3uuiKvUOOlPx4HH1McDPWFbCYbWhTzQ31rql7jAe5IWi3l6nVFIHCsf0ePGiEunIJtJZESpVjdK58LUEEwTULf+y37ErCxps8Ob1elsLRbw8ibdxWpJJZZw1ZmDgkvhuARSnyqL2vBg35ckXczMwSFEKINASQ3Su3K9RKr5lKTaql0AVa3s64yhjO4B5tcLrVj3SAe4RwaT42KU0gFr0GnK9tFASi69z9CldfmgpnEHXZz4KnKtQJHKO4o5H7bUe0SqrKpsLrqddKeMhzI9zDMJNT9ilwJFZ8UJBikWFQ5yDROIPCmLIXPkXe1R5SNQEakj7jXbdGNo8hz5Du9TImpG5QDTNshkEh7cjdPzDoADwSp3gWibH3l6YniPRFsOVbGSGDvlFAUWSwltwOvjRaB2jipDNLJeEFA4FeJCVjOyZ58mbvQMi7aCHKwYvLEEwaiFRdENTOw2wuLl7zST+a4fSCosdK9xyZPbIPc/cpsLHj9l9xEnbl/aeYu8yxNAIyg8ag1my5EXYyZAIwcdI43Tc0Nrm/xrY2UjtQl0oUlSBoANd1B0yu8kPAVZEUEDgFSpe3gH/0bOP6cjQrqS7RUqOVW40+Thd6IFF9NfhBbXnoKL5jPp2W5CEYwy/5dOJSsuIS9oRNM0RADQZ4CpapI1uBcqDWJ7n+7PbPXe1e1QHIw/bjk7V9zySLhQ7eABpwr3HOlh9HkzZG1sUKzjFxXOLsVSLOclj8KhxcJzZ4ofbcOKaRxX0+SNbW2gg0Ix2RjMhCFqg5UBOu5dSSo41NDKT3Ol0KkFykKQRY6OGmlQx2MsvGw/wAN/MCqActTQ7cLYocs7ZstpP6lwACIV2gfAVI0S97qA7YBtkqhKak+NJIC6WUAFjlOT06IFKBaxImnI70qpAgUEFpO4i3yNdspESSCYQUQEhF0U0/ug6/37ifG5UnhUePDiduc6TAAnthp3N0X6hThFbulSDqoU2Pzr8oqgVw18bHjW5rnjTiVQWFuAWo45DBFEhw3CAkIOB2j6nEDWoINjbWUqQBZoG0XFhWP3pQHB1gpC+FyRccaxMgINrUYCqA8lFlU1irMAgBIFyl0KjXqNYwK99LFpuCHBzCP+KoPYc9rMn3v2yRMgbkc9ga0IA4hSDwHKsTNflHvu4udYA3CNB+gA+Aqf3r9xe+e3YjMZGjrAPujnt/kB3L1FQlqHuUcfpfZ/ajJg+1e0t3uBDzb3Nym5LW/JaAVoJCl3IXCAnW9MIaBjt3KLIt+BINjT0yLKFXUk3IstqnlPwLWhAShI2krU4Qfqt5erktcqblTWXKl7Fq+C2uiAC9teVGEoihSFQdS7lHULlOdY7ruTaAV3FFBROIQpXt7RjHHdl4bUIKndsab7bgqax4dLakaLZUqGAKAXEpbcTwK+K1vRAhGoQE7US6kgU0FQqbvxFUAVU+kV1KdwILrdXxA4JWTKAQzqv4hwG3RXAE0mSOSIel3I3/ClY+bBp/MgdqQUB4KDTnA9GoQ9O6xIBfqOde8YZxnZOTi4bA1zSEKOdsCpu1N0r9w+1vxnYpxPc/cGncgbdxGpQuAXSvq+m/9k2Q3PiPspSU1AHJRtOmoU01hLgSVWwUJawvSA3S19QtzfS1fX97f6q6ibaEl1iiAkqDxq6a2LL2+Z50mvwaQvDjXmp8wgUagEBOFElrhyIBKE2HGugecHG1rNQfVb+k0QCOpDrZx1XhZ1IW2FrcjrbwpAPMsNFaVsqcdKglVBFlEAJe3gfjWKLtKX4kEm4GoKk0s15Qh3EKWE6D5Vh5Ep7U4I8xSbcvBU486AKbz+rKKDcoC46KEpdSbyOJ3KHIiNIRpAoxxxebqQQoQKpVULhXd2pLYK16EJYqB0gBDW0Ay6dsr9hGnS01OHAbABDHOitsL2IIPHhWzvt0u6EW2kIBxOn31K7Hb245MfsiM6uDbkkqqqNbUBlJIiBCLmyAEhTtJ51HK8QxCMfmOVCTf0gA08KkxmyzObn8ztLXPPSb6BTevTeqbHPHP2fdIYUOLit13DLu045B4LWTuYN47BgMDiW5ZLgNVIba6+FOdjRGKSXIVW6ZO1iEJwT5C1d8ynv8Ap/Ud1SF5tso4JUhEbo3zOU9lxHaNuDro468KllOXAvY7MyN3DKIAumu4LqKi7biD/wAqc90dwcimiaVE5o7gaFmm6RKgNkYL2/hQm9WY/Uw+o2puKR6Aabb613Ij3j2NXacSt0W9Fz1LyFEkoJtazALpyOlSS4ygRnqc1C90pN7EqgXXlTjL33tfN2T211I3bmoulF80OK+eVhyXPkQj0/0hy8bjhelmMByJe5HJ2Ex2vBuJQlH05Y6IOPp96SAx3JUnjr403IY3btO9/euYiDoNRwp4MUcbZlL+8SxZdFB5EaU7L9rzGgOewZGESDHLsA+nXVdayoBLD7RNBAGQvlY2WXPChnYiuUsbaGsj3Wd0uXHJ3XT9yTfNjSSEucJggJBdxqOfuQwAawIU602gWNitNgMnU4xqI0MaWJiUaD4VHoyLf5UTV7nWoLQg3ITao2mKNkDEET9dShiNyia0Mb3HIjLMYd+YkocrGHVE2KybuHOsyXH8poRsLVH5WggudeXGnl8wa+YiYwyXmxgwp5pPEioHMD8Z5jG7HfJubcqoJNy8XtUTZgWbfBAi3JBKH510zK4cAOrUFCOCgUkIJagElkHz5UWRDjbhoaHqZIYVJAKruBurbpepIMd2rXAvJOgHA1OzeST9EiHQBC0FEQ01z9zQs7nNQm6eKWvzpisM0skN+zYubrtCeJra7uMnf1dk8IRw3XAP31567L9uQM4eG000SumdBLMTC1x/xImsD2xwCU6AgbI4ZDGoBkadEGoKaJTWGWbXaZLen3WJEwIUlONMDJVPetlOAAaCihg0Q/ZT5jkiW47e3pHdJK/686JM3a7npzIU8xpPNbWWjHLDtHecIslhICSA7QSqE3BXhT2mYA47vT2AbuAde6q5AakYL9tO05VBIQldSTuqSPIjmAb5y8NU6kNl4LUk+Qsck6Y8MEDnEOxUuhuGofgKMESNagQGATggEFSTppfwqWX3EBkEoHajhA3AqE08b+FMyjE2aRsgHc9S1rcU5Fm5Z6g3hpQcMuDL9ybju3R485dvI+lzttghv41J7lnTGV+dO2SQgiA7WlGtAB6Sg+dSxMlPolaSHFq/8JuQtb37h+oRGr6lGg/iCNQg/bSdt0gJcAVcMtoNgQdFA41NFEHI4dnvZCoLKEW26yU6TIA747E6HiDbTU2vXq4ikhcnbyCQRiuF0Px415TLHq3A2CLdVW6U+XuLdAASA1bKE/pqeMyrtIJJPioF/E13Q4F2oVx1QhAEIppRQbqQm4Le+jrUj+KlBfmif6/Kiuv4RxOiAX8PhTO4/ti/UfvP2UHY6hLdRtz15ECoCUcgCBxXUBRa4CmsZgyGpof7LXO52uDQw+80jHsTwJADk+BWoJlvba0WLQqDapu1wNe3+6exZZ9uzsZwPMFEsbgIeK0cPB9v9hxcj0Xov8xMYzXKSVJV67j8LUPcv3T77l+6ZTxaMN2+1AhGkBg0QDlY1YhLhDcWVQXG4ouTqT5cxa+hWgFTiSb6k8CelKyyJgdOoEXAS5BQhRyrJx/UAEhQAFICG3C/VTYfUB6BzQCgJJ1F7aVldXAptuLg8uFIS0KCCLEjjY8VNe3k8ACNyOChwFwpBNe0OUkOwiTuvu6AVQ2HIVjOF5DhpuABsSVVbHlWK7JarDIDqVOhYVQAC1d+AqEu0aAptI0IVBT4SiKncHM2IKjcgFOx0EiDal7KNS4ogAVKCYrQhOpVpCqCbEL8KxsXHxWq67mobi6q46gVj47U6i0uLlIBJAR1um1DGDSpAc9wIbtIGnSCGjknzr3T2afD9U7J9vd2zw1Uo7RCOOor3VuPjhoyPdpfwndZq8gel3PWshwup0ttRTdLNCj5ijdv/wAvD52rcwaWVyLZQLaKhrUi6IbFw/s2tej5/wDBb68KAEjnEIfxFTb5EikCj+0SgJ4gpoFpUT7U5eJrXgeLkBPKwpSfH42+kkLai5vidAF4IFV2lflhE4D+gDnW6UtBAT6iSQbNPVZPnUJliddQ2bb0u8fAg/Oo5IYlKKnGzuC3vxqAyjtPhb1F2gcXbVS9RPORewLgUCkXW2hFdoOJiJC9RAPUllu42tagYyd0PbgLckXUhBoCSBwoRMdqAJ1uTcENaDqRuv4VMbfp8rgdRt1sFc0GiIpbOJ679SFXKugS1M7c3YQ+pIF0CoQo1Jps0xKWdfQBTdwHT1mpTLF3GhOw/HBAHBeB4XWpMiPqMyXapAN9BwVakDZNvZ/MjKC4ai3vrSPl7gMpMTXDpVLkJyArOZG7uviwDNMAQ1MWA2IVEKjwJqKTvrHMoj70+4uC33KUuvGjG4mJZj2+DVVBqqkk28KL5STB2ceKWKTohEuOrFIahaD4c63RsdCtoownT29Ywbi4vepXYjUflwGy6Y0WvwQn41K8+mLWQCCOUjcAXAgjbxtxRVoGKQGH87s5AILSRdbLY6UX9uGN/Y7kq2FiVMQHDwowQYvezswzH3PKkWeHtawx4aKMdCVQfOpWOt3m7YHEExjpQOQIiEppUcsj0bDjgSDjxTVdFqJkU+OmR/iYiNEuHKNA1vEVLIZzJNZrYbkhOIIKWHGnshlPaDeCCM358lGgpsmeZJBECjUAii0AXShL6ebo8yFf8MiIoA1WhvyG9YcPTkHtTscpJI6hYnnSDHEoiMSOcd5BcpIWTQgVGYXsKzKBdcaUBZj4kjhX/v3uJ9swsBs2XEQHmb3CVEih6VJG7XSux7ax+FjwwOxjLHH/AHAeXrP/ADOeBxWoszY5+MAgjuqhbrytzpr34zR22d8Sr5Qim53UIPvp0j8dszC3bDKQGSxv4TDiGilBiMEjo45JTpJJ8PlUrnkRySHfGh0jhUIOQSshrJw2OYgtuo9V4EaIL/Gg/d3ciNBO+R3c70IbYXRQeZoHJfIkKugdId/TwvqEFgKe984YoNoyhI4GxTW9dse5mEGId+edHHtCREagLbfbXbHuGOYJAO28OvOCAQ42Up/Cj6d/d2nY4kDU6kh3wqRs872dnqMcSqAdQwBLXotnnJiPW0j6idRjuUgg/ctZZOT2sfDb3w2U3lQJ/ToKdktlBicBF2gT3MaQglVKEgkUC4y7BMSxpvktUWcQNWnlolWSFJkf3/y8gXXaUsp52qV0Z3vaNsWPj457aBUFwfqXnUUcbBC+WHH2Cw2bSqBbBKSNu10yvExI2FzbG5+lXGo2m5QCUNJ7ZXRdACfvoNmbPGIgYY4pgFPHQai/xqMFsId3+7CpRdVWMhQQKMuRF23ugyFVvVluHWCmoIF6hWOcmMgRNDtuoCd4cwPuoMEWwSpD3nuUEnhcpddalcEaMT/FOA/Tt7Cbdt7qTwNY0WUIGZ0kONnR4YyRlY+V7X7hjjIxsv1alHXFjobV28aLawr3fUgn06gg8N1M7RgiMhMJQghyhUNl2utTZLx22oCQbauTjpXvOZ+8vf5vb5cEGLG9pmyJIMXLgdA8tQtdqD95p+TiSZCStd2IsgO+lriGqCSjNPlTg3vS7b7X6dtb9QQVtvE0JIFJ00CgcgeNECKGV8kBcz9Qq3G4qtinz4V22XaFMi3UkIbnRK9t9uxGGb3P3XLx8DCgk/6lz3BianYCTdxSvZP+4v76yML03uGVj+3y+14zi7NxTlq7CQ7QxyNN0J1osB7paDAtz+lVACQdUFdqPQuABHC5XxNhxqb+bTt2XifsoEgEooNkAFrA60Ns23cerVCCtybga2SiORItprwSiZQQ/ghCApYpxStFRLhBYC5FwFphbIQQVLUFwbu1QcPnSbwWqSvySw1FKDdoW5OoUlTcWNDGM4XIO5FQ20GlkSopv7hEmS9wnNCTWPNOob0ptuQCFBQIf9tBeC9f4nX57jqaDgXBFsbcCpRQAD99PY3KBCOLbBt1VtigWyUCckfSRcNs7VCnE0EB2hdGjpXXQjchrIEBsACoA5A8SlqcMfRXK4tABAVdf5jRgGSROFDiQNUK7NpVw4VMRk7iAgVUaCgciqGrzpfwoblLEL9qrTDYAub/AK8EtWH/AP5wT4AgjiUBr25wP/RLwKNLGra9rpzWsUnGVvo+nkQtj4EnhXp7BUJCE2CaKlIQPT7QEAQkAhSSEChD9tOygdjVj4CwAsWtGluFWTc4qegEEi40sAG2+dFqooYiANAUfTeyFEoT7kCnQbtw1cp0ahCGlI5qE6Sht0gpZKha7aqB8iIB1c9VUVlzOaBBiYTmkgAa3IvonMWFfuH2rHndIcL3r3PDcu0HdsDXBiEkolPGiWAHigU2FxX0j7TW7j8/664Hn4/OrpWv3D+qtfuH9VWXhb/U0deRT7rEeFDSyaH4kfwoW/Bx/wCO/CkC8wlrptQlNFFYmVNhY+ZHB5zcDN/wuS4IgUKAiKh+yg6WOCI+q9R2ILYzhOo28LAWqOQznGsdFcVBtYaApWyUeobODuEtxcgBU5GhHlBRsXs8eI5hQeFQJOYAZMFpyHJkD20Oy9jpHAkBwY0lxHIVH7F+yPcj+4Dh4mBJn/ug5DRi/up+U05TsjDaC53t/ZJ2leIr1GQSJAASB1WNkIsSul9daMxaFC9lFsosoK6Lx50hJ8oLMYVFy26qiHwqzWmAnbunQjqAXqOgoYkKdpdUHiQvAqdK949y96dLL7vC7GxvafZ4CDj5Kbhl5uYTodoGlHtyiAAHIgP0o7U7eTWi162gH1UsByN0xCgNJ0IsVA0POmPMssYM42gqWgkFqeO8Gvc4hH2sjKnxxJLDCPU4rYCYUBJVzXAqn3UW9oF7vIijCbcgkHz3Eq0FdajDmN7cXpxLjwHdldouduINrKfsqWXHMwiYPynjuAh3QXKqm5+OtRxuldEYykxgU3JsBra9MiYC8unEj4wrRimABUHFpRUrfHFuWIqRCsJJKOJRLtFxUboj1NWLKkQAyi/b3XUoUqFnb7IUgF5vkgL+IKgHAVEuj5uyAm3zWhV4EIE+VSTzzdUPdnOrw5T0hoKIriPCoZsgzmNylbd1Ap2+KnmbAUGnHmeZQAJABpuCWAVE46VF+4P3flyRSe4AS+3+2YuK4GGM3847gepp4c6mz/bJ8Z3thxzHFMGGH0kw4Ze1QSRpTMWWZ0r4shJu5bcGAI4Wu2oPacqZmBjZJ7ckwJkONGEKBEs5L+Fej9vyofcnyQmXHnYEj6UaoY5UA+Qr0k0h3xgrJGEiyXISZxxamlROD78QUkVNyF1ypoMdCjwC9UDgvLgFSu4WhzHkYzHmxCrcRaj51shZtanb26w+HShCrrRByNrbd2R9owRoAOIXhTcdxjkYdyFOxZ690m6/SLVkfuEtjg9jMIbGZbnfGShRydlpDbHnQxMGSHuPCvzZFM0UciNS9wpBotYkhiUtlZAAHdwXRdSlRNdt8zyXNHSpaTxS6cQKcS07YnlhmeClyQoCngKjb7hnTYHtwyOy7MxYu7IwAKrorXLkXkKjm9sjayJe25sH+FlAPa77t9zuBC/Gi5+2HHwyfUOJU4xA7YY3+zfhW58+O6EFZSOnJcpXu8iU4AGvVuZM7vBCJbAY5ACm3K441EGz7p5r+YPJQcCCLECpB292KX/mw+SHdoDgULhZK9O2CHExN3lAEmfJ2WV1kCeOtR7ijpincIO49tCQDxISnSvEU7u53D6j83GBKIYQEQLwpWPmaIh5UuP/ANNwPdCKi2pkm6UuNopFLt/C+m34CiwTKO2D5kCAXHe/s3NMkhkTuoJBPfpFr2SoHkLIBkqYbh2qEbgm7+qpp8keX2AZSQDOIrBrhptIOqXKUMWeXuyyoYZi7blNQdJZqAg1pWT92R6CWX05ChtiqIFAFGMxEh6CIREk+eUI5gqKfJ7pGO0fTwRRzkOxS4EgkhSd/wAr1ksgiDh38gYqlUxCSALucgUWHDhXZfGoIQg6HxWwItXbyzuxyVkkBviux7C5s4FyUTGhgCgaL6gmxcdR/A1hhkIlIhn7rSLTHW1gQjqlDod0/wDeidVF04jQLZK3OlO2JIZewTZqqN3MafKg68Ud1yTf1JA5KNf6KhYxga6M5IcpshRHBHDWoonA4o7Lu7oQePPkLVh+8e3FJ/bJhNDPuR3lAEALoeIr2L9p/u73HLH7M9mTO9tSZ2Q/JyYCYmnVQhJRdBX17XKSF/l14pqlbI5GmRbdkcVvxXpqSVVlJCC9iuhGgQUQbjcQgQdNj8q0spH+9ccEW3OgmiuI+acTevNsB0kg6Wsv21IIkRyM+gOAUqqm6oftruR68eCaceZqAEHtAdJUqSXDoKcVC1tYVfuAc0lHJw3W4rw41BOngSCBYhEOq2rGlQkfTkhqv1AQoif+VNwbkYzQ45IKi9h8SR/CtrSXAoSCp4ItgoSmjZrofsN9UN6Ch3FLhqXKKlDviTq0N9LaI69j8bVqQG2CuXaAStgup8KO7IOh+lwai8woNkrJgxZknWyEDp1AUHUmgMnIS7rhxIXWwGh6qAN0ICJc3v4kiuGtx1X0HyoFAFunAKRqpAJby41EmQE9YjbAAoW/SCiCvZshoBVGgodrljaSC25snwqBbOK4YKXDVXQJcfKgqu5ggkJuIGhspFf4cWRVRUN2pwBaStr86OK4D1IRxsUHMktUKiBfuoABLt1/A57vADcVCrT8Z1i1riAllJUlQqgGo8diKArnFu0bnXLdVQa0l9hcu3ivG4BcQvhQychSemxSynayyaOB1r96/uWQDHkxvZc5vU/arHEk3N0TlrX719wGQ2bf+4PcTivD94Qkg3VyBAgvwpTrp9n/AMDqUmwtxpeJG74oDtt/qtQxtvNI0HpuU1UALYN8KZtcGOlafRkIdrgCCXFUBBGtft/A/b/7Xy8P3aD9v+l/ePuXuOZ6nG95/cHqht989jRrfQD0ygikXQBykciL8OPGmFAAlv69EutRCOcERhfABdQmt6ZDJKN5Q9/cCFCjahvc0wkDH7XpYMgWIcCUAK2KrrThGNqHyigQELpw14cBTCUN0PEWJsqaWomPdJ3StlQmyKACgU66Wp3dm1HnI7cEOihVNETDph/6ddwe3mOZB5UQAIvUXCC5LSoKkqAaHdGrT02VyaKVJIsvjQjeDJLMekgO5ohxroUtyIpmO9GxgEh0DgCHLob9SnXhXYkjLJNsHdKKVF7cAeZWsedshmNhLCljkkqh1J6VqaVfI7M4id2QcZxyT+pCqCuFYCpmRxQNO0+pI1KDpIJ6tpGvxqLtdmKKIOkM8wI5j0YTQkaUHRw7hCNsQk0cTcg2Ju6nOlIcVSXst6sTu3ATVxv4rRx4J5izGBBJiEGtyVB1C/Oo8hqDIA8oSqRlhoBedtrp8axMibDLvbs6GY42QcfqXdpCNUX4aLWRlZOW0GUBokDQhEQsEBRtvvrdE4SMEAmSRp1Ko21r1E708Er5Ssr5FTGBNkA/jUz48IZHucmV3/8AMZ51idhBQPbWwodvfAtXt0Qy8dk0eK3tmXKVmJloBN7bOCVgA4V7k3NyoDN7jEW4eMZ4pZMmTuBqmFV10twqWVoM/dkyBLI/SLuC0Z4AtKAJqtSZjBOZnOxY3YsxU4zbkEFpDnAp8lvTZ8iOZzHiczSj+UgNbhi5VOfhXbbcEDb3gC4W0O3gPvrpkZPOFbPJGEAun08GitjhCHOYXSTOKhQNbcUCVNt2Qh0PcjO6yAoqniU04VCG96RRI+x5ICOYCmgsiQgCwRxMnFTw6hxpwc3cwN8xz9pCJo3RSgoezM9wjZ7bG2PZGzHc15DLRQlTtSjMQGu85siN7pUXQeC1FKIzK18Np5fLx0tw4OH8aiciwm4kJP6VyBSVuQT9lOBV7ZJJHTpISEBJG1LohWkEjun8riO48kog5NC1j9k9iKLyyYLCX+YOBQgKT8aggEfcDAe6pQCEqbqQoHjU/v8A+4I4vc8oAn2rEyQxvt7BvPMHcQBasHCxG4UfuOZA/IkwWdrtMjIQyTtb1MK6cbVjtheJJI1hdiED9XcoQR9O0aU5Q6SDs5CiSY93FkOo0sGjgaXtTSPhlWJ6hckFQRxs1OFd5sc4Mpcw9JkCgqJYl0cDUsZhLzKszpCVkl4Kf5S0XqU4YMspSDIlTgdbXBX763lkTh3TJjRhcdOk6kWBX7algwscxxxYLZ3jKXILnSMd3XE2sJfmKhbuh2ADvNBT0iAB2p4+KigO9340BYDjocVLDaz+1w+NE9kSQ6u3DzlsR6gAIAptavMxuys4PqJF5EJpuRo48aWAdyIHsN3tcEPTcOACtqOKQmGOxkn6WtTUhAdwQ1Ju8mwBkVUKJ6tAqAp8b1HGChBIiKhCost16gax0Ji7XqCLE42q2LtxcE+KGhjRflzEzTPugW21ACAvxq4BjtBv1DunjqF5U+VEix1ELZ7ZICpw5/bSuyMnJySGnHgQINQ1pWxINe/50M0MUWGYDJHl9rGyvOAY5uHihy5JH3U+KKZg07SHoN7AElGkpegSYYvJEOqkmAKqnVStI0Kf+WpCWUk6qi10y7mqFeLDKJH0kKjdaa+B+RDjZch7sMZJ2oeAJIaLcqcig8CXcLa/2rUEaWuICuBupXdcDitTRsu0oFW9wlx4UNwAG7lt4KV+VPAV4A3WsuyyfGlBsipqR/vJQlMCDUn4gBbU1HHxbcbgPA10Ej+Ol1Ol6+vr4p9qaGiLBwFyeXT9S3UUdxBa65W97WdyUUYGgtseoLZt9V0ANhWO1wbcNvq0q6zlKAuUaUuPlDvaIPpHJtzZPjaiX5Idxa3+0psTcEgqlEZA3jVztwBIIKKFJN68vK7GPbwAYp/m+FZMePkE6I9V1CIp5/dWSYcttw2+65HLU7vjSlNbBTfnbUAk0S5b9K/SgI0Q6rxoEGwNtq3Qj4kVdw46AhbWKUXqdQ0J4krqruNY9kJzFuQlk5VDi5DgRjPY0pd35YAAaQiIKzMZrSpVCCSgIJQf2iOHCjFjEoG6/UDuBLb6qL24U7HGMXMGzatwHBAq6hSK2KBZSh1TRtrkONAIAUL3AEWDQVu5RdNPGjM1WrDucSPG7QoKElv2USLlu5HEm6tS9lXabUNjXB1nNLh9PIqnjTsbeDkZpDXINxJBCWIQFK95/aeN7ozG9790xcfBeFJTuOc5wtcggcUHCvevc5JzMzK9zy8hkjW7Qe9OXFDqqk/b/wDBB/11pSblFHIA2K3RQa7sH6OaFpGPkY6OyrgNIcHdO0g/ZRau4EcftKn+0V5VthFgiF1hoRouhNF/4R0nmTx/4Up3Uq6C5104mw4IlFovutA8aWudbLrTgE2m0cUAcn1JwCIDzqPBiTqLSG5IDmkqATuB22Gl7UYpX40zwv6e/wBoJI3fKp0LYZXBYYHKCNbgXRUtUhh2y7MU4TmZQ9QCMqxQNNio6awpPfPWf5aMsepZAvqxi82opLQSmlAeykxe3xJ2PVgzZVruLukBDwWtjyDHGD2wFQhAp+N/vqVIu7lNCan9FjXQgEq4kkczUvuMsohecQ9n6dxN0QJ4rQniniOREDvM0PqEE4JChyBTwrHiMYlhkUxMBHq0nJU7lVeXhXou72WRCeVzwP1QcCRdxGi8KA/OgGgjJ7BJQDMQEJr86EcqjMxZ598rtwGZ6hC3CJCtAQWNQxFs2LEZe5jiIHtDKCbhLzbYoOK1KGSja1vqJo5m7yJXkbjuAQeA0p8ksuTHH3R28mO2zaSj3KvSdL6Co1EUb8hwk2Q+aEH41NwqL86gnljyO22b1OKosJoURRbpJFxxC1le6ZrMeN7Y8YNxfbYBh4TWw+S2bsk2s0La967uwdsxHuzoDGoUkN7uqLyvUbGESmI7XWSK6WHE9NTFsQlUBHroUB0KJy0rzWI+UeaoEhBKISpKBTTDHm5eA6QpIfbptuRmgmwcSDANq3OtP9dnZeVP6by5sjK9QLGwCDaiVChDg0k9sEAblQ8iijjUUMjO7JjHyDCB6l0eaokBsQ4glfCpmzIwQTHy5HWBcgBTnz5mneYSXEbez5EjcheR1aQKZixRzjIkKMWxyiApvyHPnUAyGASvLp7KiPsYTqiDjQkiWIgkuJ4A8xewQ1H2pSwXle5n5c242TXRDa1FhQmQqXwp3Xn+X+yE1pYg2Vj+i6Io+oq5ET+NeUULZh22z6ycCNLDlQV4lLlfOV2PxBbbr9RcPtqXut3QBN0RXuePa1uNfjSRO7sSNMRltci4uBuK1GjptmOSZrKPFthWyJHtll7yqGg2UeItSRx37/lF+llBBSxCrUrZl+gLsAJuBZpFtn9FSY/spZ2Qg/UBro8CP/nqChDVWszL9xzx7jkTSHdnSDuCcOJPMBrQTZLVHkY7QsG4ySkrIg0RQVN1CVLNFJkdsG8UwDDlykbUb+IC9vhUTm+olnHX6bRuJqpWy3tc0QSIRI8NjT+YOTYE5k0SRBL7lm7hkQnTEhsAWSA2JF6Ha81rSX7XWB2KAtwopjZ/yIj1xkBSQTKEOqhbGpDLHMUtMQgICEBDxBBtrUbsaRV/O9REkRvYG1y4VJ6jypo51Gw3KBWohRCR9lZknuPtZyf3Blbh6mVdN1rfSBt561PJHGX9z6F1Kg+FkPHwp0TT22iBZGhLIo0udL8673dypO70kLYDRQBfWpSoa1vBQfVgHUbtNq01YSx8pJMnYUaFAi/Ug1rfNlnzXH0QAHSPxKEUBOdMdFKCz8qYnRSSdykXANeSesjWFwdjC4V3Eiu2P7oHvya5GW4hF/sgOvWMohiCO7MoB9UchSGtP8yVsdD3ZGTHuH/1U3dLVFhRc9sAAckUlxoSqmxBAOnhShZOyjrdC7tETUBfsouhe4yPYRLazVXcE5miwlVm26NTaCF5mwr0pkVqbg8qFQKvBAK8B5nHT5cCPmKIXbYhQANOCkmwohpcV4WN+a2stbJbu8bL9nhVlVDpbj4Vr1EbfpUlb3KHjQYF4rcJqvLlR2oqIRdUK30StfDQf1f6LhR9/Hjxo8zzUhAh5hESgjTdth/vAXBVSL0oUBV2o4tb4Eqh+VIMhITcBoP1C+qEklErsBzRCBxaSCSCgXifuotyZDJdVPSg/wCE/hJodnLC3I4blREFlC0NuQND81JveyjhXenCDgicSQTZSq86BB6ksRtKdNr2tQIC8VdYg8xrYils8lSVN7XvzFfVR/3f/wBYJ9grq3NPOy7gVtqgtrxqH2v3Aua3JdGiBRoGqhd9ScaPuGPlHflOPpGopLgFCuuAHE16lrjuBDyu0BTdACFUaryrMyQ76judZeonqRVW5slAgqTqEUBvMlCBblwoRJxaGgWPUEAQAkAm9bkQGziLAFSiA3FjyvrUjQS7ukFziC4cQbC4QFfGmkeO0XTW5JWxBNe9fvj3zLdBB7Nge5Zp9a0KCxihwDUB8Ba1fuX2D2v35+V7J7d7jLjDG2Bl4w7qbtcRy+FOe89TgAUsE4W/+FoqiiAUS5NwBtAUIfqNbiuo4DXRR9l6Dg0oLDS4JsgW6UFsLJqut9LkfdXcK36QCup5FQovURDQpJT46ogVBepDCkMczh3+yGqPtBvUA7z2YgmTIIJadVLghUFCtrV3PV+ojJHou95yY4PE/UrfHSkzViAas88CbtwTaPEHwr1Xdxsrv3in0QgKNxN1C38aj0clu+UQ8ddANKmIHqds/nNaArcVF3kC7GqhXTxqGT/MsaOAkzc/tQKVXXnQdH6uQhRAdP1LuonM3I4gjQaJTcjJHbcQkMKIFC7rN4fGk3iIknvO4ALqdSQPsqXtdk4+H6iWTLTXeC0AOJJVxKIKkae+7cQUUepBSyKeppPxppmZOWSQgbpEx+oAhVgNgClGAt3S5UHmO1RvME823XX4UO7JNJEJ8ddpAjalkWcbgifClhw8Zue/OkZk+6RT7jle2TQuI9rGOf0tinmgKDR999xEOB7RJAcjFZkOcZcnuhS1zE3AgcDQHt8UL27cdsG/GLV4uiupNq2NkyYx3VEKAhblQdQhFATpM/Ig/VSPsgswki1rcBUj4Zi6K0gE4cbuIQNAUWB4pUjHAzOcnlAbbvQNIPALpTmPlKxXkBB7vP6R/wCVQyRCKZ5gEUtiT1n+LeNSQp2WwCJsBHQB+Fw05V2Wv9QewDj9gFu0A3hVBxFR47YhH3pgY5JHHQAHW6oPFFpob5kySNikeRuxtAvxXSsmWCQLFF2Zoz/1eQCigEAFU1qPckXnb2d7rQI0Fq3ULwproV3RkiF+Sw8QgIRUFO9Q8yudMYVmVwBu6wsl9L2qMKI5QqOkKkAJbQWpnej7EZ80dRW2ioECfGul+pI1VyAqqOXUcakaHtAkCxdIFzc2CKqUjo1fJZUVpHMKbeGlEknYYNo3XUKipdPnTwLGXpKp3yrNFNktTnbwdsxB1XtqiJoDWx23bE7vmODHClbfUblB/GoYtx3PPeMUBRwFiW71Xc7jUeflhuFiX2W2kIDwCJ/XUReJcghpZJITf0vwKXWp3e3TNZHLCNxkc6AbLKO0Sd6U2CHHEjm+oidM2xysY/3R4N2qb61FM3EEGBEAGZGsmU5FIcb2GnOmQmInI7W4Df0tJSxuQDevWNyE7s53RTEh24dKEhLWtTJHLKWF88sWQCAkB+oIQFU6DkKmJkPaLTukktlCVLFD0uCUNoDvKDLDtqBzW4Q86idBZ3eOO8tGhAF33uotapcbB7UZ7wdIZMhyIAe+2HhdPhTtp3wkB0RlsTxN9emsaZzYzH3++Pq1KhCBctr0jIbSocgKOahD+HhZak72QxensBCARcltkqSWITB8O3zFKIquO0ruAB5VHKyY+b5ylWhTzLiELiKHbjhjHZ4KQNFJKICBxodyXzNDOriGEC7QSrSSRTx3XRyQk6/zOUW4BoWjjyR40jWp3TKpubo1DcnglSNjigigJIhg0ycpoJAO1dFvUImDcMjKIF19S3abA/iI0+NNBemQJ3GFp4IvOwf91FzrOL+4Co7zr/JDresmD232zsYMwxmTwTT+rmGdjxjv5zZSVDZrqAUHKmbXdJaNshCfAKmqD7K6CIyXpukuOLr/ABotY3r7ilyaronOkUPXw2lb9Nh/spHCz/xAA2TRyaFBW66hVC/FFW963p1AkbeARbckoPKAk2lsqlSAgqxvuudU4jW51rvXU2OpA8QLC9HxW6gfh+XA18AfnrypAQA07guq8eepNbyqr4Jr9tBsbSSeHP5rUZc4EOPBUsTpe921fzktcpodLodaBcuKoBUNBFrgWVCUr6Nw2jdYIARqAgBJApsI/TOIA3j8VxuLl4FKyZopyR9OnABTcWueNNLxwS53ci6/hQGjQV6QhsfxaFbUL/gvZUv99jVx5CKXJx6SnOuwDZVVOHzRQlJtNvD4+K8KcEKpxF7AqlNCkKATpaylbkf7aSAqApKlbkko3cpU1jywKmMR1bixUcqAj6javafaPfp3Og7hP6p7SQLG7XOUaWWsU4ExBymWCsshuCQfxWAShBtBaCAWtNxcWcm0uU6U5oA3Wc1SFOyxabkC1CchTIV4A9IUkF3xpA8hU3PIJVDoAClk1pcYOH0t6CA5NLKQQFrL9298z8XHx4DuARQ1oaXOXc4Au5175/2o/wC3Xv0Xrvd/avQ5uXh+5xgbnvRAGqgIsa92/cHuExnmz8nvlzlcV4kkn8R+P/jNiEsShIvZCRYa862OFxdLW/0/628flXdkOpdtG3wUWKggg0pBAFhayp9qlKRD4og1WyDhQf2gSzRpICp1aiyk1ePioJ13aE3Th/Ct3SDf5EqqAA3oMCAAlb/zanmaMWv0lEA3AC6AC52isKXGGV2pIB5BIV3UigcloMhDhMANsMBUkoPquFPOj/3M9592xvZv2LP7639pe0ZMsjHZnvH7sGO7I/yjFwA7fHGjD1myVDjMjx5WZGYQcFR6UHGBaQ5xBIVPtqD2XF9u9v8AbPefV5w9x/cUrp/80939uyYkZ+2mhDij25vA61LEhhhchmDB+oCmwC9KNKaVLlSZfqpZsSDvzj/+HIxmjZoHIeS2qbuzdoGDsuKonEkIQF+F6yTFPNJL3R2pEI9Vj4y6r9LlFSxBrpvbo5PVyTeSJBk5CpAWfiClKegLskNG6a/qcTIYSiE2IIsnKmyZUnYyV39ifHORiuHYJxiQEO533UJBlQ7RCXxtRyrf1beYINgPGkB7sMpdN+oDgQqj0d/+nJHGsJ8KA402PnxYs20tIx3hIAJVFiPG1ZeTlyDa9xk7DAmIAgCenAawEAIEFRl3ejm7/ZhG7I24veu1VIF+FR4/rcuRneTMmmAdJjIL+kIJ7zV10rJlw4oHRdiD0XZBHfjFtzt4s4gL8amzsyKZhkO0wvSQZThuXWwuF8KyX9ps8URWWQuarYlBiKHqJ/glbfbxkxY49OY8jN6s4Tok8DkUZGKv5XhSB4JVE29riolKqV0saynPcsAQzEJYKQqaovGg5s/dbACkMN4yALKdSoSoFb6YRaBh7Y3SlLLxT5VLJnd4Y8TTA8gn1WWWoWgm1mpY8hW0SwSTNCgR3AhNgu3UgWNOebRyQlkcUMJID1Rzuq6gVEO9M9z41MgQI+3QARusOAp0M3qHxd8wEWXcquOhNieFBovuNpZAo/Tj85QDqLVsakq3NyifzHQgKFoRNcQARvltY8ioVHUk2rMhY5LFpabBEB1JQ8qlk2k3IEaA7W25rY1vgCiSAbhr1cyp4H4VLG+MB0Y7/csSPnqESpIHydt0qneQCpUlAfgK2DIBa9VfMLlCUN1BbUeflY8Ax8dzU3o6PKuoWxIqORjMduCXOGwtRhvoQ24A4Lan48rD2pIiIpW68CFS1z40S6KFwCQRTOV3pBwCIquS/Khnw3YxW5MUDeknaomUKm4WNH22L6YVdGwhYTu0N9HAmpJhL3ZZiZTrYauBcfAVLDFjIZEmO6zSgALuOh+dAeTtPfDztcfwlAOI8RzqRsEna7p9NulB3dxLqUsKLZ5seRw6XSBX8EueFeV3ZXH8aIEIW4ARAONTd5re0YMfZ6cDXtWBJBO4FPBKgjM2OWEASiFSmnSpKqt6lx07RxwvAgtJDupdD99d6WTurOG9oqLnQk8CBei9yzdr8uLIbfKdxCgFL1kKfOP5MI/6W4LlS5+NPjyR3oiphQd47gBdbFd3DjXalIgjjvsshaUIW5uRUg7Hci3GwINyEUA2Sg5ICpPebc7cX+Y8ChqGSUAmEGeCy4zmuXaCdSUNbowdygqqtGMgLgNQ0+ApklsgS+pgxluiA9SaNVdafIUYIYfNmmvk2chRDdAPjTHxnutilD2yuYoI4fUSE4UXberv2i8X2AITQKq07GyXgztdGSYnh8QBO4+Lg1p+VbGgbA87Vu7Xxv8ACpCxUaRtLtpkcQLqOf8ARUeI1/XkOLWBA3QbtpPAi/zoN1c5xaq/8KlDba4V9W7wNrnW5NjShRyS/wDXV+lSqKt/9lbib0eHEAeH9FdSl3g0IaHbBHh9vCvxfdXbHA6KQvhpotAuKDinx+JoOaET7v4V1k8Tqg+aIaW2oUnRSA1VNggFrUYASbqFsA51iFueHCmuhba+qgG6u0KINK1M7f8AkE2OihDYEmt8P1ISVRbprzNkouBIOthqTbmhBWoSSVOg4EpoqqbCoIIYUnmsVRNdV0411OR4OmgvYf716Lh+ryFN0Ab4Dgu1fGj2IQZBqNLqvAEGxvRCep0JAKW0vqCQRQOK0BwALleXbdGoEQKSfuoz5C98DpuDcAEWBUBfCh7jBKIFvuJPBEVCNoslYcGd7gw+ma9AJnaFAQVJAtWOZ/ccAT7elMgOQGx3biuvA3qCb273DBySoCLuCakWS4BWsY5Puft0G5QC4hHLcfiUFedd/P8Ad/b8QAhWOexjtykWVyiw5VOIP3D7fmZOPIWf4ljSAQVUNcVvyrM9n/Y3ucONikTtJxPdpHbidzQ4lpYD0nT5Vne9fuH3PKy5Z0a9uUXORCeBLuNxXw/1t4f+PIhhJaMlkYkVNYHiWNDoSdtxT+6d75LFwQczcaC9fBP6Bw1pDbS17rw5606abmFX6U1Oqi/DxrsxRjsFAbLccCbrp4a0WFQUDuokBURCHXcQv2VcC9x0lqX0v4mtkOnigIW6qgFiK2yOuAljYpxJCqVoSGMXsBpYknlxFLGAuqg6ArZqaiiLHsLtLQmoKDiTWPNkb+5FMYHEGwcSEvoENSSjvNjQ9yUaDQ7SQNHc6ikj9XHHMHHsmSTJw25RLQHthLu014GjgA7xoxyzgLYkAAkakkldCNFrHghcZslqSyAlUbYLfRKiZIDlsQ+TjkHbqbuOm37FFZnpRlR50cOPPNikQFygf4sBAEsm3W9BkmOUnPfBAJUh1ksNTUuc8ThuKAJts4AsVAIAsq3ThUPqMXHhIxxAGYgRRqHZjSANxHGpA8iKPSxdKIBYKqqSf4GlgYZCna7qb0jNwUJ1TwtUbI4RGyR31H9QiFfWBBYgghKDMrJbtbjmaRGrk5ZTaxEAAAPDWn5JkMIi3O9QYFLsmVSgUr0AfKseEAPcgyAk4nOVjSTt1enSVHyqSGLs5L3ZB3YsG4u9StkmFiECJXt2R7kwS4uVPBPlYEJHqvTIe5r9KOvWZlZEULfTQQRe1x46AOxGIMRrm2AyANeFEnsQwSI50Q3Ndi8QEX8Rsajc6IxOM7nLjOUGJAmlyPCo53TjtwQmbHKNOn1WN1C0wjJ7zJZzvbYZSvCj/dbf7KkbDjKJVx5ZfTltzyCgkpXpO02UE6Ke8Iz0k7RoAlQB0hnxh3oIJQFj7qLtvxUceNPwYWGaaSY+tyUK4uLd0IF/rICfOsbHhdLFIJVNgP06J9Sak3os88i4JItkgaJ/sqJykRWCLGEXgACo+NRiGLzBMT3V7nlBu1IWi5Q0dhVXXZELGclTzItapDExCC1sl0d8eRaFpbxtjco3G2Vs00QhC6keDbhCEQlLJfjWyFIpZQ1QerhZxIuAQOPOpI3MahhA7hU6WQA6kn7qkjcAv58ocbuIARpdayEC1TNI3BFL/qixTpbRQn8aVzRG0weVKUcDsB4FblaZFDP2u271EnY0O4BSV+NCF8+PMsSdmQbTlePd4ALR2tIgCEyxXRdSVQXIoQxySzOlk/USi+3GQKHoOOl691dE8xRRw9qJWpjYzCNUsqg09wl8psxbHMiq6NFdzRxtUmTIgdKEa8Y6+mC2BXxvfnQf392T+oL8dOnik4K8W16dneuATKUT1QuB3AoAp+7b3kKytnWNQQqW6jROREd0+4IPLOU1LEcAErDLfKH5EEcJN4SC4hx/s13RH06wS8HINu0i6FeFPnZDAJGATm6NulgHoDWbPhYm+L2+3uXuAK4uNoW+rKgaFEWpI4jDOYbOdCpVQA4hF+6jCS03Kdn6vTDTp5tVLU2SMDu2Dbj1X9kniW86mkEndkluUtj+pAvcIVCXqHIJdJMhglu4YpVSSAqr8TRbMRDHG4wja4A2JF7qUGmtRML+4E9PFoChXdckDilJ3VhghGPDaylQ5G3HE/0V5S3JAnsgUFCQvDlXW2FfT2iAH6kkkkoPpN6bLE0ncTjzDqOMAp1cem+nxo9yPYGjohuiDw5f68KEj2y5DQEkId5jgLcjcIKxsTHc2SSXcTvO4gnQErrcV2sh7XSkXCoeCgX4LrReAvIfTYlTamOYCxzSTG4LuBTq6tb0XSWU3UIupoOcl76hTdBa3Ck4lP6OVBLFLqhvw28wVokc+Atz+SV3B8xoicuSH/Ra6f02/ppXqfsWhNM5S2QbogSA4D6lGtGPDI7SAlEQEKoJJGn+knckf9r6VIQi1rk2ppH9og8lJGmqJSEFv8yXCnwdoorTUqdo2jnqFUJRevEa69QvrY/1UsQIKICoJubJfQE0PcJiuPiOIeCl3ErZfE15ykNKtKfhKAEJa+tIHOIA2poB4Jck0h2iANJVNNeSNXbSXQKU6SSBoB8TwrpKXUgHYFsLA616yaxdtIRQTxFiiglK2zuXIy+JJDbEBT+EFopxdMBuB26fV46oK/T5AxwTqupJ3ajS97138f3lm4gC4cU6idAbEHwrFx5fcphcICxzlc1BdwBBHjWSIs+IoqjtOB0VurgikcKyoXfuKTFOVdy5brA9LdtwAranm929+ysm7uu5BJX6VJFxx5VN3pmy3OgQoQdRqVNOa9VIBIN0466X/wDhGGMn7F4hU1v4UfeZ/bX+it+EN6fqJaSL21r0MMCwFLhb8NQFsRXuEmP7bj52Rm403te33DAdkj24Zl/8yQEBSluRoSZEP0taEbooCbioJJP3A0OniANzT4WDUBQ+PKnQsbwsg1twQqCvzqDEyB2Lgd4gloGpdZeFDHi3TrpPyS/VcaaUWtBijCE3Q7hZRr03oQmAkqVnBFzo0W4kijFMMmAy5Qui4wDrguVtra/Gnr5nARqPTlq30TcSPGjlTYZiigAccLvo5LAgXQm3Copf8txszBTvtgAcCCQQfWIRodK9Tt9MIz1wOIRwJ0XjY12oZ0sDLjgIURQpAUFStY0uJOJ5Ycg+oE4CgAaBAFaRa9D/ADOXGPtszkkMLQfS4rnAdPp1JIVeNTYHt87nYcM7ZzmBqj3PGcAU/l3DTQkVMXtIbN5cfdU5IQBXFBZESmZITyiG/Sq98AKBqSo4VFHu2I5XTtsg0LTyCE8Nalwm48PbimmYSR+qBddSlk+FQhw2I8y91zlWREAChVOieNRxx5MLJ8icy5kU0IyMrGxTckNVLr8albFNvhknXvAdRHaARNQL3HBK7kOTKJsPtuw4mIPNyFyNQEItzqXIy3hsx6THM5fPJQBpBRE+VPdLtlkjSGNxT07GgXJXi3nT9smNL5LXiUNSUi46gdCKjgjaksQM0QBHcN1Du5b7Kjye7DLM/d3BkKGoVCABEGtAtJkdKolIUzg67mFETleony44UaSyZKeUnSClgQ0LXfjMIyAU2v3dzKuEcL8F0qVkLgAAZ+0QQJ5XNAcmm0t4JWD7d/hcfADi7JOOz1OTNIComlBImKOQfCsV8/eeeykUyWubNIbo51RyscJcmS0IKfp8jgSCUI2n4Vje3QYpy/dM6Uxe3sx+lvcAJd3C47QBtJKkJRxjPjzuEaSug1xMsFJ4ORIINPBJb54MYTifu/DxqOXb1xuPaEyNOSQSoiB1DfHWt0rCY5SfKNsnGl4uEWoBXhantaCI0Q98qQSoQEEkEk/Kmg/m7j3CApNl6TxClaaC2YgAHuFwCA2V2mgFSwMPX2fKcHcSeq6It/lTQ8GIJMO5MsqoFAQAg7iiA1Avem2TEEE3Q3TT/ZUeM6bsn1N8FCD2SgTQoECXob4gWykdnsIZG4q3BPC9RbXntRQzjtydJbIAPqhIUkAqOFZAjY2aGNqsAPp5Mok6jggNSey475srLmaZcwwkfo2OCCAxhBZdaa6S4fAsUM+mTkg6DaAh+FYr3xzQiYpIq5AN/k4hRyqTIyCIW98iOEhXW0TarzbhUjGAsjn8koE1ud2oC8ClSGMEmGZxNjC09u5F9Rb7qBPn/wB+RAPJHcH0NcQqiu2YmxRawyuM4Uqqk66/bQL4e2Y/PEgEzcT1IN116zypkck2PJOApsRjhQoPNLVlx42RkYmLnucMkY+QRi5QBG1cU3sRQfJGnSCyUc0C7vjrWSO1OFInjmhBQqSVBuHALpXeB6YYFN7niB1HTnyqSXtYscKd90UHJUHEhekfOimSJQZkkjbadw2mwSyA1JDHIvacSmrrqbgcjW3uEwQkAzcW5J+kN4omtY8jDjHsgBB/1J5ogS5otK7pikqbS2wVG8FAI40Htf8AUcnHfK5fUNxjrqEItrqK7HqpzBG3yBYHJx++t+LiD91F0uSSSCAnWSEOljpxqNrHI144ICRf6hwuK9TA9jJwTtalyqKfqQgbdaDstxyJk7YcxpU3VAp0vSKSfBNvLXW1DlpZUP8AC9HS6n7AFrp/2+Na/cP6q887WKQjtV4FNdafexTta2JReFIlyQVJ43smiXpyCyI4lLC5IavE/wCkIDu3XN0uqoh8a5k8OCf1A0CEQiyc9CPkn+m3G3Kx10SthanC415lTqBpXiSl1RAUO02Q8KSwLVW/ifHhpUEPUSC0cXXLghBS1xWOMqBw9USUS5S7nOFiReg6GAOTaCwLodAE+ktCV3pWnaG7iLIpugGrilqGPDAOyUQqQHEWcE5oKd+ieQHXLhYKONiSKjU83AquhBTwtWNEV7RDWpcEbWAFugTnRhXaqXIIcrUQgoTc0kx3bUcEKBwCkArfWpVsHEbfDhbcpslfsL/td73+68D9j+xfub3p2J7p+6c9xa2HC3MaUdtcjyHa20r3f/td+1v3tgf9wvZfb/2xifuH2v8AdeE9z1GQ8t/ywuxQ0bzt3EGgd34VQE9SC11K/OvpAPEIF5WKcitdk/2St7E3KanU13gCn0tBPAoLtvqtepaSQCGv5FPxAKOB/wDg6fx/qr2vBF/U5DjuIVFIagQaX417L+3fb/bS0uxA7IyeJBYASqAglVoDHwS0oSUc7VeK89UoxTRFmRoSVLSRoHLqKVuM2do3KNxBRFsSgRKmyMZgDkALUcbqW2H0hBXcGOEN1Bs1dSAeNdzsNuLcuWhTlQlJ2rcnqTqNgnAJSzEdkW7tiL8gFJ1pceEd27kW5ACKFVBxr2v03VmdXfaT3/U3KOH8vLhpSTCfDk1b3w5BkFxsR8PlQikmM5up4beYRLA/dXZxZg1SEyCv07uIQWFel9xl/KR/cA/xYJB4Jtavzoth2wxRAA7iP1QAAAUq5VFSJDAwEnzLgELwN0+dRHpYIpj2mxf2wFVQhCnQ0YZhLLggEuIn3ZOOVV2TicS3w0rFZg93NOXjn3KCTGI7+TjfTlOdiwrt9PysTQkXuOasEORu9OPUwcHR20ZbRFpzpJAB6giHaf7hUJUXVrq9M2J0srO+S5rUUfylQDM+9jQlfG7DhEUE+O+eAiVwainaT0kka6gVJIJxO85GRM7vC7HKiOKhUT+FerAaRjLP25x0vyiL24tA+0UsMvclKjssiAc3epxgpCkheOgpm5HEBYpZgC8FVyW4gsQfiKjL2ZEQkUPimIPqu5ZpUEoW68K84CSUwNdk48PVkdhthMCAAoGiXKVjTrPkP3rFKxARiuaqOCoCBqtOIfLN6uA9oTt9O7FKkXJsi/OsbEx4IY2RN2ZM3caxnd8AepHA1G2MzIZjBN317XlAroCoCcOFMnxYoPTYswMVp97b3mQgLcIFtT4+2ds6zh24HbKoMtxwQIh4VgjEjbvzhjCKOe2HkyIF69APnrUwkxfTw44TIfkFo9LOF2ixVFFiFtWMWMOWI0i6MYkYsbOLigDdyakqlRyROlgfu9RI5uRtkB0PVwBby4Wrvuj7z8kEyyHUDnqA5OJpAsri0genBQoeC+IvQe9dkKd6OQ8fqUKhDqGU/rJga1MvoktZBtPJENP7cZJhm7pMSkYuqC4Ico51G4T5CO757J65b3CWVHH7KkWAwusXA6hETaNAU+yikPlSbp4pUDQt2q4EKCR4UyOOMsieRJ2mFf1ARxlumo/jQRha3vXjnc7vWS5Qgm/xqLMglmhyIpxscjv1BBQ94FEatq7Xu0YY/FJLBjttkqVXdwa1fuqOUvfLNGdyRxypkpoCG8uIrFGJiOxf8xhGXG8gEelI6NVc1wJ0KU6YZBE2T3xlGc/4peoC12jSsXuNEjGZAMu64xQ0qCCvUFHCiyd5cD5DZMTGErscxfTK1oAVSOGi0HiAu2gdwH822moA3HXneiSZu60DyQdyAlD6tLKKkY2GGIOHnJaIn6lChQnhXc73bEsG7Tt2NlCBb0R2p8sSuCTT2AGMdF0B+y1TYgla6GWcA+2hNxyMjTMBPUgBRFtUWRk5UMET8hrJsCNTlDGBRxsUBH212cJZIwrmS5CqiqjQRZTp409kjemd5HaIPqgASQVUBLfZXYgZA2NgE2OqTkAqHAucAV+NB8kqxNV3dA7xJXchQXdusldmKUz5c7u/mwIMZ2MhUYt9SgW2tAY8mMHN01CeoWxW5INEwxLlAkEc0VSXWOld3GTtTgCWAkOyPVrcuBKIAfsqeKSXsxIVyOJVquBAChTRZFDujh2md3Ik2Qm5J1p8YHciQgDpAFlGo1Cpag6aTtzqLTwEObrbpXSjGwEOeGtb4CxQcEPHjSxrk7OiVp8oxNVNwNlDU+dNLEmkNgRcFq6OC2IW2lbgQx7hsfFE0N8vt/NL01pZGLbAZIz8QLXBXnxpRtUKP+IaC4soo8VJ5i4VLoqW5VFJ46WUID8tBV6t9+2hyv8Awrp0T+k11KNVI+5La/8AwtnDRQE4qLm/Gty3/wBfvrBimCDexXIt15FdfhWLOcYdnHwg1wa7g5CCrRZQ6lmx90JaL3Q7kS4RLHxNY/omNxcbFaLl5Nz03BCn50bC5B1JIJIGqaHnRx7F2vUACiaqAAb1DoofGnA3AXxNOREACEIgRNEtcUARu2hOXjfgCDW4FVXUkBLhthqhrvlCFJLrJrfhoF+ynTeq9NPipl4uT7c4sPFEc1zXA/BPuqX/ADP3r3H3SXK/+t9wlz0abIHSue7p5aCk7af8RtX4/wDX50L66oiHSx4aigXM4pqBY811VK7AQFDdzVGhA51K3RrSVHgoT/8AN/4Qui3oMh3vAe4B0mpZbZbgq0e4CE8LfCinEJoD8uFe1NUNPfg6iDtDS6wNiKw/UODJMX2/BQ7UDQGtKBNdyfOsoYeOi7SSiaLuP0kfTTsn0zQxyAWJAcOJBRerjUoJaQ0OsARuVQABZAUrLhnx2pku6BtVUsCNOdDtYoZELWVBqdPBKaYIwOJUJoCrQCAutK/FeNyt6fxWsEVENDJD07Lgi7g0nVCL3BHKpnausgkJJDnONr+NZsUKd2ANO4D6XBCCARwJ5VmQ5OZLkDII7z0DQCjdqKFFxY0/ubZQrW5PcDRk3Gh0T+iiZocmHsgQTyANyA4gbgqaIDX0QzOjJ7mQ4ko0kjbooIB+VML+xGRM5JVKen22BFgoVPChqNxKRBXaXVURD/A014P6ZAJBIQJRLw0RENX3Oa6zZTZSGfTZEUGsn9q42N7ZC/P9zg9yd7yPb9/vOBBDrhYnuRaoxMki4BHwqWd2U4ubOYDkSsOkpJKjRQNbVCI3huK+WeBmUSsAFwSUBLdD8K9wgxvaT7r7s8Bn+ZyZDR6XshN2JuNl5JUORNlFjlMZb1J2nfhYGlrfG+hpW/3gHchegcgGhP8AN99YwyMgw4jzI+OSMCXoVAAwXIB51F+o88WEnpkIHAs7GrkPHShE5xyMoP8AUY7xjrmZXD9S0/S1Dy4U5uRI6KJsEIfFBjzy5GV6k7ggKlV1AvUvuP7jzO045Bg9o9ghHp/3Ec70xOJ7+cgtB/y3B0OKdSaLX5ALryZEwB7hcVPU2xbcqRREkoyoxATG9y74lVU4oTxFkr1DHwOEYEJ2lShvdSV0+2pD3MhhI7sMM+z9OL3ULrzNN3Cex3SPGQLoqeBuOVH1bjHiyzjusYv0khCF0QcVFYXtuRHBL+3MYCDFxwSona1WohDx1eOtZOYyUtfN2IJIl/5Q8oz6t+isuI/3sfYyIka4ZJkBS7ls1a3s7AASD00gQIR5KlnEn+FRQOZMMzJI8oExj0xN016jw0rtCGCKSIqH9/8AUaX0s74c6LgXOZI8CSKcAAzXAIQgEnlXeY2WbKhIORAIO95Rtov/AJVLgY+MYcfvd50aDvOc4rrqWj41nPyME5k87e1jKn6U8RewJruAGESEydtWrjobk36vhUjVHfJ729PKOLHYDUHcuicaa0d0T2nBVNUCkroBUeRGe42WfaVKi9lVeGtIHCVwcg0/UgWJ0sG/KmOkkx5HZQd2ogqlx13EfSOC2rBysACKb2yeCZkSCRokaFIIc0tIK66VlZ3uU8eVLluVkSMx4B2/wtaAAE4AICaj27pA3Tg4qLhUJsqWqfZF5klu21S3S6nTdUe+TsyRY7jAF1nBU2sQoNSyOM8cglORHGi7SEVbaECpJmwzduWLy44gp9Sb/rSqc70+SEbsZ4n7TWp+Y7UXstqkDY0ymD07ZSLYxIX0iFQinWo48fAhwgXQM9JEf0wyYPKzM1ycc7X51uEInzACGytRw5r1XIC2oSzxCGReqIBcs5R4u4taVoyECYs0cq+mbqnquXgRT5SspukYTaTtsfEA8akxXyAHD8ibvKnnlRdurVHwFSDIQIB5JG5CUDSl1aS3XxqbuxkaTeq/Ep1sAo27alTquW48jmi+2ynktE40yyqfUwakHRt77jfhQll3N08wKCHa3Q3Nr8aERm9PDL3y446oNt7BFBdtua7dih8l5Fukj6rBVaONZT5ISGD8P1Yy5HHE/lcpW9SyOJVxMA8/fkrZQLHneu+IAfboBA2SdvW8OP8AMwKdSKnhiiEvcd5kxHmBvBS3wre1jTAwgmOG0wdr6iQ6JcinkuyQ3b5XbLh5bgZk67DSmZ20tZuHSdbKNxAsRa9Omkc037jQNJdEDtUNew/sjP8A33+2P+2mN72Moz/vD99zS4v7c9o9NjPyGMzJ8aGSbfkSx9piA3IqOP2rM9aweognf3myMa7HyH4/qIZGNaJW5Gzc230EVr9wrfy42PhX9r5cvs0oxIqXN7aXU8QlbmAIToRb4Djx0ovbD9g8dLi5FbSoIcjynEffYrRHL/xpw/0e3z6pKwlSio9y31VDXtGXjj/E4LsC4AJIuVbfjWGJ8YFzUCIXI4KLk2OlHGicAMkjclzcg7QANCaMcaicNQKyydNrhSFvWJke47sl85K3dZfpINgE8KxQ0ADUgHpVECqdQlNxoLdC25BEJOlOtqQenq0CKoAqHj1iw5EtB1WuxjEJ08ghQKo0uprsDiAAANEOtrXrvTBOLUCJxPJBXTGOAQJw8dCeNKSfDkvUgoqCAbhfqHNfA0sgUBdOVtRevcchxJOLg6eKW+BU1Mdbr8TxUakL/CrfaD9qrzoXVfs+1Uq11Wx0NgBpwoeN/h4f6S9AjFaip9SLZVOtW/8AIX++sPHht14eoVCoVU1F6gyc0AH0Xt6FwudzVIO47i0fctZUGPgf4poHfICqNCxqKlqObm70IAVLE6AEFbAmv0S+nufpJIB4A8itd6HU6D5agm9jWPDkRdSa7HKFClQUGo+dIYTBtsSRtcSqkFAFFtKLnDuY5I7f8tl4KoKrTpJiiNAUgC1yhBtUTsWEmEhznq0EEiwTQLpQhI7AmxnT54RdqAtC2QBAKzcWLa3a/sq4IpYpUAIqDSg95Lk+vi4gFNNEKV+lk7cb/wAyJCXcB9grdcHJxx1j6VU9Bav1OPMLULW7PUd1C130hVUcSNoF63MZ3SJbCPQsfcudYtFODGQ7vrXVknSnLUGscMc1jXIJO4vU5xOgAsUFq2MBlcJwQwlyARhLLwNe3n3iXIbhxSE5z4A4OEcbSXJbWvZP+4E03sf7Y9m96k9u/wDtHBgyW5OR+8vaPcPb4cmTN9xk3D0Pprd1AbmpzmY5LmTOBTRt+gCwVp4c6LGwTR5AU9s2ZIikaix+ysn0rg0dsZkrNwOS17JFMpuOkfeKanaL2jeHzKXkSG7iFLSEvWM3DbIZGpkSEifGxyQvnsLvqbTIpXHLzMh0Hey4CPUYu4oGtybi3Kp8sftyX3j3H25kkXtvuMmQMduNJkBYs04rmu37Qb8KOX7hCcrLyDkyy5M6tRsJ4GwG21hrTJeycmQQ7tzf+pC8blbG9QvjAljcIztVozMVVABCgn21amx42jFyNv6uIp6UlwH0KjVPx8ajTsyQvSCS57itCoHElQEpsONIGZDp+9HFmdN2oEHBHfeaxYpR225GQGhh/JxMYkAuzP7IJVab7f7dmjMmwhLj+6ZWGk3t+VLK0SYvopbt3NcUPJKl9vnkx8DOlxgcbKzv8DknGIa72ybQb88aHwqLJgy/RYw1j3Q5Xo8spuhBDx6gnQchWB7g3s5jDPkZEeLMO5Hl9iwJIVQCpFZRym9vNcroi429IboAdEAQJTMiXaO5AvdjudUTnoUWo2SyRPEExyNyFQrQEJ03cqlwcX2lPf5jkfrp4R6mfFcRbuoQiaUjyYo+8HFJgV1O1waNxQ1Htk7Ym82ORTAbKigOB5/GtkTUl7Ij7s+jt4UI35U94XcEbJ39p1ItYiwqY5EqJtgii/8AqgEI7TuH9VfnEvi80QIhF0RFuqgfGjHFFNFJEVlYZQ2W4Bto0318KypD6HJlEHaKKjWyG6LbpXhQkkjAj7PYH6gkKgN9uiCntilPkzqCW3PEajw+yi9iAxkKQba8AUAKVkxiURRQiNw7GpzNSGkrqdVqSVluyRPIJkCK1NRcqRw0ruRydo+ndvyCqk8Q0LckjSu5eKUHsmJUGWQVDl4G6/OpTL+nZIzy4Y1KZIKEgHglT5DphJHKUjnlIH0tThqTe9Nikkh7cX5djf1B0a4ku051ECTHi4kMwjl/w+StkSxB++oHY8O2OVPUZpbcHxJ6lteiHSpMYTP3ETEysUnaXIND8eNRthy+1PKBAJb7WW3HVW3CV2I3dx00ORgdqe2LlmdwBJNySgJp4lk2SQjsFir+mC49ypRSNU0qUIjJPIK5ZdjDG5AkruJ+2lhPl4yiVhKKPmm4Fv3V6iENja8JiEjsfqOPBVaPlXa9Ynp9xmNkyiQVcVVdU0qSMyW6uy7T9IQuvxFeljIAQIfpHxDiAiCsYer7Goeqn1RCAjL2qL8CONTeUAqr9O5CA22psL17R7f6P2jDf7HFm43dwcHse4+64ua4kZ3vOT9M5xlQDkKkASaXIx9s+XAVx8YBVLeZP21+3P2k72j2zExP27gTxMy4YAz3X3nvyCdc0keeDqAtbnZgYp78QQG9+m/AKnhU85erUACIRctMgsVAW4tUjXSXeAHM4yIinmFSivW613LuUj8IcbKvDlRa38pfvsFHj41xQ6L4WodSr/WePxFD+v8A0O/c+c6cSiZsvtvtjcfutkxoQFyMjd9K8fCvec+bMxGZnsGR3T7dhxpHi+3Tub3JC78Z6jrxqRsJcQ8DYuhaQ0oBZNy//CbMigvaCF23Xd8tpFY/tM+QjcZ7htBUrFtJs4lAU10rG9tBSGYDLG3bq0AltjtQkUcjGxgDe7giK4cDa6aVsGNu9vxiANo2bkOpsEaE+FYvZJ2446sYDchSx8RbhWKiFPwjW6DmoahrGyEXZt1UghzF4IQoovA6rgtDbuCKQRc6mtz7ORyAdQ042KVO7Xp2lRcFEDgQVVaE/wDMbXBuASFutjSofmU01QcNacERbKU5eOnjQW4dfgVv+HgRegAHAtUDx2hLqBcpb40XEaaA8QFPVwsRyrJyJ1GR7jvUKCgICBAFQKtCa4udSfEX8fsr+0QqBOPzpF52NiQlvgRX4lC8ONL4qAnjppqP4UQUCXI/pHD5Vp94/r/0C6XH2ca9hh7waPVRgnUIS2w5n+FYc8OL6l4w8I4u1SitYV0QrQmnxyZw31Tk4oEII4hqJWT6b25zoccIiK0GztSEUfMUIQxx0aWAoBYEtUakOsK9uglH6c5KBQOk6AErYFeNOwp4PUZjtzslHNJDQekNIUAigY/0wBOzQqioE0BNTxtvMEBbtJ3KRqosgoxybsloeAVXkot4br+Aqb1+WcBMX9McTDM7TlciC0iyAE8K/c37lnBbFtnxcbIc4IqELtRRur3fuyvm/WLGXlqmNFXRBWl13ANHV3ANpUp9nKiHeHbcugH1dQVU/ophAnDHBZSoTIMegbx8aagY1zZBucFY4lU6ifw3osx2nabK0+UOBDnJe97U1rGEo/e3bZsnAjcFsByo26iD5QTkiL9QIrYriOzG6cvVsu5uhhsAQRb4U7ExwW7h+pBRe0QGkf7208K9s9h929/959w9m9ggMP7exp53yw+1xnX02LfpcQNaVNzu+JN8mh7dudynDnQcGzs2t25DWosTP+c0KDc/ZTJWsM/94A0+WgcFExW42jSp8rGlZGZZTFHCSe3jxyKDc3IJH31AzJ90mwfb8aJ+CZn4/Vj5oUgmQq/sO4HS9R4+JHORFnCCKWa5M6rl/TqSLjhUuLK5kbDi7sN5/v44QAYZlJIJBTnUcxfkMxMaYuJgJ9PjQEqinqK/OsbIylhljIGFFjEkSBQN/G7t1xWUZYYD2sYRRzAlXbgoaildUNYomi9RmFD25j0tuSEJRA1tMkhxoZTJ/hcVUORjEAZmZ4Jw8KidJhqANsTfT3KBBdS5qWHKpe5J28uaM92MuP6bEsjS4A6jmtNmxYsjZFL3n4XpzHqvbyGpci+tQuyJe7tSSaOwOtx/vM8Ctd2JJMeKYuuSvdygQ3pKfbXtmJ7e+bJyJJ3QSxTP/TBt4XBXbdG8RWP7aMnHzHlySzOscUoT6QEfV6Y8L0OxJCyCVIFmfq6O1xwUaUYxJjl+Knqx6gHHIKc+khPvqK5kjkyD25Aqk/ylEO3d8BUgkjLwvnyKLO4AcVK2qCJkatlV2LDCVyTO0aO/shppgyJupsPei+nVSdt7qHfOu7OYWNh77Xhv85HE6XJ8a7vc8iFIS4hGiTUFSv1fbReIGsmIjG5+QFGNxeUJDSUtQnXZICTjAXGUGqUtYW8ajjb9UX0x8eJLbnTWj3EjjjCFpu71Fk4kObf5VI05HqQ6fzDAB0lU2uXUtT4Vhuz4j6DKPe7JQgQqnrmuFiAvwFS4ntUoyMfGFskY59RlA3c3qAaXDmKlxnlSVOKXKpUf4UqlnX+ddyNxixZS784efhy/ykC19K2SyiFxG3s/9OioHICS0reoZXyiaU7sdBACi9IUhUJoMihZNdOyT+ncb6ElWka/GpIRjSiVRLGJyqMddyEEK0A0gIlN4o58jaVcRrhgElBopqRkpKxqpnJAcmjk4LUkWDjTTdxwdLkhrgwYYIVqkbeCUYsgfn5O3tAK3EBaqbk+q330fUTnEgxzBlY007gFeCVDS1SSSNK9vycuTFx/cvdcV2QIUByziKB+qYtlNwqG9dpN8ZmE4OQD4q0rqARblQ7yZFiWwfT6XUgLZXfaaYZXYuLkhUELCUAsrh4pwoNjBIETQdytb1HRTbh8aMkeH62JrZoO76YnExRYkroS0c+NDso+KaB1xCbPIGpJADVsONRdvGyCQD3scao0p9KKgJJ+Fd30yRwZHW9qEX0aHap9tOhllSRrjMJIlLXl3SAQlw3lUkZPcjlW3U0OUkqPjTRlTHyg4xAm/a4hstySnCiO3scTvMCDqiF4G3JK9K61M5zi10igxQsKpZCVQLW7cjlJBNn2ttdwv/RQ0IuEsqhGnQca42/pP3UPDS68v6v9BDlB/h8eNA3UEInxrG9pxXCY5O0e6hymXuFjY2gIFCpwUV77k+552Kfff3Jl4+Jje2yiL1eVjZErXvkjDOpvoYW3WsvKiJdCXERKSAQ0bdToLfd/8L/X+Ne14QlGPDmZb8SWQkjbFO3aXBbH586xZfaly5zgj3HHyGoTdu5zQfxHcdOFf5lkYx7GSABbQjmulwaycn0ybiE15bOrkb6UAhOQSTHORuubkIEQChPjp8xcbUCtQXAGq0yCdSehEOlghOtlPxrJBPU1Tu0G0Dcb2PTz8K9zyINhnymBt0RAOGnD4VM6dFJPAIAp+SJSG2nVf7UuONCQ6lQg+ZV4HiaNvpB6TxUX0JsCfjSAr/wqCf7CqQi/Ci4bbX3AoguTay7hUMOmRloD/ZwAilBYA/atY3t+PlBgx2lCUKAtRpI4kNA+Ne34/tX7T9Hlt/bZw/3BmzZpzB7n70cxzh+48PqTBIbtHpgOGlHqCgoLXKcUuimiR1HiEUjQ+BulC224sh4/gXgRQt0tAVFQ8OofzChItuSHjyII4V9f3/8A9tGx4JtHwReHx8a1CaXW3PTjyr2LNny/TY3+Z4yyNu4AuHAdSOAr2H3DH/VJ7IzaURGuhaRcr1cbCknyFJ/R2sPxFFH0hDX+U4VvbsRr0KAEvRDu4lQeNT5IxxCm4FbApYEHQFftrJnhJcbk8AVNi4aAhK9y9fMck9O43NksiciPlWfnSKARaAiwPBAVW3Gv8wx4EjLQrdwH06Kn3rXdy8a6ElTq5L9LUaP4U0RY71T02PuBPVlFOn+YBftrH9vinMfuGdg+ryQXOIAc7iidScNayJ5JAS+YOBJ6yFUHTlxo7esGRN4sL3HK970dw3BiI02A4KvBEosDkaxpkJJGkQVAqIEr2E/uqR7PYGzMHuToy5RAupLRuBAFqxcH/szC6L9sw+3YzgJHZUmXPlSRsM+ar+oEyE2H2UoeoUb2hVh1QoeJHCgCQGzgxMftUl41IQKAUod/bJAJu5JEm2U7AnbFwtzcUMhjYmnZvJjBH4tCtiQDTZWNEj3lgRmP2+sDRRY0xzwx/trX3x1ISQ6uBI3ICfhW6I9Vm7gvVE+6FLKtr1LkblcJE7UVu0QFt4KKMrCIW5LQXdPbFrBBxcDeoIfZPejjtkB3h4Le7lIjhcEBpFlNb8l78h4cZDvepVUJiubqPiaOQJTG4ybbkCxAAvGqWF6ma4Bkgg3NAT0kQhCEAH6n+BuaGV2J4pezjuZlzIQOKtxLoorInjjg9Nj7zNl3gxsc2BJVVcT4GjjRyHzhjl0pdd1yf0ZT6aiQF0swSOKaxOMl2jkvxqMmOKMuiIG3JQdyAFcTLUkqlwmtRujkBilHo5twLm9pC7bcFENP3yDIlxyRBKfqysNSBhHioRaZlF80QM4HpSgAyL5Km/SLoBpSf37lWAGy6MRtiQo+VMd6qGPJER7rMe/pVFixQhPwotyJO7lGD1ETZCk6NN8x2rR89VqJu6FgLTkTL5CI1dyakjUipp48kyRy2hETb5ZB47vp6q7h3Y8roOxKFH82lggPTwqQeqHeN2BCigKNRtQfHSj2pDHlxd7IkkYDq0/3LioIJrKdkP8AVYuROJ1kmO7Fy9puTwY5q+ArudyCLGBPeNlaZ7RXCqV4nhWNh5smyNRHJFADOcpdMw6IgqSPEhEOFD+ndKwkHL3Cxurt1YzMaX0sOMe/LG/qlRE1N1dUZyZFiUrIoQBwJv8A62ppjyXHd5XahBI28b6ql1vUOazsPZhTWx9pdjZmKCjm5pBUlLc9azszNxe3gy+RgY2Enp/bDOqHCuV9suNdDXe2zHiwtKBQRxF1aqjSoZZh2pnHtwTDJB2kaqboh+dMzGAYrZZxgzXAxv8AM8VfS5hJu31oafA1su1xnImceQKOQJoSKhZDIXSRzBPFQdSBYEUZHJFt/LR36YZei2Ov2io+7IZGPxzDGHWNinTYFBeom4/ZhQOhIuQACSCL6lKiZ3u6Zcjpg1VHAKSdAXU329IcSOGB2VNDxyjkG3VwJKW0FSyZHkzsy/LjW+0Kd4OhLW6C9Qe/e6e3we65k53ft72SYquMCCfec5u7g7QH7K9yzcuczZuWFHqG+o9IP7IA27bfC1Y5GR6ghBPAJwFKoutkNwKljkGJNDN58OReADI4AEXT48qWaXtib8mUpqAhvwAPOmxSZAnZEO+4jTKAFvRuFlHwFT+34syYecuRkzvCbQLoNTYjhXddN6zFyDu7wO2AEabRZ4cv30JZc4wBB30H6oA2AAFnEoL8jW0HsfFUVeIUgqimoe12JpDqrbE38LFvCvTNyp3OD52t7wHqBdVUANa29vCo3Z5d3U6HvA2kbVBh2lNwApo3SMYCS92h7IVS3juIFbh6jf8AglcQFQ8kuUovPSpCBoH92OSkXSnSWDl0HIKNDYm9f2rjx/qrmn30RW77r8k8a+376ZB7LNixgflyy4zZMiNxCAiXW3Dkalzv3F717h7lkSfW6eRURQ1sQHSwAcvnR+P/AMPEz8d5jlhna8EHRCFIAsSE+6vbP2979+5F94wonHFGW1GhHJtc4IEcDccKT9v5JDsrb/mvr74JAQtb7Wio8nlWLBjLhZOYQFTf0hOlxRwDVC3oFP1X0HJCXACgbQgafHlQgVWoW2I4WK8bpVscDxJDiCOCJdSaTAJ/Vr6kcQp6i5XFAtZOEwnbtFx9/HjRRTChUlwVEsSNdq/ZUBlBUEtRBcc1sthTgnKzTdHFAb/CuG2+uqkhSoVdKBVXG5TXgU01NKQgT6bpouvJBU3vU4s7djYyC4AB+lpAIF6nc7wAcUJLQVW5IQg/dQEIGqopAOvUo/jzo67iCiWUWBP+2ggufpuTe10ReHOtxP1Hbc23cem1C+iEAkC4RUtoaLiHJqBqlj4IlEojdoCfZpfX+ikJRoU8+C2BW1K4HaQCEHIhD46V7T7hjOcBj5LmvHTZrjcgmy2+NYP7S9xy8bHnxcCHAxTl5rfrLQ1dd4ANZHunsTXT5WQEJI4hoLrtVobtuKyAG+pyF/VkkgE7kKB3IVl44HpmgjpA10UtTVdabge3AZXqnauRvC5JCogdTseZPPQZWTfcV0FrANNNxX4rXZV0yALjk0ki7S21boYRqW7SgIAUKgB1r1MWKe85zhiANIDbkbiBwJHGme5+9Af5Z+1sY5eTMBf1wBeAjUDj0/Csv27DyzJhYWyDYqKFclmiyNHwraG3CgEoR4a3vSkIFG5rNFBQEpzSkm2M1IPC1m6U1X7i8nRUA5qOFOZnskexx/NYAXW+geAFCdheHxsLY1A8sE9JANtKa5f1Jk7krVsbq3QpTJA0OJfKjQWgIgUAW6nD7qDplWPewtQuijKpYWPz4mn4b/NDtvYQntdk33L9TUX4U6WT8ggMQhRYcFBtenMQ+Y5WABA29xwXGP2itkMeyEg7mtKSqD+TfxH2VEZI0k7hLjYeXIfxFqKiVFuyTEMdm+LF2pKXg8xwKVj5Z/wzo8gGEbe6ZWnioufhrUJmZ2iHLskJJaJFAQgoABwoBokLQO6YmG6lCAtwKndJ3pI3jcZNikTeLf8A0acYsv1DpIehr3ImU3X/AHTtqD2xkPYx3NE+dkY4U5V1uEsFCGoZJ2NleS4xyw9TWh3+EaVs21GYTDyiSADuOKShA4lAbV6WHEmyMh0LZo48LFnkcRCSMmUiDcdjdS5OFdvIkT00oj7UM8OTi+598Ar4Fmh4tIqV8MkAjc/yQ5UCf4lrQ3gE50zHniMgfkNkhiH6g5f/APBBELdx41Dke5xH2qRs+/3PvuHqsXF/Dgt4OVfjQmwx3ITkHHYwC+N3yUc4cQiGsr1ccBixgMZcLXJdZDcBGjbzSoshYY5PUFrpXdQsEAIUq0BLV2MKQyGNA4weUgJTNQEAaVO1mTumjh7UZnAO4ICqmyhtenkiVnYmPeAU4qOut13E+NHGheEy3si7s/8Ahx3bABLgp99GWFsss8qjKk/uMbpSIuBueNJjI7FtDmdW3GKkgBoK9RRBwWo/QRCN+NjsHt8U1jiz6OOYQbgBSK7Ja73DMM/Z9TC1cZUO7KuhAJ8OFETP2sAO+bcMi4VAUUovCnxHJWewLLNG0C6BEuBUckRnhSEtLYeleBVAqAcKjjZaRVMLFO5t13G4eeYpkuzHhxmtcrSA79KgUBo6QhC1HHHL3nlQ0LcBblB/ChEhEQaMgh1v48xUmPInoPcnCHKa1Ex3tQ4mWAU2kEIorLkjHbyWz9gH/EY6DRQq3AvyqWPGKlm2WWTFQHVSQSFGlStj81hIgK3AylFvAHnW+WWCVmESgCWP5JI0JI/jQR88TYslYkb+qacqzRtTT486OVDib0K5HqD6b0mV+SpOnVwHE0GvwJ3Sxgh+NKFUhAEcR1KRzqP/ADOJzMWPKMO36nYIORYEN1UHXlUjMaQmaGGDGgjUocXsggcR1KNKdLmywThserSLztCtwymqW8K9THdcrvT/APTmyAKUIThaxrten8qa4OupUEWJA8RejJKvdTsiD/EB1l5oAnGhFHB3soBZgC44oaAegkFWm1AlxiJcBDhH8J3C5KEX1qWGVREycTCTd0lR9Ia3gpQ2qLZ5c7B2Ll3p9qklRx1rHjiJyJSdxvcFQXC54E1NK+Xct2/FEuNFB/hTMeIwGbqnycuQo7jOG3uhFtadLKJYy5XB6+SL8FWziLU0vVkrX7NoKW2/m/7tBwc9zkVHEXsRZugvVxofuKf11+JVFhdQTzBJBPOsLLd7wz3HP9zwTOMODHkg/wAnzYnlnost0jts3cX620nElPny56n/APBM9x/buflYz2biwMeR9X1EHkotWF7N++Jps+CItDpsrY9EQEAuBdpz5VFLj+/Y/teVO4B3fYHXeBxU9ILkW1Cf2P3b2n3P1AcQcPPQBbohJQD+NDscNei6FSQ4gA/ZrWR2IGuQ/wArgFTTqQWArJcjhkbS0XIKgEEbdPCh6odJBci7nAuB2lbqhrgim4JbZF0S+tfd/RRJC+nABvoqp4uRadoQ4HT8S28b15AUqB3jqAqPtdbn5VkTDL9U7GQbAo0Qn6dSENhTYYdzccBC1TY2CjaQFKDgtf4brsLhxDvkAVtXf9znb7Zi/SuW3p/s7SSC5p4JpQT3UZJsW5IaFNuSmwNhR7GU0ka2U7TqVVAAtbMLKGUQF6Qig2KAWVDXfg9t9Sqj6HDQhA1AVNZAn9vzMa5shbopKqOCfZQVzhoq2RLLZbIVp1ybNH3gHxrj91v6qMjVUWIPLQg3CGsHN9my86CTGa1iCRzbseHLY7XbeeoFYH7T/evusjckyATOzPdW8WBq7pOThoq3o+6ezS4eTiqf1OKWEdGgOwlSQdaOM4+RjWGXiX4EBo+Y+VCaWZMWzbN1RFRLhQL1jlwQJtuNSERboNhCijGjpO/bHCH/AOZSLX0r3PK91aPVAnewkBPbFPFyEoCtgq1kN9ud/k+FkWHvOWzaTgE/yuAAPL7ayv2f+0fcIMj3v3DHkdk5WNntX1QAj0Di4kkre1ZfumY8yS5Mz3uKk21CEopvXx4/01P7m3KxYcZmTFiPhM7X5wkkCtm7Flx7a2pGne64LyAhuUIbdKLW3VQ1r1sT/wAomwdTR+A6jjGY/rGtjaiGu0NmvXYOIlUG331HASx4L+pGdxpW3I01rw5j2ESMaVC/3guoXThwqRsjW4zy0v7gvYEJuVt/utRheSGhgDJAEd3VTurqMb+yqCgMgT7ox3GyAntygXOioEr1AyAQ9GtiuvaUAkXIUrRYHMG+TaXElv5SEHgRfjoaYkasaU3HjyK8fvosc5uyQ9ySRAQhP5YVToNBUX+XifsRHb33rCAeW1psEd4rUcLHjaLPkkO7xRVJTdYGsiRomgndGCNhF0cD3RzaBwqLLyI5YnNb23S4h7YmCBhIjAADyGha3RRdqUECWGUgY+S5QGuLlXQ3+FY+6WbNhc10WWYSoxiSu0KS0jxWoz7We+yXy5I5kCKhW6m5Br02LgeihEw7jXN9Tl5OUnUDZNo/hTZf2x737xj/ALnzzkQZwiX2/M9gxsgI5/tvuQLhne3Z7Sf0qBEN6y/d54fcRBCm5srXBuXBkpAc/wBpc4I4hxXKRUNSdrsNxR5D2TdeScmDQsC6utUOXgw45/cc0HYk76TjCGQFbnNBG1qLrzqWbMyZ5cgNByoXWysvV2TndRJvw4LXt7cPJ7Iy58dgE+SYMoepnLepDcJzqPGxciGQe3ZvoPcW2/uVKkjVSdadLhwbjCLSfX6oLxA02Co2480srhAZppYLekE6ki31rfWsaHGf3sfMVwmyN0G3GVxJJBXXxqWBsjZUcTI/b2kRAMtLbkNqL8fy3TRGDKCBOlC3MHDUcL3qLEwfcJjJplSwOTIsCDYFoPS1eK0Bk+4Da2HvSYghJ9TiqgzCSSjg776EmNkkTRnpCEK02ROO4JUKDswk/quGTjZPwFjuf91I7bHJFMTL6e53AhoOiFxF/jQEWKO7MpbxyS5edkJTQ3pe6khDVhF8oZA5uB0UVkSx9OQ3pY3Q213A2GlSmUBDtHZdwXUcr096mGKMEyiLHHqQCoDieCLfmFpZMkmXBAix9pAxskqgB5m/jepYmyXUd5g6jiuyCSC3apcP4V5Uw/zCFWzDHAOWew0KSArSSL6XFdtzoO7Kpb/02ipohKppRRYCvnBpP3IdD9teoklX6YA29iQCoTibJXf9TPDO8D1az7gNoBYQDoiDSsN3/eH3XGb7BguZ7jBhZ2Q3Hw/dfcmzxEf5rlSuDQxWjThwr33B/wCy0Iwf2rh4WB6ubCEM/trv3S3FTOHtGVEn/toBuedY2D7fJPly50sMTYIv1OWQigqhXXjoL1Jg+6ZML5YHR4+U6MgzWXpahKkaGpY43uiaZ+7Ewu1DDcoouW2ojGbBGXQocWcqQRy1uCVqN+Vl+UjfPaCSDysuulq2SDKSQdM7luShUJcjjUzhmh51kyIGq3J0VvIBOdTTAAyztXt7TOfT8wBo0eGlQyRRiAbj+pchcBoSGkEkEDSpZpp172Yk/Tf097IVIKijBhsMd1fMEU/yhb3++gxztx5oSbmwOnGu0CWqCCASjlFyU6jevMlPJjVJDNp0KlETWnaogG3cSgGgGvCr3YCmtmg3HwK15Z4cOdvssKt+WoUpZSDZTayUv+vy/wBCEEuXT4hdSNf/AMH/AO2e4ZMA6elk8zSUPAtc0ioRg/uX3GSCEnZAPcMkAA8CjiDYeNETehyCOIspRUKGyjTxoYwxhA5S4oUBBCBq3KU2dBxJ6rbtSbleNLu3OFwCP5ifAtrRdAByS6LxuKd8P6fjTd38V1utlQAGjxAsTdS1boulqZDC1oA3EkEuRbFQv1FaMMGQcZLXufEFSFB+1KJK6kler6jwC3BrGOdCcr3Qf4TDQKXORN21bqeNB2c8EkpB7bdMALqBoUOq12VuqBwAJRANAD/5UAMVCoU2uCfxEcT86xntAdkf/TLZtkKkWLj9wpzkGQPqxsUoAVG1PG9YsPvv7WON6rqGYCQCSpCEtTT5pX+ZYeOXY+X3DtTUKpI2ghoBqYQttt4pytrf6flWt7m11AXw1CVYry4qEsTa4SrKi9RJJVdUW4WocjByp4XwuaWltyoQgkqjkqP2P3POmnwQ5dhdIzduLQpBJAANCb3H3f2z2zOyWbngSdv9cQLdV9p41/mHt2Q3JJKg4jmva1pBLVCncHDiBWTmwyekaLfqs9pAJufqcBw+VZP/AN0fvf2bF9INxGN7nGOlOBLiAW/xrLn9vzfb/wBxe645/PzvdBmAnVNrWkoDpWV7Z+0Xs9pwnvcWnFMiJ1In0D7Kl90/cHuGTmzyO+mdxftDiSQFJBBX/QgVSQOY4HwvSoF8FX71ppcGhSAu+/EomlnGtrtwFkcbIBysCqikvuTmdSeelKxQT08DrrdNKie50Ykd3OkBZQQiGUanUIdKPqHRpuHmPPmAgdKldL/ZTZO255bIO/O0/wB39AhLboB9hp7O+CXDbEWRggBShFuGlAB/cY22W0SXHVtKEKWjautqjLcp5dlF/wCk7YBjBHlGQJ9RC02cBpD2owyOVrddUIKKtHzJUQtaRrw+kBF8K9QXiMwiERn+9JuD0tVDQlzPc3GTHlAggA7XeLyNX/8AoaGi+T07C1NkQKxbNAq81+2nEPXHDz3QV+oi4aASUHCuyG72NKiONyO5lDwuFrc7uSCUv7Q+oC6N53It8qxoM/EeYIYskSshVjp4ipWbUEr87UHY7R2rdvKRDjhbQIEG6/3VHFjByQjInkBBOS2cq1rydQNoqFp7GUctdzZsgDJYXIAQlmjlpXsX7fyfdcvK9p/b0OT/AJJBkz+mOM7O3Oz2YxCb2b3cdddKjHuHRJjA5L+x+p4q3bpuuQut1qOaXGh9xj9RjjKxpsg4mNk42SP8I10HEC+utdtxhlncuFEYYD6gY2NfFwvVaFzdF402IogDp+7plYrrjLBNyCCKJyHhJdyvE4V2PdMokgkkILc6fNhTCXaWuleD2VAvZo/EUtzqFzu/EDP3SPp3NPnlXJf4V6cxB0MZPbiMAU4pcE+Km9SySYhjklmHaEGQgAxgNClgUvQa8QSenxz2tAPU5PA3U7RRyZ3D2+KFpgglgKeqyrj8V3I0a8KDcz3ADtP8uKK+Xl3c5XEAnZxI5CsuEP8A1WcFwg4cMZHFQEuQEqGZew+MbpY7C6AKSvEoajx5h25I5z3QQmQ7KNwcOxDkRUNGdkxXL9SHTO/THbpoSC33K2pReFdySxQN7yo8lpQkr+IJUmTHDkEPXIDghBdAnVw6VN6iyJJuz4uKbToSRdACaytg8uUBZAXH1QJAQG/2CtsqAOmWDHJLNoI1BQD6Vt41LDFKGSQFWyw65ONbUnW9udd6N3amP5ksIcm3RdFco1rFlj7OZMD3oiCdoKhSQSo2rflUs3rMc9/iFA1PSBe97U2OVNs43YSp/isb+YfUAQqKltKVyQywG9iQpN917OBH9Ndlrm58WbaOOfh6dNyhqIAdOdNZLAIsZ4yIZX4wRpUggbF1UAE07P8Aanf5PmyeV32ocrsyBAu0oC9oFZcrxNLmCTcMiSTzULitiSoJvTnSkZEwZ3GvsoD1vrz1qNzSxj12lzGlAQUCk2qNsrh6Mlof0g3JADrnVzj86wxmQehyoMnye+47NguAQtl/gazGiTHxfWtE+RDBj9jFBaf+l3cXJXakYMeNob6ebHILkS6udoicuNQ9rzZccGA3W4B3OUI0i9AxpuU9SWTchBaE6kqN8bTG3gFVQFX43OtANkRbBR8Rqo3KOddGh1NtDcak3NFhtKCdxsm1Bx08UrimoIXw++9QsyZBhQvk2y5RidJ249pIkMTeuY2S1MfCeoE3QI5oJbuGrlcEKcFrYoA+xE51bda9gf6KV1//AMCqW+f9X/hcAWtG5yrYm6IvwoqbgEr8781t91brjUdNypbtBIJThXYmyUTiUU7St1VF+6p+PUQ0tKIWoF8a3r0orOVil01+FbgWq4KEA2oBxGobtoEKgIK3sF3c/pvXS1QU3KOBP8y1jiA8+v4uQqDypMfEGR7ou5oN7gAEnUWVUrvk+rmyW/4ni0i/Hl4XojI6ipsPqFrX01dXqGlQbk/USqIihLtNY3ZsdqE6XIChbX+NehIV2qqfpTmCdUKmsYEDJ54wcptcqUHSE+NYuBk+ixfbsY/piTewQ8SVXwSp8HOAW4xiRZCCBpoutTmBewF3X0Qn6UTWgS5SSUDkULoQ0aBaMp6SXI0XudUNjw+//SoJVVVupNRy+3e5ZMToXHaGvJHJL8Cax8WD36aODGQNAiElg3amtxXoMb3/ACsaAKNu1oPVqqG+4mj/AJn+5/cXQvBDoe64RqSriOobVP30uZly5JuT3HPKrdDqoWhpx/prbr/s+af6DdE/0O6XG4FlQk2churqR31MKvDbm54W2hG/xq4QrdTpxIXw50Q8Pb/uC5+24qIAR3Z217fVdRcgoV512gFtbqsp1VRcpXVog5+YVRCBoTwovYkbWJHtYbFi/wD5tb0XhQ1pb3HC4kLz5W7aLhdFob+t0bXM8zqjLUJCXW1MDmlsk6ks6kLgbrqAKA9UIzjODmASo25VFQKR/TTe0/dLkzp5pI7dlLrdKAKa34cncfF0ASBYjECVCa2v91RDtgsQbo3qnAEhL63p03tMrWCLtOfKZBG3bIBuhLSbgLqlOD4zkNLQTlhySSFCsXDRfnTHY8hx3Fd+4OJUGzQC2yj4VEjWxhtxvJ4g6XNlNMZJP/l+0bX45RH31uoBctemjxJziz/Qx043ILr6skFEumlbYIm+XP3t0QCZLZ+khwPFNPtqPFw8VuW6GZqRS7snKBPFLIwHhwAqP27NYcX0k3YjyIJgcQd8fS4hSjhqDppWTDB1zMPTLMXT4uM4anDF9T8UrqLoYxtms0j6SCTiodzmlL1I2bFXKkm74yQO+TjTCzHNUBXIOFqjfiyQ910IayypkKBlYZUIBxr0XkYmSydzu9EU6rwlvUSHNNTsyX5EXaNnzg37pVzl12gN4LaliyRLNO0vjuPT9gWxm4pJCO5jWjHPkbpWz2WzcW2gciOX40ZMd0AYZSZTP9RcqKOVwq0HZ8SRGDsyenBKE/TmgchZay3Q4cGa9sHYgM06DGyshqjMaTtVpF0uhqKSWXuF6+aiEISOki5uEXlUsgix5Df/ABG65B4fGotieYCRofSZDRuVdLJa6EVLFnAd7031yjbjZJARpytv0uB0S9elyhrOicriyhUFSxQpFN6lvmkdXo+oDp0vwpnuEjAMWe8U06EgD8O2+7Wu5FK3EeYTPiBA5vqsZf1RDrIUsKGTMs8cso9TPMU/VcEaCAAfsWphJ6h7YPPJF9t0KkXAK/ZUuVB6mR8OMvYAA6XAH1QW56aaZJDkSwd9MXHH6owTp9TVU2uUvURN5Yk7pIXFbi8FC3IsE1Wo3TSiN8p4LtCBQQQqDaPjQkinx53Dz5bWKEr0pcpavVt8mObpsS5O2QETUbiakjesR7ydwIoHD+C17T3ZDHFnvObNLAh8oLGHcyOdCG87AS85COPqWuJG4kXQLpRkgkR7bvK7vJKBC7Qf7KMMMW5jIUmELS+5KCV5Ac4KTrU/7h/dj8j2b2DCw25XtbtjZH/uH3SBCz2nEAJeALlSBYVl+5SyH9b1Bgaf0iFGtQmxRAU5UNks584CUlxUCxO1UTd4U9zZ5QwE9vuG9wl28r2pjjLIgXaQSPHlzrcELR9XHWyIUWiI13DUkkq35+NHchSzUaCAbCyaqa3RrZSnBD4eFBq2YVUquoJ+JNbPd8Zvt2R2IM6LDyMhhzXYuYwPxpmmN7mu74uhvzqNuQx8D3sjmjZI4Nf2n2jlCOK7vlR2n6FPgU5Dn/oVP9eZXjXSvyX/AM//AMN//9k=");
    this.blendPass = new WAGNER.BlendPass();
};

WAGNER.DirtPass.prototype = Object.create(WAGNER.Pass.prototype);

WAGNER.DirtPass.prototype.isLoaded = function() {
    if (this.blendPass.isLoaded()) {
        this.loaded = true;
    }
    return WAGNER.Pass.prototype.isLoaded.call(this);
};

WAGNER.DirtPass.prototype.run = function(c) {
    if (!this.dirtTexture.image) return;
    this.blendPass.params.sizeMode = 1;
    this.blendPass.params.mode = WAGNER.BlendMode.SoftLight;
    this.blendPass.params.tInput2 = this.dirtTexture;
    this.blendPass.params.resolution2.set(this.dirtTexture.image.width, this.dirtTexture.image.height);
    this.blendPass.params.aspectRatio = c.read.width / c.read.height;
    this.blendPass.params.aspectRatio2 = this.dirtTexture.image.width / this.dirtTexture.image.height;
    c.pass(this.blendPass);
};

var ShaderLoader = function() {
    this.loaded = 0;
    this.toLoad = 0;
    this.shaders = {};
    this.queue = [];
    this.onLoadedCallback = function() {};
};

ShaderLoader.prototype.add = function(id, name) {
    this.toLoad++;
    this.shaders[id] = {
        id: id,
        name: name,
        content: "",
        loaded: false
    };
    this.queue.push(this.shaders[id]);
};

ShaderLoader.prototype.processQueue = function() {
    var shader = this.queue.pop();
    var oReq = new XMLHttpRequest();
    oReq.onload = function() {
        this.loaded++;
        shader.content = oReq.responseText;
        if (this.loaded != this.toLoad) {
            this.processQueue();
        } else {
            this.onLoadedCallback();
        }
    }.bind(this);
    oReq.open("get", shader.name, true);
    oReq.send();
};

ShaderLoader.prototype.load = function() {
    this.processQueue();
};

ShaderLoader.prototype.onLoaded = function(callback) {
    if (this.loaded == this.toLoad) callback(); else this.onLoadedCallback = callback;
};

ShaderLoader.prototype.get = function(id) {
    function ShaderLoaderGetException(message) {
        this.message = 'Cannot find shader "' + id + '".';
        this.name = "ShaderLoaderGetException";
        this.toString = function() {
            return this.message;
        };
    }
    var s = this.shaders[id];
    if (!s) {
        throw new ShaderLoaderGetException(id);
        return;
    }
    return s.content;
};

window.isMobile = false;

(function(a) {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) window.isMobile = true;
})(navigator.userAgent || navigator.vendor || window.opera);

var scene, camera, renderer, controls;

var plane_material, composer;

var target;

var options = {
    valley_elevation: .5,
    noise_elevation: .5,
    speed: .4
};

var uniforms = {
    time: {
        type: "f",
        value: 0
    },
    speed: {
        type: "f",
        value: options.speed
    },
    valley_elevation: {
        type: "f",
        value: options.valley_elevation
    },
    noise_elevation: {
        type: "f",
        value: options.noise_elevation
    },
    offset: {
        type: "f",
        value: options.valley_elevation
    }
};

var clock;

WAGNER.vertexShadersPath = "/shaders/vertex-shaders";

WAGNER.fragmentShadersPath = "/shaders/fragment-shaders";

WAGNER.assetsPath = "/shaders/assets/";

var dirtPass, barrelBlurPass, invertPass, boxBlurPass, fullBoxBlurPass, zoomBlurPass, multiPassBloomPass, denoisePass, sepiaPass, noisePass, vignettePass, vignette2Pass, CGAPass, edgeDetectionPass, dirtPass, blendPass, guidedFullBoxBlurPass, SSAOPass;

buildScene();

if (!window.isMobile) initPass();

update();

function initPass() {
    composer = new WAGNER.Composer(renderer, {
        useRGBA: false
    });
    composer.setSize(window.innerWidth, window.innerHeight);
    multiPassBloomPass = new WAGNER.MultiPassBloomPass();
    vignettePass = new WAGNER.VignettePass();
    vignette2Pass = new WAGNER.Vignette2Pass();
    vignette2Pass.params.boost = 2;
    vignette2Pass.params.reduction = 1;
    dirtPass = new WAGNER.DirtPass();
    blendPass = new WAGNER.BlendPass();
}

function renderPass() {
    composer.reset();
    composer.render(scene, camera);
    composer.pass(multiPassBloomPass);
    composer.pass(blendPass);
    composer.pass(dirtPass);
    composer.pass(vignettePass);
    composer.pass(vignette2Pass);
    composer.toScreen();
}

function buildScene() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, .1, 1e4);
    camera.position.z = 7;
    camera.lookAt(0);
    scene.add(camera);
    clock = new THREE.Clock(false);
    plane_geometry = new THREE.PlaneBufferGeometry(10, 10, 200, 200);
    plane_material = new THREE.ShaderMaterial({
        vertexShader: document.getElementById("shader-vertex-terrain").textContent,
        fragmentShader: document.getElementById("shader-fragment-terrain").textContent,
        wireframe: false,
        transparent: true,
        uniforms: uniforms
    });
    plane_mesh = new THREE.Mesh(plane_geometry, plane_material);
    plane_mesh.rotation.x = -Math.PI / 2;
    plane_mesh.position.y = -.5;
    scene.add(plane_mesh);
    renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false
    });
    renderer.inputGamma = true;
    renderer.outputGamma = true;
    renderer.autoClear = false;
    document.getElementById("containerCanvas").insertBefore(renderer.domElement, document.getElementById("containerCanvas").childNodes[0]);
    renderer.setSize(window.innerWidth, window.innerHeight);
    clock.start();
    addControls();
    setTimeout(function() {
        document.getElementsByTagName("canvas")[0].className += "animateCanvas";
    }, 700);
}

function addControls() {
    controls = new THREE.OrbitControls(camera);
    controls.enabled = false;
    controls.addEventListener("change", render);
    window.addEventListener("resize", onWindowResize);
    stats = new Stats();
    stats.domElement.style.position = "absolute";
    stats.domElement.style.top = "0px";
    stats.domElement.style.display = "none";
    document.body.appendChild(stats.domElement);
}

function update() {
    controls.update();
    plane_material.uniforms["time"].value = clock.getElapsedTime();
    render();
    requestAnimationFrame(update);
}

function render() {
    if (window.isMobile) {
        renderer.render(scene, camera);
    } else {
        renderPass();
    }
    stats.update();
}

function onWindowResize() {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.left = -window.innerWidth * .5;
    camera.right = window.innerWidth * .5;
    camera.top = window.innerHeight * .5;
    camera.bottom = -window.innerHeight * .5;
    camera.updateProjectionMatrix();
}

function animateBody() {
    document.body.scrollTop += (target.offsetTop + 15 - document.body.scrollTop) * .1;
    if (document.body.scrollTop < target.offsetTop + 15) {
        requestAnimationFrame(animateBody);
    }
}

document.querySelector(".labs").onclick = function(e) {
    target = document.querySelector('section[id="labs"]');
    animateBody();
};